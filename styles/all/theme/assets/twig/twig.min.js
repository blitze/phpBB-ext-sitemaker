(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["twig/twig"],{

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/twig/twig.js":
/*!***********************************!*\
  !*** ./node_modules/twig/twig.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(global, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 5);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function sprintf() {
  //  discuss at: http://locutus.io/php/sprintf/
  // original by: Ash Searle (http://hexmen.com/blog/)
  // improved by: Michael White (http://getsprink.com)
  // improved by: Jack
  // improved by: Kevin van Zonneveld (http://kvz.io)
  // improved by: Kevin van Zonneveld (http://kvz.io)
  // improved by: Kevin van Zonneveld (http://kvz.io)
  // improved by: Dj
  // improved by: Allidylls
  //    input by: Paulo Freitas
  //    input by: Brett Zamir (http://brett-zamir.me)
  // improved by: Rafał Kukawski (http://kukawski.pl)
  //   example 1: sprintf("%01.2f", 123.1)
  //   returns 1: '123.10'
  //   example 2: sprintf("[%10s]", 'monkey')
  //   returns 2: '[    monkey]'
  //   example 3: sprintf("[%'#10s]", 'monkey')
  //   returns 3: '[####monkey]'
  //   example 4: sprintf("%d", 123456789012345)
  //   returns 4: '123456789012345'
  //   example 5: sprintf('%-03s', 'E')
  //   returns 5: 'E00'
  //   example 6: sprintf('%+010d', 9)
  //   returns 6: '+000000009'
  //   example 7: sprintf('%+0\'@10d', 9)
  //   returns 7: '@@@@@@@@+9'
  //   example 8: sprintf('%.f', 3.14)
  //   returns 8: '3.140000'
  //   example 9: sprintf('%% %2$d', 1, 2)
  //   returns 9: '% 2'

  var regex = /%%|%(?:(\d+)\$)?((?:[-+#0 ]|'[\s\S])*)(\d+)?(?:\.(\d*))?([\s\S])/g;
  var args = arguments;
  var i = 0;
  var format = args[i++];

  var _pad = function _pad(str, len, chr, leftJustify) {
    if (!chr) {
      chr = ' ';
    }
    var padding = str.length >= len ? '' : new Array(1 + len - str.length >>> 0).join(chr);
    return leftJustify ? str + padding : padding + str;
  };

  var justify = function justify(value, prefix, leftJustify, minWidth, padChar) {
    var diff = minWidth - value.length;
    if (diff > 0) {
      // when padding with zeros
      // on the left side
      // keep sign (+ or -) in front
      if (!leftJustify && padChar === '0') {
        value = [value.slice(0, prefix.length), _pad('', diff, '0', true), value.slice(prefix.length)].join('');
      } else {
        value = _pad(value, minWidth, padChar, leftJustify);
      }
    }
    return value;
  };

  var _formatBaseX = function _formatBaseX(value, base, leftJustify, minWidth, precision, padChar) {
    // Note: casts negative numbers to positive ones
    var number = value >>> 0;
    value = _pad(number.toString(base), precision || 0, '0', false);
    return justify(value, '', leftJustify, minWidth, padChar);
  };

  // _formatString()
  var _formatString = function _formatString(value, leftJustify, minWidth, precision, customPadChar) {
    if (precision !== null && precision !== undefined) {
      value = value.slice(0, precision);
    }
    return justify(value, '', leftJustify, minWidth, customPadChar);
  };

  // doFormat()
  var doFormat = function doFormat(substring, argIndex, modifiers, minWidth, precision, specifier) {
    var number, prefix, method, textTransform, value;

    if (substring === '%%') {
      return '%';
    }

    // parse modifiers
    var padChar = ' '; // pad with spaces by default
    var leftJustify = false;
    var positiveNumberPrefix = '';
    var j, l;

    for (j = 0, l = modifiers.length; j < l; j++) {
      switch (modifiers.charAt(j)) {
        case ' ':
        case '0':
          padChar = modifiers.charAt(j);
          break;
        case '+':
          positiveNumberPrefix = '+';
          break;
        case '-':
          leftJustify = true;
          break;
        case "'":
          if (j + 1 < l) {
            padChar = modifiers.charAt(j + 1);
            j++;
          }
          break;
      }
    }

    if (!minWidth) {
      minWidth = 0;
    } else {
      minWidth = +minWidth;
    }

    if (!isFinite(minWidth)) {
      throw new Error('Width must be finite');
    }

    if (!precision) {
      precision = specifier === 'd' ? 0 : 'fFeE'.indexOf(specifier) > -1 ? 6 : undefined;
    } else {
      precision = +precision;
    }

    if (argIndex && +argIndex === 0) {
      throw new Error('Argument number must be greater than zero');
    }

    if (argIndex && +argIndex >= args.length) {
      throw new Error('Too few arguments');
    }

    value = argIndex ? args[+argIndex] : args[i++];

    switch (specifier) {
      case '%':
        return '%';
      case 's':
        return _formatString(value + '', leftJustify, minWidth, precision, padChar);
      case 'c':
        return _formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, padChar);
      case 'b':
        return _formatBaseX(value, 2, leftJustify, minWidth, precision, padChar);
      case 'o':
        return _formatBaseX(value, 8, leftJustify, minWidth, precision, padChar);
      case 'x':
        return _formatBaseX(value, 16, leftJustify, minWidth, precision, padChar);
      case 'X':
        return _formatBaseX(value, 16, leftJustify, minWidth, precision, padChar).toUpperCase();
      case 'u':
        return _formatBaseX(value, 10, leftJustify, minWidth, precision, padChar);
      case 'i':
      case 'd':
        number = +value || 0;
        // Plain Math.round doesn't just truncate
        number = Math.round(number - number % 1);
        prefix = number < 0 ? '-' : positiveNumberPrefix;
        value = prefix + _pad(String(Math.abs(number)), precision, '0', false);

        if (leftJustify && padChar === '0') {
          // can't right-pad 0s on integers
          padChar = ' ';
        }
        return justify(value, prefix, leftJustify, minWidth, padChar);
      case 'e':
      case 'E':
      case 'f': // @todo: Should handle locales (as per setlocale)
      case 'F':
      case 'g':
      case 'G':
        number = +value;
        prefix = number < 0 ? '-' : positiveNumberPrefix;
        method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(specifier.toLowerCase())];
        textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(specifier) % 2];
        value = prefix + Math.abs(number)[method](precision);
        return justify(value, prefix, leftJustify, minWidth, padChar)[textTransform]();
      default:
        // unknown specifier, consume that char and return empty
        return '';
    }
  };

  try {
    return format.replace(regex, doFormat);
  } catch (err) {
    return false;
  }
};
//# sourceMappingURL=sprintf.js.map

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = __webpack_require__(/*! path */ "./node_modules/path-browserify/index.js");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Twig.js
 *
 * @copyright 2011-2020 John Roepke and the Twig.js Contributors
 * @license   Available under the BSD 2-Clause License
 * @link      https://github.com/twigjs/twig.js
 */
module.exports = __webpack_require__(6)();

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// ## twig.factory.js
//
// This file handles creating the Twig library
module.exports = function factory() {
  var Twig = {
    VERSION: '1.14.0'
  };

  __webpack_require__(7)(Twig);

  __webpack_require__(8)(Twig);

  __webpack_require__(9)(Twig);

  __webpack_require__(15)(Twig);

  __webpack_require__(16)(Twig);

  __webpack_require__(17)(Twig);

  __webpack_require__(27)(Twig);

  __webpack_require__(28)(Twig);

  __webpack_require__(30)(Twig);

  __webpack_require__(31)(Twig);

  __webpack_require__(32)(Twig);

  __webpack_require__(33)(Twig);

  __webpack_require__(34)(Twig);

  __webpack_require__(35)(Twig);

  __webpack_require__(36)(Twig);

  Twig.exports.factory = factory;
  return Twig.exports;
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(0);

var _defineProperty2 = _interopRequireDefault(__webpack_require__(2));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// ## twig.core.js
//
// This file handles template level tokenizing, compiling and parsing.
module.exports = function (Twig) {
  'use strict';

  Twig.trace = false;
  Twig.debug = false; // Default caching to true for the improved performance it offers

  Twig.cache = true;

  Twig.noop = function () {};

  Twig.merge = function (target, source, onlyChanged) {
    Object.keys(source).forEach(function (key) {
      if (onlyChanged && !(key in target)) {
        return;
      }

      target[key] = source[key];
    });
    return target;
  };
  /**
   * Exception thrown by twig.js.
   */


  Twig.Error = function (message, file) {
    this.message = message;
    this.name = 'TwigException';
    this.type = 'TwigException';
    this.file = file;
  };
  /**
   * Get the string representation of a Twig error.
   */


  Twig.Error.prototype.toString = function () {
    var output = this.name + ': ' + this.message;
    return output;
  };
  /**
   * Wrapper for logging to the console.
   */


  Twig.log = {
    trace: function trace() {
      if (Twig.trace && console) {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        console.log(Array.prototype.slice.call(args));
      }
    },
    debug: function debug() {
      if (Twig.debug && console) {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        console.log(Array.prototype.slice.call(args));
      }
    }
  };

  if (typeof console === 'undefined') {
    Twig.log.error = function () {};
  } else if (typeof console.error !== 'undefined') {
    Twig.log.error = function () {
      var _console;

      (_console = console).error.apply(_console, arguments);
    };
  } else if (typeof console.log !== 'undefined') {
    Twig.log.error = function () {
      var _console2;

      (_console2 = console).log.apply(_console2, arguments);
    };
  }
  /**
   * Container for methods related to handling high level template tokens
   *      (for example: {{ expression }}, {% logic %}, {# comment #}, raw data)
   */


  Twig.token = {};
  /**
   * Token types.
   */

  Twig.token.type = {
    output: 'output',
    logic: 'logic',
    comment: 'comment',
    raw: 'raw',
    outputWhitespacePre: 'output_whitespace_pre',
    outputWhitespacePost: 'output_whitespace_post',
    outputWhitespaceBoth: 'output_whitespace_both',
    logicWhitespacePre: 'logic_whitespace_pre',
    logicWhitespacePost: 'logic_whitespace_post',
    logicWhitespaceBoth: 'logic_whitespace_both'
  };
  /**
   * Token syntax definitions.
   */

  Twig.token.definitions = [{
    type: Twig.token.type.raw,
    open: '{% raw %}',
    close: '{% endraw %}'
  }, {
    type: Twig.token.type.raw,
    open: '{% verbatim %}',
    close: '{% endverbatim %}'
  }, // *Whitespace type tokens*
  //
  // These typically take the form `{{- expression -}}` or `{{- expression }}` or `{{ expression -}}`.
  {
    type: Twig.token.type.outputWhitespacePre,
    open: '{{-',
    close: '}}'
  }, {
    type: Twig.token.type.outputWhitespacePost,
    open: '{{',
    close: '-}}'
  }, {
    type: Twig.token.type.outputWhitespaceBoth,
    open: '{{-',
    close: '-}}'
  }, {
    type: Twig.token.type.logicWhitespacePre,
    open: '{%-',
    close: '%}'
  }, {
    type: Twig.token.type.logicWhitespacePost,
    open: '{%',
    close: '-%}'
  }, {
    type: Twig.token.type.logicWhitespaceBoth,
    open: '{%-',
    close: '-%}'
  }, // *Output type tokens*
  //
  // These typically take the form `{{ expression }}`.
  {
    type: Twig.token.type.output,
    open: '{{',
    close: '}}'
  }, // *Logic type tokens*
  //
  // These typically take a form like `{% if expression %}` or `{% endif %}`
  {
    type: Twig.token.type.logic,
    open: '{%',
    close: '%}'
  }, // *Comment type tokens*
  //
  // These take the form `{# anything #}`
  {
    type: Twig.token.type.comment,
    open: '{#',
    close: '#}'
  }];
  /**
   * What characters start "strings" in token definitions. We need this to ignore token close
   * strings inside an expression.
   */

  Twig.token.strings = ['"', '\''];

  Twig.token.findStart = function (template) {
    var output = {
      position: null,
      def: null
    };
    var closePosition = null;
    var len = Twig.token.definitions.length;
    var i;
    var tokenTemplate;
    var firstKeyPosition;
    var closeKeyPosition;

    for (i = 0; i < len; i++) {
      tokenTemplate = Twig.token.definitions[i];
      firstKeyPosition = template.indexOf(tokenTemplate.open);
      closeKeyPosition = template.indexOf(tokenTemplate.close);
      Twig.log.trace('Twig.token.findStart: ', 'Searching for ', tokenTemplate.open, ' found at ', firstKeyPosition); // Special handling for mismatched tokens

      if (firstKeyPosition >= 0) {
        // This token matches the template
        if (tokenTemplate.open.length !== tokenTemplate.close.length) {
          // This token has mismatched closing and opening tags
          if (closeKeyPosition < 0) {
            // This token's closing tag does not match the template
            continue;
          }
        }
      } // Does this token occur before any other types?


      if (firstKeyPosition >= 0 && (output.position === null || firstKeyPosition < output.position)) {
        output.position = firstKeyPosition;
        output.def = tokenTemplate;
        closePosition = closeKeyPosition;
      } else if (firstKeyPosition >= 0 && output.position !== null && firstKeyPosition === output.position) {
        /* This token exactly matches another token,
        greedily match to check if this token has a greater specificity */
        if (tokenTemplate.open.length > output.def.open.length) {
          // This token's opening tag is more specific than the previous match
          output.position = firstKeyPosition;
          output.def = tokenTemplate;
          closePosition = closeKeyPosition;
        } else if (tokenTemplate.open.length === output.def.open.length) {
          if (tokenTemplate.close.length > output.def.close.length) {
            // This token's opening tag is as specific as the previous match,
            // but the closing tag has greater specificity
            if (closeKeyPosition >= 0 && closeKeyPosition < closePosition) {
              // This token's closing tag exists in the template,
              // and it occurs sooner than the previous match
              output.position = firstKeyPosition;
              output.def = tokenTemplate;
              closePosition = closeKeyPosition;
            }
          } else if (closeKeyPosition >= 0 && closeKeyPosition < closePosition) {
            // This token's closing tag is not more specific than the previous match,
            // but it occurs sooner than the previous match
            output.position = firstKeyPosition;
            output.def = tokenTemplate;
            closePosition = closeKeyPosition;
          }
        }
      }
    }

    return output;
  };

  Twig.token.findEnd = function (template, tokenDef, start) {
    var end = null;
    var found = false;
    var offset = 0; // String position variables

    var strPos = null;
    var strFound = null;
    var pos = null;
    var endOffset = null;
    var thisStrPos = null;
    var endStrPos = null; // For loop variables

    var i;
    var l;

    while (!found) {
      strPos = null;
      strFound = null;
      pos = template.indexOf(tokenDef.close, offset);

      if (pos >= 0) {
        end = pos;
        found = true;
      } else {
        // Throw an exception
        throw new Twig.Error('Unable to find closing bracket \'' + tokenDef.close + '\' opened near template position ' + start);
      } // Ignore quotes within comments; just look for the next comment close sequence,
      // regardless of what comes before it. https://github.com/justjohn/twig.js/issues/95


      if (tokenDef.type === Twig.token.type.comment) {
        break;
      } // Ignore quotes within raw tag
      // Fixes #283


      if (tokenDef.type === Twig.token.type.raw) {
        break;
      }

      l = Twig.token.strings.length;

      for (i = 0; i < l; i += 1) {
        thisStrPos = template.indexOf(Twig.token.strings[i], offset);

        if (thisStrPos > 0 && thisStrPos < pos && (strPos === null || thisStrPos < strPos)) {
          strPos = thisStrPos;
          strFound = Twig.token.strings[i];
        }
      } // We found a string before the end of the token, now find the string's end and set the search offset to it


      if (strPos !== null) {
        endOffset = strPos + 1;
        end = null;
        found = false;

        for (;;) {
          endStrPos = template.indexOf(strFound, endOffset);

          if (endStrPos < 0) {
            throw Twig.Error('Unclosed string in template');
          } // Ignore escaped quotes


          if (template.slice(endStrPos - 1, endStrPos) === '\\') {
            endOffset = endStrPos + 1;
          } else {
            offset = endStrPos + 1;
            break;
          }
        }
      }
    }

    return end;
  };
  /**
   * Convert a template into high-level tokens.
   */


  Twig.tokenize = function (template) {
    var tokens = []; // An offset for reporting errors locations in the template.

    var errorOffset = 0; // The start and type of the first token found in the template.

    var foundToken = null; // The end position of the matched token.

    var end = null;

    while (template.length > 0) {
      // Find the first occurance of any token type in the template
      foundToken = Twig.token.findStart(template);
      Twig.log.trace('Twig.tokenize: ', 'Found token: ', foundToken);

      if (foundToken.position === null) {
        // No more tokens -> add the rest of the template as a raw-type token
        tokens.push({
          type: Twig.token.type.raw,
          value: template
        });
        template = '';
      } else {
        // Add a raw type token for anything before the start of the token
        if (foundToken.position > 0) {
          tokens.push({
            type: Twig.token.type.raw,
            value: template.slice(0, Math.max(0, foundToken.position))
          });
        }

        template = template.slice(foundToken.position + foundToken.def.open.length);
        errorOffset += foundToken.position + foundToken.def.open.length; // Find the end of the token

        end = Twig.token.findEnd(template, foundToken.def, errorOffset);
        Twig.log.trace('Twig.tokenize: ', 'Token ends at ', end);
        tokens.push({
          type: foundToken.def.type,
          value: template.slice(0, Math.max(0, end)).trim()
        });

        if (template.slice(end + foundToken.def.close.length, end + foundToken.def.close.length + 1) === '\n') {
          switch (foundToken.def.type) {
            case 'logic_whitespace_pre':
            case 'logic_whitespace_post':
            case 'logic_whitespace_both':
            case 'logic':
              // Newlines directly after logic tokens are ignored
              end += 1;
              break;

            default:
              break;
          }
        }

        template = template.slice(end + foundToken.def.close.length); // Increment the position in the template

        errorOffset += end + foundToken.def.close.length;
      }
    }

    return tokens;
  };

  Twig.compile = function (tokens) {
    var self = this;

    try {
      // Output and intermediate stacks
      var output = [];
      var stack = []; // The tokens between open and close tags

      var intermediateOutput = [];
      var token = null;
      var logicToken = null;
      var unclosedToken = null; // Temporary previous token.

      var prevToken = null; // Temporary previous output.

      var prevOutput = null; // Temporary previous intermediate output.

      var prevIntermediateOutput = null; // The previous token's template

      var prevTemplate = null; // Token lookahead

      var nextToken = null; // The output token

      var tokOutput = null; // Logic Token values

      var type = null;
      var open = null;
      var next = null;

      var compileOutput = function compileOutput(token) {
        Twig.expression.compile.call(self, token);

        if (stack.length > 0) {
          intermediateOutput.push(token);
        } else {
          output.push(token);
        }
      };

      var compileLogic = function compileLogic(token) {
        // Compile the logic token
        logicToken = Twig.logic.compile.call(self, token);
        type = logicToken.type;
        open = Twig.logic.handler[type].open;
        next = Twig.logic.handler[type].next;
        Twig.log.trace('Twig.compile: ', 'Compiled logic token to ', logicToken, ' next is: ', next, ' open is : ', open); // Not a standalone token, check logic stack to see if this is expected

        if (open !== undefined && !open) {
          prevToken = stack.pop();
          prevTemplate = Twig.logic.handler[prevToken.type];

          if (!prevTemplate.next.includes(type)) {
            throw new Error(type + ' not expected after a ' + prevToken.type);
          }

          prevToken.output = prevToken.output || [];
          prevToken.output = prevToken.output.concat(intermediateOutput);
          intermediateOutput = [];
          tokOutput = {
            type: Twig.token.type.logic,
            token: prevToken
          };

          if (stack.length > 0) {
            intermediateOutput.push(tokOutput);
          } else {
            output.push(tokOutput);
          }
        } // This token requires additional tokens to complete the logic structure.


        if (next !== undefined && next.length > 0) {
          Twig.log.trace('Twig.compile: ', 'Pushing ', logicToken, ' to logic stack.');

          if (stack.length > 0) {
            // Put any currently held output into the output list of the logic operator
            // currently at the head of the stack before we push a new one on.
            prevToken = stack.pop();
            prevToken.output = prevToken.output || [];
            prevToken.output = prevToken.output.concat(intermediateOutput);
            stack.push(prevToken);
            intermediateOutput = [];
          } // Push the new logic token onto the logic stack


          stack.push(logicToken);
        } else if (open !== undefined && open) {
          tokOutput = {
            type: Twig.token.type.logic,
            token: logicToken
          }; // Standalone token (like {% set ... %}

          if (stack.length > 0) {
            intermediateOutput.push(tokOutput);
          } else {
            output.push(tokOutput);
          }
        }
      };

      while (tokens.length > 0) {
        token = tokens.shift();
        prevOutput = output[output.length - 1];
        prevIntermediateOutput = intermediateOutput[intermediateOutput.length - 1];
        nextToken = tokens[0];
        Twig.log.trace('Compiling token ', token);

        switch (token.type) {
          case Twig.token.type.raw:
            if (stack.length > 0) {
              intermediateOutput.push(token);
            } else {
              output.push(token);
            }

            break;

          case Twig.token.type.logic:
            compileLogic.call(self, token);
            break;
          // Do nothing, comments should be ignored

          case Twig.token.type.comment:
            break;

          case Twig.token.type.output:
            compileOutput.call(self, token);
            break;
          // Kill whitespace ahead and behind this token

          case Twig.token.type.logicWhitespacePre:
          case Twig.token.type.logicWhitespacePost:
          case Twig.token.type.logicWhitespaceBoth:
          case Twig.token.type.outputWhitespacePre:
          case Twig.token.type.outputWhitespacePost:
          case Twig.token.type.outputWhitespaceBoth:
            if (token.type !== Twig.token.type.outputWhitespacePost && token.type !== Twig.token.type.logicWhitespacePost) {
              if (prevOutput) {
                // If the previous output is raw, pop it off
                if (prevOutput.type === Twig.token.type.raw) {
                  output.pop();
                  prevOutput.value = prevOutput.value.trimEnd(); // Repush the previous output

                  output.push(prevOutput);
                }
              }

              if (prevIntermediateOutput) {
                // If the previous intermediate output is raw, pop it off
                if (prevIntermediateOutput.type === Twig.token.type.raw) {
                  intermediateOutput.pop();
                  prevIntermediateOutput.value = prevIntermediateOutput.value.trimEnd(); // Repush the previous intermediate output

                  intermediateOutput.push(prevIntermediateOutput);
                }
              }
            } // Compile this token


            switch (token.type) {
              case Twig.token.type.outputWhitespacePre:
              case Twig.token.type.outputWhitespacePost:
              case Twig.token.type.outputWhitespaceBoth:
                compileOutput.call(self, token);
                break;

              case Twig.token.type.logicWhitespacePre:
              case Twig.token.type.logicWhitespacePost:
              case Twig.token.type.logicWhitespaceBoth:
                compileLogic.call(self, token);
                break;

              default:
                break;
            }

            if (token.type !== Twig.token.type.outputWhitespacePre && token.type !== Twig.token.type.logicWhitespacePre) {
              if (nextToken) {
                // If the next token is raw, shift it out
                if (nextToken.type === Twig.token.type.raw) {
                  tokens.shift();
                  nextToken.value = nextToken.value.trimStart(); // Unshift the next token

                  tokens.unshift(nextToken);
                }
              }
            }

            break;

          default:
            break;
        }

        Twig.log.trace('Twig.compile: ', ' Output: ', output, ' Logic Stack: ', stack, ' Pending Output: ', intermediateOutput);
      } // Verify that there are no logic tokens left in the stack.


      if (stack.length > 0) {
        unclosedToken = stack.pop();
        throw new Error('Unable to find an end tag for ' + unclosedToken.type + ', expecting one of ' + unclosedToken.next);
      }

      return output;
    } catch (error) {
      if (self.options.rethrow) {
        if (error.type === 'TwigException' && !error.file) {
          error.file = self.id;
        }

        throw error;
      } else {
        Twig.log.error('Error compiling twig template ' + self.id + ': ');

        if (error.stack) {
          Twig.log.error(error.stack);
        } else {
          Twig.log.error(error.toString());
        }
      }
    }
  };

  function handleException(state, ex) {
    if (state.template.options.rethrow) {
      if (typeof ex === 'string') {
        ex = new Twig.Error(ex);
      }

      if (ex.type === 'TwigException' && !ex.file) {
        ex.file = state.template.id;
      }

      throw ex;
    } else {
      Twig.log.error('Error parsing twig template ' + state.template.id + ': ');

      if (ex.stack) {
        Twig.log.error(ex.stack);
      } else {
        Twig.log.error(ex.toString());
      }

      if (Twig.debug) {
        return ex.toString();
      }
    }
  }
  /**
   * Tokenize and compile a string template.
   *
   * @param {string} data The template.
   *
   * @return {Array} The compiled tokens.
   */


  Twig.prepare = function (data) {
    // Tokenize
    Twig.log.debug('Twig.prepare: ', 'Tokenizing ', data);
    var rawTokens = Twig.tokenize.call(this, data); // Compile

    Twig.log.debug('Twig.prepare: ', 'Compiling ', rawTokens);
    var tokens = Twig.compile.call(this, rawTokens);
    Twig.log.debug('Twig.prepare: ', 'Compiled ', tokens);
    return tokens;
  };
  /**
   * Join the output token's stack and escape it if needed
   *
   * @param {Array} Output token's stack
   *
   * @return {string|String} Autoescaped output
   */


  Twig.output = function (output) {
    var autoescape = this.options.autoescape;

    if (!autoescape) {
      return output.join('');
    }

    var strategy = typeof autoescape === 'string' ? autoescape : 'html';
    var escapedOutput = output.map(function (str) {
      if (str && str.twigMarkup !== true && str.twigMarkup !== strategy && !(strategy === 'html' && str.twigMarkup === 'html_attr')) {
        str = Twig.filters.escape(str, [strategy]);
      }

      return str;
    });

    if (escapedOutput.length === 0) {
      return '';
    }

    var joinedOutput = escapedOutput.join('');

    if (joinedOutput.length === 0) {
      return '';
    }

    return new Twig.Markup(joinedOutput, true);
  }; // Namespace for template storage and retrieval


  Twig.Templates = {
    /**
     * Registered template loaders - use Twig.Templates.registerLoader to add supported loaders
     * @type {Object}
     */
    loaders: {},

    /**
     * Registered template parsers - use Twig.Templates.registerParser to add supported parsers
     * @type {Object}
     */
    parsers: {},

    /**
     * Cached / loaded templates
     * @type {Object}
     */
    registry: {}
  };
  /**
   * Is this id valid for a twig template?
   *
   * @param {string} id The ID to check.
   *
   * @throws {Twig.Error} If the ID is invalid or used.
   * @return {boolean} True if the ID is valid.
   */

  Twig.validateId = function (id) {
    if (id === 'prototype') {
      throw new Twig.Error(id + ' is not a valid twig identifier');
    } else if (Twig.cache && Object.hasOwnProperty.call(Twig.Templates.registry, id)) {
      throw new Twig.Error('There is already a template with the ID ' + id);
    }

    return true;
  };
  /**
   * Register a template loader
   *
   * @example
   * Twig.extend(function (Twig) {
   *    Twig.Templates.registerLoader('custom_loader', function (location, params, callback, errorCallback) {
   *        // ... load the template ...
   *        params.data = loadedTemplateData;
   *        // create and return the template
   *        var template = new Twig.Template(params);
   *        if (typeof callback === 'function') {
   *            callback(template);
   *        }
   *        return template;
   *    });
   * });
   *
   * @param {String} methodName The method this loader is intended for (ajax, fs)
   * @param {Function} func The function to execute when loading the template
   * @param {Object|undefined} scope Optional scope parameter to bind func to
   *
   * @throws Twig.Error
   *
   * @return {void}
   */


  Twig.Templates.registerLoader = function (methodName, func, scope) {
    if (typeof func !== 'function') {
      throw new Twig.Error('Unable to add loader for ' + methodName + ': Invalid function reference given.');
    }

    if (scope) {
      func = func.bind(scope);
    }

    this.loaders[methodName] = func;
  };
  /**
   * Remove a registered loader
   *
   * @param {String} methodName The method name for the loader you wish to remove
   *
   * @return {void}
   */


  Twig.Templates.unRegisterLoader = function (methodName) {
    if (this.isRegisteredLoader(methodName)) {
      delete this.loaders[methodName];
    }
  };
  /**
   * See if a loader is registered by its method name
   *
   * @param {String} methodName The name of the loader you are looking for
   *
   * @return {boolean}
   */


  Twig.Templates.isRegisteredLoader = function (methodName) {
    return Object.hasOwnProperty.call(this.loaders, methodName);
  };
  /**
   * Register a template parser
   *
   * @example
   * Twig.extend(function (Twig) {
   *    Twig.Templates.registerParser('custom_parser', function (params) {
   *        // this template source can be accessed in params.data
   *        var template = params.data
   *
   *        // ... custom process that modifies the template
   *
   *        // return the parsed template
   *        return template;
   *    });
   * });
   *
   * @param {String} methodName The method this parser is intended for (twig, source)
   * @param {Function} func The function to execute when parsing the template
   * @param {Object|undefined} scope Optional scope parameter to bind func to
   *
   * @throws Twig.Error
   *
   * @return {void}
   */


  Twig.Templates.registerParser = function (methodName, func, scope) {
    if (typeof func !== 'function') {
      throw new Twig.Error('Unable to add parser for ' + methodName + ': Invalid function regerence given.');
    }

    if (scope) {
      func = func.bind(scope);
    }

    this.parsers[methodName] = func;
  };
  /**
   * Remove a registered parser
   *
   * @param {String} methodName The method name for the parser you wish to remove
   *
   * @return {void}
   */


  Twig.Templates.unRegisterParser = function (methodName) {
    if (this.isRegisteredParser(methodName)) {
      delete this.parsers[methodName];
    }
  };
  /**
   * See if a parser is registered by its method name
   *
   * @param {String} methodName The name of the parser you are looking for
   *
   * @return {boolean}
   */


  Twig.Templates.isRegisteredParser = function (methodName) {
    return Object.hasOwnProperty.call(this.parsers, methodName);
  };
  /**
   * Save a template object to the store.
   *
   * @param {Twig.Template} template   The twig.js template to store.
   */


  Twig.Templates.save = function (template) {
    if (template.id === undefined) {
      throw new Twig.Error('Unable to save template with no id');
    }

    Twig.Templates.registry[template.id] = template;
  };
  /**
   * Load a previously saved template from the store.
   *
   * @param {string} id   The ID of the template to load.
   *
   * @return {Twig.Template} A twig.js template stored with the provided ID.
   */


  Twig.Templates.load = function (id) {
    if (!Object.hasOwnProperty.call(Twig.Templates.registry, id)) {
      return null;
    }

    return Twig.Templates.registry[id];
  };
  /**
   * Load a template from a remote location using AJAX and saves in with the given ID.
   *
   * Available parameters:
   *
   *      async:       Should the HTTP request be performed asynchronously.
   *                      Defaults to true.
   *      method:      What method should be used to load the template
   *                      (fs or ajax)
   *      parser:      What method should be used to parse the template
   *                      (twig or source)
   *      precompiled: Has the template already been compiled.
   *
   * @param {string} location  The remote URL to load as a template.
   * @param {Object} params The template parameters.
   * @param {function} callback  A callback triggered when the template finishes loading.
   * @param {function} errorCallback  A callback triggered if an error occurs loading the template.
   *
   *
   */


  Twig.Templates.loadRemote = function (location, params, callback, errorCallback) {
    // Default to the URL so the template is cached.
    var id = typeof params.id === 'undefined' ? location : params.id;
    var cached = Twig.Templates.registry[id]; // Check for existing template

    if (Twig.cache && typeof cached !== 'undefined') {
      // A template is already saved with the given id.
      if (typeof callback === 'function') {
        callback(cached);
      } // TODO: if async, return deferred promise


      return cached;
    } // If the parser name hasn't been set, default it to twig


    params.parser = params.parser || 'twig';
    params.id = id; // Default to async

    if (typeof params.async === 'undefined') {
      params.async = true;
    } // Assume 'fs' if the loader is not defined


    var loader = this.loaders[params.method] || this.loaders.fs;
    return loader.call(this, location, params, callback, errorCallback);
  }; // Determine object type


  function is(type, obj) {
    var clas = Object.prototype.toString.call(obj).slice(8, -1);
    return obj !== undefined && obj !== null && clas === type;
  }
  /**
   * A wrapper for template blocks.
   *
   * @param  {Twig.Template} The template that the block was originally defined in.
   * @param  {Object} The compiled block token.
   */


  Twig.Block = function (template, token) {
    this.template = template;
    this.token = token;
  };
  /**
   * Render the block using a specific parse state and context.
   *
   * @param  {Twig.ParseState} parseState
   * @param  {Object} context
   *
   * @return {Promise}
   */


  Twig.Block.prototype.render = function (parseState, context) {
    var originalTemplate = parseState.template;
    var promise;
    parseState.template = this.template;

    if (this.token.expression) {
      promise = Twig.expression.parseAsync.call(parseState, this.token.output, context);
    } else {
      promise = parseState.parseAsync(this.token.output, context);
    }

    return promise.then(function (value) {
      return Twig.expression.parseAsync.call(parseState, {
        type: Twig.expression.type.string,
        value: value
      }, context);
    }).then(function (output) {
      parseState.template = originalTemplate;
      return output;
    });
  };
  /**
   * Holds the state needed to parse a template.
   *
   * @param {Twig.Template} template The template that the tokens being parsed are associated with.
   * @param {Object} blockOverrides Any blocks that should override those defined in the associated template.
   */


  Twig.ParseState = function (template, blockOverrides) {
    this.renderedBlocks = {};
    this.overrideBlocks = blockOverrides === undefined ? {} : blockOverrides;
    this.context = {};
    this.macros = {};
    this.nestingStack = [];
    this.template = template;
  };
  /**
   * Get a block by its name, resolving in the following order:
   *     - override blocks specified when initialized (except when excluded)
   *     - blocks resolved from the associated template
   *     - blocks resolved from the parent template when extending
   *
   * @param {String} name The name of the block to return.
   * @param {Boolean} checkOnlyInheritedBlocks Whether to skip checking the overrides and associated template, will not skip by default.
   *
   * @return {Twig.Block|undefined}
   */


  Twig.ParseState.prototype.getBlock = function (name, checkOnlyInheritedBlocks) {
    var block;

    if (checkOnlyInheritedBlocks !== true) {
      // Blocks specified when initialized
      block = this.overrideBlocks[name];
    }

    if (block === undefined) {
      // Block defined by the associated template
      block = this.template.getBlock(name, checkOnlyInheritedBlocks);
    }

    if (block === undefined && this.template.parentTemplate !== null) {
      // Block defined in the parent template when extending
      block = this.template.parentTemplate.getBlock(name);
    }

    return block;
  };
  /**
   * Get all the available blocks, resolving in the following order:
   *     - override blocks specified when initialized
   *     - blocks resolved from the associated template
   *     - blocks resolved from the parent template when extending (except when excluded)
   *
   * @param {Boolean} includeParentBlocks Whether to get blocks from the parent template when extending, will always do so by default.
   *
   * @return {Object}
   */


  Twig.ParseState.prototype.getBlocks = function (includeParentBlocks) {
    var blocks = {};

    if (includeParentBlocks !== false && this.template.parentTemplate !== null && // Prevent infinite loop
    this.template.parentTemplate !== this.template) {
      // Blocks from the parent template when extending
      blocks = this.template.parentTemplate.getBlocks();
    }

    blocks = _objectSpread({}, blocks, {}, this.template.getBlocks(), {}, this.overrideBlocks);
    return blocks;
  };
  /**
   * Get the closest token of a specific type to the current nest level.
   *
   * @param  {String} type  The logic token type
   *
   * @return {Object}
   */


  Twig.ParseState.prototype.getNestingStackToken = function (type) {
    var matchingToken;
    this.nestingStack.forEach(function (token) {
      if (matchingToken === undefined && token.type === type) {
        matchingToken = token;
      }
    });
    return matchingToken;
  };
  /**
   * Parse a set of tokens using the current state.
   *
   * @param {Array} tokens The compiled tokens.
   * @param {Object} context The context to set the state to while parsing.
   * @param {Boolean} allowAsync Whether to parse asynchronously.
   * @param {Object} blocks Blocks that should override any defined while parsing.
   *
   * @return {String} The rendered tokens.
   *
   */


  Twig.ParseState.prototype.parse = function (tokens, context, allowAsync) {
    var state = this;
    var output = []; // Store any error that might be thrown by the promise chain.

    var err = null; // This will be set to isAsync if template renders synchronously

    var isAsync = true;
    var promise = null; // Track logic chains

    var chain = true;

    if (context) {
      state.context = context;
    }
    /*
     * Extracted into it's own function such that the function
     * does not get recreated over and over again in the `forEach`
     * loop below. This method can be compiled and optimized
     * a single time instead of being recreated on each iteration.
     */


    function outputPush(o) {
      output.push(o);
    }

    function parseTokenLogic(logic) {
      if (typeof logic.chain !== 'undefined') {
        chain = logic.chain;
      }

      if (typeof logic.context !== 'undefined') {
        state.context = logic.context;
      }

      if (typeof logic.output !== 'undefined') {
        output.push(logic.output);
      }
    }

    promise = Twig.async.forEach(tokens, function (token) {
      Twig.log.debug('Twig.ParseState.parse: ', 'Parsing token: ', token);

      switch (token.type) {
        case Twig.token.type.raw:
          output.push(Twig.filters.raw(token.value));
          break;

        case Twig.token.type.logic:
          return Twig.logic.parseAsync.call(state, token.token
          /* logicToken */
          , state.context, chain).then(parseTokenLogic);

        case Twig.token.type.comment:
          // Do nothing, comments should be ignored
          break;
        // Fall through whitespace to output

        case Twig.token.type.outputWhitespacePre:
        case Twig.token.type.outputWhitespacePost:
        case Twig.token.type.outputWhitespaceBoth:
        case Twig.token.type.output:
          Twig.log.debug('Twig.ParseState.parse: ', 'Output token: ', token.stack); // Parse the given expression in the given context

          return Twig.expression.parseAsync.call(state, token.stack, state.context).then(outputPush);

        default:
          break;
      }
    }).then(function () {
      output = Twig.output.call(state.template, output);
      isAsync = false;
      return output;
    })["catch"](function (error) {
      if (allowAsync) {
        handleException(state, error);
      }

      err = error;
    }); // If `allowAsync` we will always return a promise since we do not
    // know in advance if we are going to run asynchronously or not.

    if (allowAsync) {
      return promise;
    } // Handle errors here if we fail synchronously.


    if (err !== null) {
      return handleException(state, err);
    } // If `allowAsync` is not true we should not allow the user
    // to use asynchronous functions or filters.


    if (isAsync) {
      throw new Twig.Error('You are using Twig.js in sync mode in combination with async extensions.');
    }

    return output;
  };
  /**
   * Create a new twig.js template.
   *
   * Parameters: {
   *      data:   The template, either pre-compiled tokens or a string template
   *      id:     The name of this template
   * }
   *
   * @param {Object} params The template parameters.
   */


  Twig.Template = function (params) {
    var data = params.data,
        id = params.id,
        base = params.base,
        path = params.path,
        url = params.url,
        name = params.name,
        method = params.method,
        options = params.options; // # What is stored in a Twig.Template
    //
    // The Twig Template hold several chucks of data.
    //
    //     {
    //          id:     The token ID (if any)
    //          tokens: The list of tokens that makes up this template.
    //          base:   The base template (if any)
    //            options:  {
    //                Compiler/parser options
    //
    //                strict_variables: true/false
    //                    Should missing variable/keys emit an error message. If false, they default to null.
    //            }
    //     }
    //

    this.base = base;
    this.blocks = {
      defined: {},
      imported: {}
    };
    this.id = id;
    this.method = method;
    this.name = name;
    this.options = options;
    this.parentTemplate = null;
    this.path = path;
    this.url = url;

    if (is('String', data)) {
      this.tokens = Twig.prepare.call(this, data);
    } else {
      this.tokens = data;
    }

    if (id !== undefined) {
      Twig.Templates.save(this);
    }
  };
  /**
   * Get a block by its name, resolving in the following order:
   *     - blocks defined in the template itself
   *     - blocks imported from another template
   *
   * @param {String} name The name of the block to return.
   * @param {Boolean} checkOnlyInheritedBlocks Whether to skip checking the blocks defined in the template itself, will not skip by default.
   *
   * @return {Twig.Block|undefined}
   */


  Twig.Template.prototype.getBlock = function (name, checkOnlyInheritedBlocks) {
    var checkImports = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    var block;

    if (checkOnlyInheritedBlocks !== true) {
      block = this.blocks.defined[name];
    }

    if (checkImports && block === undefined) {
      block = this.blocks.imported[name];
    }

    if (block === undefined && this.parentTemplate !== null) {
      /**
       * Block defined in the parent template when extending.
       * This recursion is useful to inherit from ascendants.
       * But take care of not considering ascendants' {% use %}
       */
      block = this.parentTemplate.getBlock(name, checkOnlyInheritedBlocks, checkImports = false);
    }

    return block;
  };
  /**
   * Get all the available blocks, resolving in the following order:
   *     - blocks defined in the template itself
   *     - blocks imported from other templates
   *
   * @return {Object}
   */


  Twig.Template.prototype.getBlocks = function () {
    var blocks = {};
    blocks = _objectSpread({}, blocks, {}, this.blocks.imported, {}, this.blocks.defined);
    return blocks;
  };

  Twig.Template.prototype.render = function (context, params, allowAsync) {
    var template = this;
    params = params || {};
    return Twig.async.potentiallyAsync(template, allowAsync, function () {
      var state = new Twig.ParseState(template, params.blocks);
      return state.parseAsync(template.tokens, context).then(function (output) {
        var parentTemplate;
        var url;

        if (template.parentTemplate !== null) {
          // This template extends another template
          if (template.options.allowInlineIncludes) {
            // The template is provided inline
            parentTemplate = Twig.Templates.load(template.parentTemplate);

            if (parentTemplate) {
              parentTemplate.options = template.options;
            }
          } // Check for the template file via include


          if (!parentTemplate) {
            url = Twig.path.parsePath(template, template.parentTemplate);
            parentTemplate = Twig.Templates.loadRemote(url, {
              method: template.getLoaderMethod(),
              base: template.base,
              async: false,
              id: url,
              options: template.options
            });
          }

          template.parentTemplate = parentTemplate;
          return template.parentTemplate.renderAsync(state.context, {
            blocks: state.getBlocks(false),
            isInclude: true
          });
        }

        if (params.isInclude === true) {
          return output;
        }

        return output.valueOf();
      });
    });
  };

  Twig.Template.prototype.importFile = function (file) {
    var url = null;
    var subTemplate;

    if (!this.url && this.options.allowInlineIncludes) {
      file = this.path ? Twig.path.parsePath(this, file) : file;
      subTemplate = Twig.Templates.load(file);

      if (!subTemplate) {
        subTemplate = Twig.Templates.loadRemote(url, {
          id: file,
          method: this.getLoaderMethod(),
          async: false,
          path: file,
          options: this.options
        });

        if (!subTemplate) {
          throw new Twig.Error('Unable to find the template ' + file);
        }
      }

      subTemplate.options = this.options;
      return subTemplate;
    }

    url = Twig.path.parsePath(this, file); // Load blocks from an external file

    subTemplate = Twig.Templates.loadRemote(url, {
      method: this.getLoaderMethod(),
      base: this.base,
      async: false,
      options: this.options,
      id: url
    });
    return subTemplate;
  };

  Twig.Template.prototype.getLoaderMethod = function () {
    if (this.path) {
      return 'fs';
    }

    if (this.url) {
      return 'ajax';
    }

    return this.method || 'fs';
  };

  Twig.Template.prototype.compile = function (options) {
    // Compile the template into raw JS
    return Twig.compiler.compile(this, options);
  };
  /**
   * Create safe output
   *
   * @param {string} Content safe to output
   *
   * @return {String} Content wrapped into a String
   */


  Twig.Markup = function (content, strategy) {
    if (typeof content !== 'string') {
      return content;
    }
    /* eslint-disable no-new-wrappers, unicorn/new-for-builtins */


    var output = new String(content);
    /* eslint-enable */

    output.twigMarkup = typeof strategy === 'undefined' ? true : strategy;
    return output;
  };

  return Twig;
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// ## twig.compiler.js
//
// This file handles compiling templates into JS
module.exports = function (Twig) {
  /**
   * Namespace for compilation.
   */
  Twig.compiler = {
    module: {}
  }; // Compile a Twig Template to output.

  Twig.compiler.compile = function (template, options) {
    // Get tokens
    var tokens = JSON.stringify(template.tokens);
    var id = template.id;
    var output = null;

    if (options.module) {
      if (Twig.compiler.module[options.module] === undefined) {
        throw new Twig.Error('Unable to find module type ' + options.module);
      }

      output = Twig.compiler.module[options.module](id, tokens, options.twig);
    } else {
      output = Twig.compiler.wrap(id, tokens);
    }

    return output;
  };

  Twig.compiler.module = {
    amd: function amd(id, tokens, pathToTwig) {
      return 'define(["' + pathToTwig + '"], function (Twig) {\n\tvar twig, templates;\ntwig = Twig.twig;\ntemplates = ' + Twig.compiler.wrap(id, tokens) + '\n\treturn templates;\n});';
    },
    node: function node(id, tokens) {
      return 'var twig = require("twig").twig;\nexports.template = ' + Twig.compiler.wrap(id, tokens);
    },
    cjs2: function cjs2(id, tokens, pathToTwig) {
      return 'module.declare([{ twig: "' + pathToTwig + '" }], function (require, exports, module) {\n\tvar twig = require("twig").twig;\n\texports.template = ' + Twig.compiler.wrap(id, tokens) + '\n});';
    }
  };

  Twig.compiler.wrap = function (id, tokens) {
    return 'twig({id:"' + id.replace('"', '\\"') + '", data:' + tokens + ', precompiled: true});\n';
  };

  return Twig;
};

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(0);

var _typeof2 = _interopRequireDefault(__webpack_require__(1));

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(10));

// ## twig.expression.js
//
// This file handles tokenizing, compiling and parsing expressions.
module.exports = function (Twig) {
  'use strict';

  function parseParams(state, params, context) {
    if (params) {
      return Twig.expression.parseAsync.call(state, params, context);
    }

    return Twig.Promise.resolve(false);
  }
  /**
   * Namespace for expression handling.
   */


  Twig.expression = {};

  __webpack_require__(14)(Twig);
  /**
   * Reserved word that can't be used as variable names.
   */


  Twig.expression.reservedWords = ['true', 'false', 'null', 'TRUE', 'FALSE', 'NULL', '_context', 'and', 'b-and', 'or', 'b-or', 'b-xor', 'in', 'not in', 'if', 'matches', 'starts', 'ends', 'with'];
  /**
   * The type of tokens used in expressions.
   */

  Twig.expression.type = {
    comma: 'Twig.expression.type.comma',
    operator: {
      unary: 'Twig.expression.type.operator.unary',
      binary: 'Twig.expression.type.operator.binary'
    },
    string: 'Twig.expression.type.string',
    bool: 'Twig.expression.type.bool',
    slice: 'Twig.expression.type.slice',
    array: {
      start: 'Twig.expression.type.array.start',
      end: 'Twig.expression.type.array.end'
    },
    object: {
      start: 'Twig.expression.type.object.start',
      end: 'Twig.expression.type.object.end'
    },
    parameter: {
      start: 'Twig.expression.type.parameter.start',
      end: 'Twig.expression.type.parameter.end'
    },
    subexpression: {
      start: 'Twig.expression.type.subexpression.start',
      end: 'Twig.expression.type.subexpression.end'
    },
    key: {
      period: 'Twig.expression.type.key.period',
      brackets: 'Twig.expression.type.key.brackets'
    },
    filter: 'Twig.expression.type.filter',
    _function: 'Twig.expression.type._function',
    variable: 'Twig.expression.type.variable',
    number: 'Twig.expression.type.number',
    _null: 'Twig.expression.type.null',
    context: 'Twig.expression.type.context',
    test: 'Twig.expression.type.test'
  };
  Twig.expression.set = {
    // What can follow an expression (in general)
    operations: [Twig.expression.type.filter, Twig.expression.type.operator.unary, Twig.expression.type.operator.binary, Twig.expression.type.array.end, Twig.expression.type.object.end, Twig.expression.type.parameter.end, Twig.expression.type.subexpression.end, Twig.expression.type.comma, Twig.expression.type.test],
    expressions: [Twig.expression.type._function, Twig.expression.type.bool, Twig.expression.type.string, Twig.expression.type.variable, Twig.expression.type.number, Twig.expression.type._null, Twig.expression.type.context, Twig.expression.type.parameter.start, Twig.expression.type.array.start, Twig.expression.type.object.start, Twig.expression.type.subexpression.start, Twig.expression.type.operator.unary]
  }; // Most expressions allow a '.' or '[' after them, so we provide a convenience set

  Twig.expression.set.operationsExtended = Twig.expression.set.operations.concat([Twig.expression.type.key.period, Twig.expression.type.key.brackets, Twig.expression.type.slice]); // Some commonly used compile and parse functions.

  Twig.expression.fn = {
    compile: {
      push: function push(token, stack, output) {
        output.push(token);
      },
      pushBoth: function pushBoth(token, stack, output) {
        output.push(token);
        stack.push(token);
      }
    },
    parse: {
      push: function push(token, stack) {
        stack.push(token);
      },
      pushValue: function pushValue(token, stack) {
        stack.push(token.value);
      }
    }
  }; // The regular expressions and compile/parse logic used to match tokens in expressions.
  //
  // Properties:
  //
  //      type:  The type of expression this matches
  //
  //      regex: One or more regular expressions that matche the format of the token.
  //
  //      next:  Valid tokens that can occur next in the expression.
  //
  // Functions:
  //
  //      compile: A function that compiles the raw regular expression match into a token.
  //
  //      parse:   A function that parses the compiled token into output.
  //

  Twig.expression.definitions = [{
    type: Twig.expression.type.test,
    regex: /^is\s+(not)?\s*([a-zA-Z_]\w*(\s?as)?)/,
    next: Twig.expression.set.operations.concat([Twig.expression.type.parameter.start]),
    compile: function compile(token, stack, output) {
      token.filter = token.match[2];
      token.modifier = token.match[1];
      delete token.match;
      delete token.value;
      output.push(token);
    },
    parse: function parse(token, stack, context) {
      var value = stack.pop();
      var state = this;
      return parseParams(state, token.params, context).then(function (params) {
        var result = Twig.test(token.filter, value, params);

        if (token.modifier === 'not') {
          stack.push(!result);
        } else {
          stack.push(result);
        }
      });
    }
  }, {
    type: Twig.expression.type.comma,
    // Match a comma
    regex: /^,/,
    next: Twig.expression.set.expressions.concat([Twig.expression.type.array.end, Twig.expression.type.object.end]),
    compile: function compile(token, stack, output) {
      var i = stack.length - 1;
      var stackToken;
      delete token.match;
      delete token.value; // Pop tokens off the stack until the start of the object

      for (; i >= 0; i--) {
        stackToken = stack.pop();

        if (stackToken.type === Twig.expression.type.object.start || stackToken.type === Twig.expression.type.parameter.start || stackToken.type === Twig.expression.type.array.start) {
          stack.push(stackToken);
          break;
        }

        output.push(stackToken);
      }

      output.push(token);
    }
  }, {
    /**
     * Match a number (integer or decimal)
     */
    type: Twig.expression.type.number,
    // Match a number
    regex: /^-?\d+(\.\d+)?/,
    next: Twig.expression.set.operations,
    compile: function compile(token, stack, output) {
      token.value = Number(token.value);
      output.push(token);
    },
    parse: Twig.expression.fn.parse.pushValue
  }, {
    type: Twig.expression.type.operator.binary,
    // Match any of ??, ?:, +, *, /, -, %, ~, <, <=, >, >=, !=, ==, **, ?, :, and, b-and, or, b-or, b-xor, in, not in
    // and, or, in, not in, matches, starts with, ends with can be followed by a space or parenthesis
    regex: /(^\?\?|^\?:|^(b-and)|^(b-or)|^(b-xor)|^[+\-~%?]|^[:](?!\d\])|^[!=]==?|^[!<>]=?|^\*\*?|^\/\/?|^(and)[(|\s+]|^(or)[(|\s+]|^(in)[(|\s+]|^(not in)[(|\s+]|^(matches)|^(starts with)|^(ends with)|^\.\.)/,
    next: Twig.expression.set.expressions,
    transform: function transform(match, tokens) {
      switch (match[0]) {
        case 'and(':
        case 'or(':
        case 'in(':
        case 'not in(':
          // Strip off the ( if it exists
          tokens[tokens.length - 1].value = match[2];
          return match[0];

        default:
          return '';
      }
    },
    compile: function compile(token, stack, output) {
      delete token.match;
      token.value = token.value.trim();
      var value = token.value;
      var operator = Twig.expression.operator.lookup(value, token);
      Twig.log.trace('Twig.expression.compile: ', 'Operator: ', operator, ' from ', value);

      while (stack.length > 0 && (stack[stack.length - 1].type === Twig.expression.type.operator.unary || stack[stack.length - 1].type === Twig.expression.type.operator.binary) && (operator.associativity === Twig.expression.operator.leftToRight && operator.precidence >= stack[stack.length - 1].precidence || operator.associativity === Twig.expression.operator.rightToLeft && operator.precidence > stack[stack.length - 1].precidence)) {
        var temp = stack.pop();
        output.push(temp);
      }

      if (value === ':') {
        // Check if this is a ternary or object key being set
        if (stack[stack.length - 1] && stack[stack.length - 1].value === '?') {// Continue as normal for a ternary
        } else {
          // This is not a ternary so we push the token to the output where it can be handled
          //   when the assocated object is closed.
          var keyToken = output.pop();

          if (keyToken.type === Twig.expression.type.string || keyToken.type === Twig.expression.type.variable) {
            token.key = keyToken.value;
          } else if (keyToken.type === Twig.expression.type.number) {
            // Convert integer keys into string keys
            token.key = keyToken.value.toString();
          } else if (keyToken.expression && (keyToken.type === Twig.expression.type.parameter.end || keyToken.type === Twig.expression.type.subexpression.end)) {
            token.params = keyToken.params;
          } else {
            throw new Twig.Error('Unexpected value before \':\' of ' + keyToken.type + ' = ' + keyToken.value);
          }

          output.push(token);
        }
      } else {
        stack.push(operator);
      }
    },
    parse: function parse(token, stack, context) {
      var state = this;

      if (token.key) {
        // Handle ternary ':' operator
        stack.push(token);
      } else if (token.params) {
        // Handle "{(expression):value}"
        return Twig.expression.parseAsync.call(state, token.params, context).then(function (key) {
          token.key = key;
          stack.push(token); // If we're in a loop, we might need token.params later, especially in this form of "(expression):value"

          if (!context.loop) {
            delete token.params;
          }
        });
      } else {
        Twig.expression.operator.parse(token.value, stack);
      }
    }
  }, {
    type: Twig.expression.type.operator.unary,
    // Match any of not
    regex: /(^not\s+)/,
    next: Twig.expression.set.expressions,
    compile: function compile(token, stack, output) {
      delete token.match;
      token.value = token.value.trim();
      var value = token.value;
      var operator = Twig.expression.operator.lookup(value, token);
      Twig.log.trace('Twig.expression.compile: ', 'Operator: ', operator, ' from ', value);

      while (stack.length > 0 && (stack[stack.length - 1].type === Twig.expression.type.operator.unary || stack[stack.length - 1].type === Twig.expression.type.operator.binary) && (operator.associativity === Twig.expression.operator.leftToRight && operator.precidence >= stack[stack.length - 1].precidence || operator.associativity === Twig.expression.operator.rightToLeft && operator.precidence > stack[stack.length - 1].precidence)) {
        var temp = stack.pop();
        output.push(temp);
      }

      stack.push(operator);
    },
    parse: function parse(token, stack) {
      Twig.expression.operator.parse(token.value, stack);
    }
  }, {
    /**
     * Match a string. This is anything between a pair of single or double quotes.
     */
    type: Twig.expression.type.string,
    // See: http://blog.stevenlevithan.com/archives/match-quoted-string
    regex: /^(["'])(?:(?=(\\?))\2[\s\S])*?\1/,
    next: Twig.expression.set.operationsExtended,
    compile: function compile(token, stack, output) {
      var value = token.value;
      delete token.match; // Remove the quotes from the string

      if (value.slice(0, 1) === '"') {
        value = value.replace('\\"', '"');
      } else {
        value = value.replace('\\\'', '\'');
      }

      token.value = value.slice(1, -1).replace(/\\n/g, '\n').replace(/\\r/g, '\r');
      Twig.log.trace('Twig.expression.compile: ', 'String value: ', token.value);
      output.push(token);
    },
    parse: Twig.expression.fn.parse.pushValue
  }, {
    /**
     * Match a subexpression set start.
     */
    type: Twig.expression.type.subexpression.start,
    regex: /^\(/,
    next: Twig.expression.set.expressions.concat([Twig.expression.type.subexpression.end]),
    compile: function compile(token, stack, output) {
      token.value = '(';
      output.push(token);
      stack.push(token);
    },
    parse: Twig.expression.fn.parse.push
  }, {
    /**
     * Match a subexpression set end.
     */
    type: Twig.expression.type.subexpression.end,
    regex: /^\)/,
    next: Twig.expression.set.operationsExtended,
    validate: function validate(match, tokens) {
      // Iterate back through previous tokens to ensure we follow a subexpression start
      var i = tokens.length - 1;
      var foundSubexpressionStart = false;
      var nextSubexpressionStartInvalid = false;
      var unclosedParameterCount = 0;

      while (!foundSubexpressionStart && i >= 0) {
        var token = tokens[i];
        foundSubexpressionStart = token.type === Twig.expression.type.subexpression.start; // If we have previously found a subexpression end, then this subexpression start is the start of
        // that subexpression, not the subexpression we are searching for

        if (foundSubexpressionStart && nextSubexpressionStartInvalid) {
          nextSubexpressionStartInvalid = false;
          foundSubexpressionStart = false;
        } // Count parameter tokens to ensure we dont return truthy for a parameter opener


        if (token.type === Twig.expression.type.parameter.start) {
          unclosedParameterCount++;
        } else if (token.type === Twig.expression.type.parameter.end) {
          unclosedParameterCount--;
        } else if (token.type === Twig.expression.type.subexpression.end) {
          nextSubexpressionStartInvalid = true;
        }

        i--;
      } // If we found unclosed parameters, return false
      // If we didnt find subexpression start, return false
      // Otherwise return true


      return foundSubexpressionStart && unclosedParameterCount === 0;
    },
    compile: function compile(token, stack, output) {
      // This is basically a copy of parameter end compilation
      var stackToken;
      var endToken = token;
      stackToken = stack.pop();

      while (stack.length > 0 && stackToken.type !== Twig.expression.type.subexpression.start) {
        output.push(stackToken);
        stackToken = stack.pop();
      } // Move contents of parens into preceding filter


      var paramStack = [];

      while (token.type !== Twig.expression.type.subexpression.start) {
        // Add token to arguments stack
        paramStack.unshift(token);
        token = output.pop();
      }

      paramStack.unshift(token); // If the token at the top of the *stack* is a function token, pop it onto the output queue.
      // Get the token preceding the parameters

      stackToken = stack[stack.length - 1];

      if (stackToken === undefined || stackToken.type !== Twig.expression.type._function && stackToken.type !== Twig.expression.type.filter && stackToken.type !== Twig.expression.type.test && stackToken.type !== Twig.expression.type.key.brackets) {
        endToken.expression = true; // Remove start and end token from stack

        paramStack.pop();
        paramStack.shift();
        endToken.params = paramStack;
        output.push(endToken);
      } else {
        // This should never be hit
        endToken.expression = false;
        stackToken.params = paramStack;
      }
    },
    parse: function parse(token, stack, context) {
      var state = this;

      if (token.expression) {
        return Twig.expression.parseAsync.call(state, token.params, context).then(function (value) {
          stack.push(value);
        });
      }

      throw new Twig.Error('Unexpected subexpression end when token is not marked as an expression');
    }
  }, {
    /**
     * Match a parameter set start.
     */
    type: Twig.expression.type.parameter.start,
    regex: /^\(/,
    next: Twig.expression.set.expressions.concat([Twig.expression.type.parameter.end]),
    validate: function validate(match, tokens) {
      var lastToken = tokens[tokens.length - 1]; // We can't use the regex to test if we follow a space because expression is trimmed

      return lastToken && !Twig.expression.reservedWords.includes(lastToken.value.trim());
    },
    compile: Twig.expression.fn.compile.pushBoth,
    parse: Twig.expression.fn.parse.push
  }, {
    /**
     * Match a parameter set end.
     */
    type: Twig.expression.type.parameter.end,
    regex: /^\)/,
    next: Twig.expression.set.operationsExtended,
    compile: function compile(token, stack, output) {
      var stackToken;
      var endToken = token;
      stackToken = stack.pop();

      while (stack.length > 0 && stackToken.type !== Twig.expression.type.parameter.start) {
        output.push(stackToken);
        stackToken = stack.pop();
      } // Move contents of parens into preceding filter


      var paramStack = [];

      while (token.type !== Twig.expression.type.parameter.start) {
        // Add token to arguments stack
        paramStack.unshift(token);
        token = output.pop();
      }

      paramStack.unshift(token); // Get the token preceding the parameters

      token = output[output.length - 1];

      if (token === undefined || token.type !== Twig.expression.type._function && token.type !== Twig.expression.type.filter && token.type !== Twig.expression.type.test && token.type !== Twig.expression.type.key.brackets) {
        endToken.expression = true; // Remove start and end token from stack

        paramStack.pop();
        paramStack.shift();
        endToken.params = paramStack;
        output.push(endToken);
      } else {
        endToken.expression = false;
        token.params = paramStack;
      }
    },
    parse: function parse(token, stack, context) {
      var newArray = [];
      var arrayEnded = false;
      var value = null;
      var state = this;

      if (token.expression) {
        return Twig.expression.parseAsync.call(state, token.params, context).then(function (value) {
          stack.push(value);
        });
      }

      while (stack.length > 0) {
        value = stack.pop(); // Push values into the array until the start of the array

        if (value && value.type && value.type === Twig.expression.type.parameter.start) {
          arrayEnded = true;
          break;
        }

        newArray.unshift(value);
      }

      if (!arrayEnded) {
        throw new Twig.Error('Expected end of parameter set.');
      }

      stack.push(newArray);
    }
  }, {
    type: Twig.expression.type.slice,
    regex: /^\[(\d*:\d*)\]/,
    next: Twig.expression.set.operationsExtended,
    compile: function compile(token, stack, output) {
      var sliceRange = token.match[1].split(':'); // SliceStart can be undefined when we pass parameters to the slice filter later

      var sliceStart = sliceRange[0] ? parseInt(sliceRange[0], 10) : undefined;
      var sliceEnd = sliceRange[1] ? parseInt(sliceRange[1], 10) : undefined;
      token.value = 'slice';
      token.params = [sliceStart, sliceEnd]; // SliceEnd can't be undefined as the slice filter doesn't check for this, but it does check the length
      // of the params array, so just shorten it.

      if (!sliceEnd) {
        token.params = [sliceStart];
      }

      output.push(token);
    },
    parse: function parse(token, stack) {
      var input = stack.pop();
      var params = token.params;
      var state = this;
      stack.push(Twig.filter.call(state, token.value, input, params));
    }
  }, {
    /**
     * Match an array start.
     */
    type: Twig.expression.type.array.start,
    regex: /^\[/,
    next: Twig.expression.set.expressions.concat([Twig.expression.type.array.end]),
    compile: Twig.expression.fn.compile.pushBoth,
    parse: Twig.expression.fn.parse.push
  }, {
    /**
     * Match an array end.
     */
    type: Twig.expression.type.array.end,
    regex: /^\]/,
    next: Twig.expression.set.operationsExtended,
    compile: function compile(token, stack, output) {
      var i = stack.length - 1;
      var stackToken; // Pop tokens off the stack until the start of the object

      for (; i >= 0; i--) {
        stackToken = stack.pop();

        if (stackToken.type === Twig.expression.type.array.start) {
          break;
        }

        output.push(stackToken);
      }

      output.push(token);
    },
    parse: function parse(token, stack) {
      var newArray = [];
      var arrayEnded = false;
      var value = null;

      while (stack.length > 0) {
        value = stack.pop(); // Push values into the array until the start of the array

        if (value && value.type && value.type === Twig.expression.type.array.start) {
          arrayEnded = true;
          break;
        }

        newArray.unshift(value);
      }

      if (!arrayEnded) {
        throw new Twig.Error('Expected end of array.');
      }

      stack.push(newArray);
    }
  }, // Token that represents the start of a hash map '}'
  //
  // Hash maps take the form:
  //    { "key": 'value', "another_key": item }
  //
  // Keys must be quoted (either single or double) and values can be any expression.
  {
    type: Twig.expression.type.object.start,
    regex: /^\{/,
    next: Twig.expression.set.expressions.concat([Twig.expression.type.object.end]),
    compile: Twig.expression.fn.compile.pushBoth,
    parse: Twig.expression.fn.parse.push
  }, // Token that represents the end of a Hash Map '}'
  //
  // This is where the logic for building the internal
  // representation of a hash map is defined.
  {
    type: Twig.expression.type.object.end,
    regex: /^\}/,
    next: Twig.expression.set.operationsExtended,
    compile: function compile(token, stack, output) {
      var i = stack.length - 1;
      var stackToken; // Pop tokens off the stack until the start of the object

      for (; i >= 0; i--) {
        stackToken = stack.pop();

        if (stackToken && stackToken.type === Twig.expression.type.object.start) {
          break;
        }

        output.push(stackToken);
      }

      output.push(token);
    },
    parse: function parse(endToken, stack) {
      var newObject = {};
      var objectEnded = false;
      var token = null;
      var hasValue = false;
      var value = null;

      while (stack.length > 0) {
        token = stack.pop(); // Push values into the array until the start of the object

        if (token && token.type && token.type === Twig.expression.type.object.start) {
          objectEnded = true;
          break;
        }

        if (token && token.type && (token.type === Twig.expression.type.operator.binary || token.type === Twig.expression.type.operator.unary) && token.key) {
          if (!hasValue) {
            throw new Twig.Error('Missing value for key \'' + token.key + '\' in object definition.');
          }

          newObject[token.key] = value; // Preserve the order that elements are added to the map
          // This is necessary since JavaScript objects don't
          // guarantee the order of keys

          if (newObject._keys === undefined) {
            newObject._keys = [];
          }

          newObject._keys.unshift(token.key); // Reset value check


          value = null;
          hasValue = false;
        } else {
          hasValue = true;
          value = token;
        }
      }

      if (!objectEnded) {
        throw new Twig.Error('Unexpected end of object.');
      }

      stack.push(newObject);
    }
  }, // Token representing a filter
  //
  // Filters can follow any expression and take the form:
  //    expression|filter(optional, args)
  //
  // Filter parsing is done in the Twig.filters namespace.
  {
    type: Twig.expression.type.filter,
    // Match a | then a letter or _, then any number of letters, numbers, _ or -
    regex: /^\|\s?([a-zA-Z_][a-zA-Z0-9_-]*)/,
    next: Twig.expression.set.operationsExtended.concat([Twig.expression.type.parameter.start]),
    compile: function compile(token, stack, output) {
      token.value = token.match[1];
      output.push(token);
    },
    parse: function parse(token, stack, context) {
      var input = stack.pop();
      var state = this;
      return parseParams(state, token.params, context).then(function (params) {
        return Twig.filter.call(state, token.value, input, params);
      }).then(function (value) {
        stack.push(value);
      });
    }
  }, {
    type: Twig.expression.type._function,
    // Match any letter or _, then any number of letters, numbers, _ or - followed by (
    regex: /^([a-zA-Z_]\w*)\s*\(/,
    next: Twig.expression.type.parameter.start,
    validate: function validate(match) {
      // Make sure this function is not a reserved word
      return match[1] && !Twig.expression.reservedWords.includes(match[1]);
    },
    transform: function transform() {
      return '(';
    },
    compile: function compile(token, stack, output) {
      var fn = token.match[1];
      token.fn = fn; // Cleanup token

      delete token.match;
      delete token.value;
      output.push(token);
    },
    parse: function parse(token, stack, context) {
      var state = this;
      var fn = token.fn;
      var value;
      return parseParams(state, token.params, context).then(function (params) {
        if (Twig.functions[fn]) {
          // Get the function from the built-in functions
          value = Twig.functions[fn].apply(state, params);
        } else if (typeof context[fn] === 'function') {
          // Get the function from the user/context defined functions
          value = context[fn].apply(context, (0, _toConsumableArray2["default"])(params));
        } else {
          throw new Twig.Error(fn + ' function does not exist and is not defined in the context');
        }

        return value;
      }).then(function (result) {
        stack.push(result);
      });
    }
  }, // Token representing a variable.
  //
  // Variables can contain letters, numbers, underscores and
  // dashes, but must start with a letter or underscore.
  //
  // Variables are retrieved from the render context and take
  // the value of 'undefined' if the given variable doesn't
  // exist in the context.
  {
    type: Twig.expression.type.variable,
    // Match any letter or _, then any number of letters, numbers, _ or -
    regex: /^[a-zA-Z_]\w*/,
    next: Twig.expression.set.operationsExtended.concat([Twig.expression.type.parameter.start]),
    compile: Twig.expression.fn.compile.push,
    validate: function validate(match) {
      return !Twig.expression.reservedWords.includes(match[0]);
    },
    parse: function parse(token, stack, context) {
      var state = this; // Get the variable from the context

      return Twig.expression.resolveAsync.call(state, context[token.value], context).then(function (value) {
        if (state.template.options.strictVariables && value === undefined) {
          throw new Twig.Error('Variable "' + token.value + '" does not exist.');
        }

        stack.push(value);
      });
    }
  }, {
    type: Twig.expression.type.key.period,
    regex: /^\.(\w+)/,
    next: Twig.expression.set.operationsExtended.concat([Twig.expression.type.parameter.start]),
    compile: function compile(token, stack, output) {
      token.key = token.match[1];
      delete token.match;
      delete token.value;
      output.push(token);
    },
    parse: function parse(token, stack, context, nextToken) {
      var state = this;
      var key = token.key;
      var object = stack.pop();
      var value;

      if (object && !Object.prototype.hasOwnProperty.call(object, key) && state.template.options.strictVariables) {
        var keys = Object.keys(object);

        if (keys.length > 0) {
          throw new Twig.Error('Key "' + key + '" for object with keys "' + Object.keys(object).join(', ') + '" does not exist.');
        } else {
          throw new Twig.Error('Key "' + key + '" does not exist as the object is empty.');
        }
      }

      return parseParams(state, token.params, context).then(function (params) {
        if (object === null || object === undefined) {
          value = undefined;
        } else {
          var capitalize = function capitalize(value) {
            return value.slice(0, 1).toUpperCase() + value.slice(1);
          }; // Get the variable from the context


          if ((0, _typeof2["default"])(object) === 'object' && key in object) {
            value = object[key];
          } else if (object['get' + capitalize(key)]) {
            value = object['get' + capitalize(key)];
          } else if (object['is' + capitalize(key)]) {
            value = object['is' + capitalize(key)];
          } else {
            value = undefined;
          }
        } // When resolving an expression we need to pass nextToken in case the expression is a function


        return Twig.expression.resolveAsync.call(state, value, context, params, nextToken, object);
      }).then(function (result) {
        stack.push(result);
      });
    }
  }, {
    type: Twig.expression.type.key.brackets,
    regex: /^\[([^\]:]*)\]/,
    next: Twig.expression.set.operationsExtended.concat([Twig.expression.type.parameter.start]),
    compile: function compile(token, stack, output) {
      var match = token.match[1];
      delete token.value;
      delete token.match; // The expression stack for the key

      token.stack = Twig.expression.compile({
        value: match
      }).stack;
      output.push(token);
    },
    parse: function parse(token, stack, context, nextToken) {
      // Evaluate key
      var state = this;
      var params = null;
      var object;
      var value;
      return parseParams(state, token.params, context).then(function (parameters) {
        params = parameters;
        return Twig.expression.parseAsync.call(state, token.stack, context);
      }).then(function (key) {
        object = stack.pop();

        if (object && !Object.prototype.hasOwnProperty.call(object, key) && state.template.options.strictVariables) {
          var keys = Object.keys(object);

          if (keys.length > 0) {
            throw new Twig.Error('Key "' + key + '" for array with keys "' + keys.join(', ') + '" does not exist.');
          } else {
            throw new Twig.Error('Key "' + key + '" does not exist as the array is empty.');
          }
        } else if (object === null || object === undefined) {
          return null;
        } // Get the variable from the context


        if ((0, _typeof2["default"])(object) === 'object' && key in object) {
          value = object[key];
        } else {
          value = null;
        } // When resolving an expression we need to pass nextToken in case the expression is a function


        return Twig.expression.resolveAsync.call(state, value, object, params, nextToken);
      }).then(function (result) {
        stack.push(result);
      });
    }
  }, {
    /**
     * Match a null value.
     */
    type: Twig.expression.type._null,
    // Match a number
    regex: /^(null|NULL|none|NONE)/,
    next: Twig.expression.set.operations,
    compile: function compile(token, stack, output) {
      delete token.match;
      token.value = null;
      output.push(token);
    },
    parse: Twig.expression.fn.parse.pushValue
  }, {
    /**
     * Match the context
     */
    type: Twig.expression.type.context,
    regex: /^_context/,
    next: Twig.expression.set.operationsExtended.concat([Twig.expression.type.parameter.start]),
    compile: Twig.expression.fn.compile.push,
    parse: function parse(token, stack, context) {
      stack.push(context);
    }
  }, {
    /**
     * Match a boolean
     */
    type: Twig.expression.type.bool,
    regex: /^(true|TRUE|false|FALSE)/,
    next: Twig.expression.set.operations,
    compile: function compile(token, stack, output) {
      token.value = token.match[0].toLowerCase() === 'true';
      delete token.match;
      output.push(token);
    },
    parse: Twig.expression.fn.parse.pushValue
  }];
  /**
   * Resolve a context value.
   *
   * If the value is a function, it is executed with a context parameter.
   *
   * @param {string} key The context object key.
   * @param {Object} context The render context.
   */

  Twig.expression.resolveAsync = function (value, context, params, nextToken, object) {
    var state = this;

    if (typeof value !== 'function') {
      return Twig.Promise.resolve(value);
    }

    var promise = Twig.Promise.resolve(params);
    /*
    If value is a function, it will have been impossible during the compile stage to determine that a following
    set of parentheses were parameters for this function.
     Those parentheses will have therefore been marked as an expression, with their own parameters, which really
    belong to this function.
     Those parameters will also need parsing in case they are actually an expression to pass as parameters.
        */

    if (nextToken && nextToken.type === Twig.expression.type.parameter.end) {
      // When parsing these parameters, we need to get them all back, not just the last item on the stack.
      var tokensAreParameters = true;
      promise = promise.then(function () {
        return nextToken.params && Twig.expression.parseAsync.call(state, nextToken.params, context, tokensAreParameters);
      }).then(function (p) {
        // Clean up the parentheses tokens on the next loop
        nextToken.cleanup = true;
        return p;
      });
    }

    return promise.then(function (params) {
      return value.apply(object || context, params || []);
    });
  };

  Twig.expression.resolve = function (value, context, params, nextToken, object) {
    return Twig.async.potentiallyAsync(this, false, function () {
      return Twig.expression.resolveAsync.call(this, value, context, params, nextToken, object);
    });
  };
  /**
   * Registry for logic handlers.
   */


  Twig.expression.handler = {};
  /**
   * Define a new expression type, available at Twig.logic.type.{type}
   *
   * @param {string} type The name of the new type.
   */

  Twig.expression.extendType = function (type) {
    Twig.expression.type[type] = 'Twig.expression.type.' + type;
  };
  /**
   * Extend the expression parsing functionality with a new definition.
   *
   * Token definitions follow this format:
   *  {
   *      type:     One of Twig.expression.type.[type], either pre-defined or added using
   *                    Twig.expression.extendType
   *
   *      next:     Array of types from Twig.expression.type that can follow this token,
   *
   *      regex:    A regex or array of regex's that should match the token.
   *
   *      compile: function(token, stack, output) called when this token is being compiled.
   *                   Should return an object with stack and output set.
   *
   *      parse:   function(token, stack, context) called when this token is being parsed.
   *                   Should return an object with stack and context set.
   *  }
   *
   * @param {Object} definition A token definition.
   */


  Twig.expression.extend = function (definition) {
    if (!definition.type) {
      throw new Twig.Error('Unable to extend logic definition. No type provided for ' + definition);
    }

    Twig.expression.handler[definition.type] = definition;
  }; // Extend with built-in expressions


  while (Twig.expression.definitions.length > 0) {
    Twig.expression.extend(Twig.expression.definitions.shift());
  }
  /**
   * Break an expression into tokens defined in Twig.expression.definitions.
   *
   * @param {string} expression The string to tokenize.
   *
   * @return {Array} An array of tokens.
   */


  Twig.expression.tokenize = function (expression) {
    var tokens = []; // Keep an offset of the location in the expression for error messages.

    var expOffset = 0; // The valid next tokens of the previous token

    var next = null; // Match information

    var type;
    var regex;
    var regexI; // The possible next token for the match

    var tokenNext; // Has a match been found from the definitions

    var matchFound;
    var invalidMatches = [];

    var matchFunction = function matchFunction() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Don't pass arguments to `Array.slice`, that is a performance killer
      var matchI = arguments.length - 2;
      var match = new Array(matchI);

      while (matchI-- > 0) {
        match[matchI] = args[matchI];
      }

      Twig.log.trace('Twig.expression.tokenize', 'Matched a ', type, ' regular expression of ', match);

      if (next && !next.includes(type)) {
        invalidMatches.push(type + ' cannot follow a ' + tokens[tokens.length - 1].type + ' at template:' + expOffset + ' near \'' + match[0].slice(0, 20) + '...\''); // Not a match, don't change the expression

        return match[0];
      }

      var handler = Twig.expression.handler[type]; // Validate the token if a validation function is provided

      if (handler.validate && !handler.validate(match, tokens)) {
        return match[0];
      }

      invalidMatches = [];
      tokens.push({
        type: type,
        value: match[0],
        match: match
      });
      matchFound = true;
      next = tokenNext;
      expOffset += match[0].length; // Does the token need to return output back to the expression string
      // e.g. a function match of cycle( might return the '(' back to the expression
      // This allows look-ahead to differentiate between token types (e.g. functions and variable names)

      if (handler.transform) {
        return handler.transform(match, tokens);
      }

      return '';
    };

    Twig.log.debug('Twig.expression.tokenize', 'Tokenizing expression ', expression);

    while (expression.length > 0) {
      expression = expression.trim();

      for (type in Twig.expression.handler) {
        if (Object.hasOwnProperty.call(Twig.expression.handler, type)) {
          tokenNext = Twig.expression.handler[type].next;
          regex = Twig.expression.handler[type].regex;
          Twig.log.trace('Checking type ', type, ' on ', expression);
          matchFound = false;

          if (Array.isArray(regex)) {
            regexI = regex.length;

            while (regexI-- > 0) {
              expression = expression.replace(regex[regexI], matchFunction);
            }
          } else {
            expression = expression.replace(regex, matchFunction);
          } // An expression token has been matched. Break the for loop and start trying to
          //  match the next template (if expression isn't empty.)


          if (matchFound) {
            break;
          }
        }
      }

      if (!matchFound) {
        if (invalidMatches.length > 0) {
          throw new Twig.Error(invalidMatches.join(' OR '));
        } else {
          throw new Twig.Error('Unable to parse \'' + expression + '\' at template position' + expOffset);
        }
      }
    }

    Twig.log.trace('Twig.expression.tokenize', 'Tokenized to ', tokens);
    return tokens;
  };
  /**
   * Compile an expression token.
   *
   * @param {Object} rawToken The uncompiled token.
   *
   * @return {Object} The compiled token.
   */


  Twig.expression.compile = function (rawToken) {
    var expression = rawToken.value; // Tokenize expression

    var tokens = Twig.expression.tokenize(expression);
    var token = null;
    var output = [];
    var stack = [];
    var tokenTemplate = null;
    Twig.log.trace('Twig.expression.compile: ', 'Compiling ', expression); // Push tokens into RPN stack using the Shunting-yard algorithm
    // See http://en.wikipedia.org/wiki/Shunting_yard_algorithm

    while (tokens.length > 0) {
      token = tokens.shift();
      tokenTemplate = Twig.expression.handler[token.type];
      Twig.log.trace('Twig.expression.compile: ', 'Compiling ', token); // Compile the template

      tokenTemplate.compile(token, stack, output);
      Twig.log.trace('Twig.expression.compile: ', 'Stack is', stack);
      Twig.log.trace('Twig.expression.compile: ', 'Output is', output);
    }

    while (stack.length > 0) {
      output.push(stack.pop());
    }

    Twig.log.trace('Twig.expression.compile: ', 'Final output is', output);
    rawToken.stack = output;
    delete rawToken.value;
    return rawToken;
  };
  /**
   * Parse an RPN expression stack within a context.
   *
   * @param {Array} tokens An array of compiled expression tokens.
   * @param {Object} context The render context to parse the tokens with.
   *
   * @return {Object} The result of parsing all the tokens. The result
   *                  can be anything, String, Array, Object, etc... based on
   *                  the given expression.
   */


  Twig.expression.parse = function (tokens, context, tokensAreParameters, allowAsync) {
    var state = this; // If the token isn't an array, make it one.

    if (!Array.isArray(tokens)) {
      tokens = [tokens];
    } // The output stack


    var stack = [];
    var loopTokenFixups = [];
    var binaryOperator = Twig.expression.type.operator.binary;
    return Twig.async.potentiallyAsync(state, allowAsync, function () {
      return Twig.async.forEach(tokens, function (token, index) {
        var tokenTemplate = null;
        var nextToken = null;
        var result; // If the token is marked for cleanup, we don't need to parse it

        if (token.cleanup) {
          return;
        } // Determine the token that follows this one so that we can pass it to the parser


        if (tokens.length > index + 1) {
          nextToken = tokens[index + 1];
        }

        tokenTemplate = Twig.expression.handler[token.type];

        if (tokenTemplate.parse) {
          result = tokenTemplate.parse.call(state, token, stack, context, nextToken);
        } // Store any binary tokens for later if we are in a loop.


        if (token.type === binaryOperator && context.loop) {
          loopTokenFixups.push(token);
        }

        return result;
      }).then(function () {
        // Check every fixup and remove "key" as long as they still have "params". This covers the use case where
        // a ":" operator is used in a loop with a "(expression):" statement. We need to be able to evaluate the expression
        var len = loopTokenFixups.length;
        var loopTokenFixup = null;

        while (len-- > 0) {
          loopTokenFixup = loopTokenFixups[len];

          if (loopTokenFixup.params && loopTokenFixup.key) {
            delete loopTokenFixup.key;
          }
        } // If parse has been called with a set of tokens that are parameters, we need to return the whole stack,
        // wrapped in an Array.


        if (tokensAreParameters) {
          var params = stack.splice(0);
          stack.push(params);
        } // Pop the final value off the stack


        return stack.pop();
      });
    });
  };

  return Twig;
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(11);

var iterableToArray = __webpack_require__(12);

var nonIterableSpread = __webpack_require__(13);

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),
/* 11 */
/***/ (function(module, exports) {

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

module.exports = _arrayWithoutHoles;

/***/ }),
/* 12 */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),
/* 13 */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

module.exports = _nonIterableSpread;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// ## twig.expression.operator.js
//
// This file handles operator lookups and parsing.
module.exports = function (Twig) {
  'use strict';
  /**
   * Operator associativity constants.
   */

  Twig.expression.operator = {
    leftToRight: 'leftToRight',
    rightToLeft: 'rightToLeft'
  };

  var containment = function containment(a, b) {
    if (b === undefined || b === null) {
      return null;
    }

    if (b.indexOf !== undefined) {
      // String
      return (a === b || a !== '') && b.includes(a);
    }

    var el;

    for (el in b) {
      if (Object.hasOwnProperty.call(b, el) && b[el] === a) {
        return true;
      }
    }

    return false;
  };
  /**
   * Get the precidence and associativity of an operator. These follow the order that C/C++ use.
   * See http://en.wikipedia.org/wiki/Operators_in_C_and_C++ for the table of values.
   */


  Twig.expression.operator.lookup = function (operator, token) {
    switch (operator) {
      case '..':
        token.precidence = 20;
        token.associativity = Twig.expression.operator.leftToRight;
        break;

      case ',':
        token.precidence = 18;
        token.associativity = Twig.expression.operator.leftToRight;
        break;
      // Ternary

      case '?:':
      case '?':
      case ':':
        token.precidence = 16;
        token.associativity = Twig.expression.operator.rightToLeft;
        break;
      // Null-coalescing operator

      case '??':
        token.precidence = 15;
        token.associativity = Twig.expression.operator.rightToLeft;
        break;

      case 'or':
        token.precidence = 14;
        token.associativity = Twig.expression.operator.leftToRight;
        break;

      case 'and':
        token.precidence = 13;
        token.associativity = Twig.expression.operator.leftToRight;
        break;

      case 'b-or':
        token.precidence = 12;
        token.associativity = Twig.expression.operator.leftToRight;
        break;

      case 'b-xor':
        token.precidence = 11;
        token.associativity = Twig.expression.operator.leftToRight;
        break;

      case 'b-and':
        token.precidence = 10;
        token.associativity = Twig.expression.operator.leftToRight;
        break;

      case '==':
      case '!=':
        token.precidence = 9;
        token.associativity = Twig.expression.operator.leftToRight;
        break;

      case '<':
      case '<=':
      case '>':
      case '>=':
      case 'not in':
      case 'in':
        token.precidence = 8;
        token.associativity = Twig.expression.operator.leftToRight;
        break;

      case '~': // String concatination

      case '+':
      case '-':
        token.precidence = 6;
        token.associativity = Twig.expression.operator.leftToRight;
        break;

      case '//':
      case '**':
      case '*':
      case '/':
      case '%':
        token.precidence = 5;
        token.associativity = Twig.expression.operator.leftToRight;
        break;

      case 'not':
        token.precidence = 3;
        token.associativity = Twig.expression.operator.rightToLeft;
        break;

      case 'matches':
        token.precidence = 8;
        token.associativity = Twig.expression.operator.leftToRight;
        break;

      case 'starts with':
        token.precidence = 8;
        token.associativity = Twig.expression.operator.leftToRight;
        break;

      case 'ends with':
        token.precidence = 8;
        token.associativity = Twig.expression.operator.leftToRight;
        break;

      default:
        throw new Twig.Error('Failed to lookup operator: ' + operator + ' is an unknown operator.');
    }

    token.operator = operator;
    return token;
  };
  /**
   * Handle operations on the RPN stack.
   *
   * Returns the updated stack.
   */


  Twig.expression.operator.parse = function (operator, stack) {
    Twig.log.trace('Twig.expression.operator.parse: ', 'Handling ', operator);
    var a;
    var b;
    var c;

    if (operator === '?') {
      c = stack.pop();
    }

    b = stack.pop();

    if (operator !== 'not') {
      a = stack.pop();
    }

    if (operator !== 'in' && operator !== 'not in' && operator !== '??') {
      if (a && Array.isArray(a)) {
        a = a.length;
      }

      if (b && Array.isArray(b)) {
        b = b.length;
      }
    }

    if (operator === 'matches') {
      if (b && typeof b === 'string') {
        var reParts = b.match(/^\/(.*)\/([gims]?)$/);
        var reBody = reParts[1];
        var reFlags = reParts[2];
        b = new RegExp(reBody, reFlags);
      }
    }

    switch (operator) {
      case ':':
        // Ignore
        break;

      case '??':
        if (a === undefined) {
          a = b;
          b = c;
          c = undefined;
        }

        if (a !== undefined && a !== null) {
          stack.push(a);
        } else {
          stack.push(b);
        }

        break;

      case '?:':
        if (Twig.lib.boolval(a)) {
          stack.push(a);
        } else {
          stack.push(b);
        }

        break;

      case '?':
        if (a === undefined) {
          // An extended ternary.
          a = b;
          b = c;
          c = undefined;
        }

        if (Twig.lib.boolval(a)) {
          stack.push(b);
        } else {
          stack.push(c);
        }

        break;

      case '+':
        b = parseFloat(b);
        a = parseFloat(a);
        stack.push(a + b);
        break;

      case '-':
        b = parseFloat(b);
        a = parseFloat(a);
        stack.push(a - b);
        break;

      case '*':
        b = parseFloat(b);
        a = parseFloat(a);
        stack.push(a * b);
        break;

      case '/':
        b = parseFloat(b);
        a = parseFloat(a);
        stack.push(a / b);
        break;

      case '//':
        b = parseFloat(b);
        a = parseFloat(a);
        stack.push(Math.floor(a / b));
        break;

      case '%':
        b = parseFloat(b);
        a = parseFloat(a);
        stack.push(a % b);
        break;

      case '~':
        stack.push((typeof a !== 'undefined' && a !== null ? a.toString() : '') + (typeof b !== 'undefined' && b !== null ? b.toString() : ''));
        break;

      case 'not':
      case '!':
        stack.push(!Twig.lib.boolval(b));
        break;

      case '<':
        stack.push(a < b);
        break;

      case '<=':
        stack.push(a <= b);
        break;

      case '>':
        stack.push(a > b);
        break;

      case '>=':
        stack.push(a >= b);
        break;

      case '===':
        stack.push(a === b);
        break;

      case '==':
        /* eslint-disable-next-line eqeqeq */
        stack.push(a == b);
        break;

      case '!==':
        stack.push(a !== b);
        break;

      case '!=':
        /* eslint-disable-next-line eqeqeq */
        stack.push(a != b);
        break;

      case 'or':
        stack.push(Twig.lib.boolval(a) || Twig.lib.boolval(b));
        break;

      case 'b-or':
        stack.push(a | b);
        break;

      case 'b-xor':
        stack.push(a ^ b);
        break;

      case 'and':
        stack.push(Twig.lib.boolval(a) && Twig.lib.boolval(b));
        break;

      case 'b-and':
        stack.push(a & b);
        break;

      case '**':
        stack.push(Math.pow(a, b));
        break;

      case 'not in':
        stack.push(!containment(a, b));
        break;

      case 'in':
        stack.push(containment(a, b));
        break;

      case 'matches':
        stack.push(b.test(a));
        break;

      case 'starts with':
        stack.push(typeof a === 'string' && a.indexOf(b) === 0);
        break;

      case 'ends with':
        stack.push(typeof a === 'string' && a.includes(b, a.length - b.length));
        break;

      case '..':
        stack.push(Twig.functions.range(a, b));
        break;

      default:
        throw new Twig.Error('Failed to parse operator: ' + operator + ' is an unknown operator.');
    }
  };

  return Twig;
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(0);

var _typeof2 = _interopRequireDefault(__webpack_require__(1));

// ## twig.filters.js
//
// This file handles parsing filters.
module.exports = function (Twig) {
  // Determine object type
  function is(type, obj) {
    var clas = Object.prototype.toString.call(obj).slice(8, -1);
    return obj !== undefined && obj !== null && clas === type;
  }

  Twig.filters = {
    // String Filters
    upper: function upper(value) {
      if (typeof value !== 'string') {
        return value;
      }

      return value.toUpperCase();
    },
    lower: function lower(value) {
      if (typeof value !== 'string') {
        return value;
      }

      return value.toLowerCase();
    },
    capitalize: function capitalize(value) {
      if (typeof value !== 'string') {
        return value;
      }

      return value.slice(0, 1).toUpperCase() + value.toLowerCase().slice(1);
    },
    title: function title(value) {
      if (typeof value !== 'string') {
        return value;
      }

      return value.toLowerCase().replace(/(^|\s)([a-z])/g, function (m, p1, p2) {
        return p1 + p2.toUpperCase();
      });
    },
    length: function length(value) {
      if (Twig.lib.is('Array', value) || typeof value === 'string') {
        return value.length;
      }

      if (Twig.lib.is('Object', value)) {
        if (value._keys === undefined) {
          return Object.keys(value).length;
        }

        return value._keys.length;
      }

      return 0;
    },
    // Array/Object Filters
    reverse: function reverse(value) {
      if (is('Array', value)) {
        return value.reverse();
      }

      if (is('String', value)) {
        return value.split('').reverse().join('');
      }

      if (is('Object', value)) {
        var keys = value._keys || Object.keys(value).reverse();
        value._keys = keys;
        return value;
      }
    },
    sort: function sort(value) {
      if (is('Array', value)) {
        return value.sort();
      }

      if (is('Object', value)) {
        // Sorting objects isn't obvious since the order of
        // returned keys isn't guaranteed in JavaScript.
        // Because of this we use a "hidden" key called _keys to
        // store the keys in the order we want to return them.
        delete value._keys;
        var keys = Object.keys(value);
        var sortedKeys = keys.sort(function (a, b) {
          var a1;
          var b1; // If a and b are comparable, we're fine :-)

          if (value[a] > value[b] === !(value[a] <= value[b])) {
            return value[a] > value[b] ? 1 : value[a] < value[b] ? -1 : 0;
          } // If a and b can be parsed as numbers, we can compare
          // their numeric value


          if (!isNaN(a1 = parseFloat(value[a])) && !isNaN(b1 = parseFloat(value[b]))) {
            return a1 > b1 ? 1 : a1 < b1 ? -1 : 0;
          } // If one of the values is a string, we convert the
          // other value to string as well


          if (typeof value[a] === 'string') {
            return value[a] > value[b].toString() ? 1 : value[a] < value[b].toString() ? -1 : 0;
          }

          if (typeof value[b] === 'string') {
            return value[a].toString() > value[b] ? 1 : value[a].toString() < value[b] ? -1 : 0;
          } // Everything failed - return 'null' as sign, that
          // the values are not comparable


          return null;
        });
        value._keys = sortedKeys;
        return value;
      }
    },
    keys: function keys(value) {
      if (value === undefined || value === null) {
        return;
      }

      var keyset = value._keys || Object.keys(value);
      var output = [];
      keyset.forEach(function (key) {
        if (key === '_keys') {
          return;
        } // Ignore the _keys property


        if (Object.hasOwnProperty.call(value, key)) {
          output.push(key);
        }
      });
      return output;
    },

    /* eslint-disable-next-line camelcase */
    url_encode: function url_encode(value) {
      if (value === undefined || value === null) {
        return;
      }

      if (Twig.lib.is('Object', value)) {
        var serialize = function serialize(obj, prefix) {
          var result = [];
          var keyset = obj._keys || Object.keys(obj);
          keyset.forEach(function (key) {
            if (!Object.prototype.hasOwnProperty.call(obj, key)) {
              return;
            }

            var resultKey = prefix ? prefix + '[' + key + ']' : key;
            var resultValue = obj[key];
            result.push(Twig.lib.is('Object', resultValue) || Array.isArray(resultValue) ? serialize(resultValue, resultKey) : encodeURIComponent(resultKey) + '=' + encodeURIComponent(resultValue));
          });
          return result.join('&amp;');
        };

        return serialize(value);
      }

      var result = encodeURIComponent(value);
      result = result.replace('\'', '%27');
      return result;
    },
    join: function join(value, params) {
      if (value === undefined || value === null) {
        return;
      }

      var joinStr = '';
      var output = [];
      var keyset = null;

      if (params && params[0]) {
        joinStr = params[0];
      }

      if (is('Array', value)) {
        output = value;
      } else {
        keyset = value._keys || Object.keys(value);
        keyset.forEach(function (key) {
          if (key === '_keys') {
            return;
          } // Ignore the _keys property


          if (Object.hasOwnProperty.call(value, key)) {
            output.push(value[key]);
          }
        });
      }

      return output.join(joinStr);
    },
    "default": function _default(value, params) {
      if (params !== undefined && params.length > 1) {
        throw new Twig.Error('default filter expects one argument');
      }

      if (value === undefined || value === null || value === '') {
        if (params === undefined) {
          return '';
        }

        return params[0];
      }

      return value;
    },

    /* eslint-disable-next-line camelcase */
    json_encode: function json_encode(value) {
      if (value === undefined || value === null) {
        return 'null';
      }

      if ((0, _typeof2["default"])(value) === 'object' && is('Array', value)) {
        var output = [];
        value.forEach(function (v) {
          output.push(Twig.filters.json_encode(v));
        });
        return '[' + output.join(',') + ']';
      }

      if ((0, _typeof2["default"])(value) === 'object' && is('Date', value)) {
        return '"' + value.toISOString() + '"';
      }

      if ((0, _typeof2["default"])(value) === 'object') {
        var keyset = value._keys || Object.keys(value);
        var _output = [];
        keyset.forEach(function (key) {
          _output.push(JSON.stringify(key) + ':' + Twig.filters.json_encode(value[key]));
        });
        return '{' + _output.join(',') + '}';
      }

      return JSON.stringify(value);
    },
    merge: function merge(value, params) {
      var obj = [];
      var arrIndex = 0;
      var keyset = []; // Check to see if all the objects being merged are arrays

      if (is('Array', value)) {
        params.forEach(function (param) {
          if (!is('Array', param)) {
            obj = {};
          }
        });
      } else {
        // Create obj as an Object
        obj = {};
      }

      if (!is('Array', obj)) {
        obj._keys = [];
      }

      if (is('Array', value)) {
        value.forEach(function (val) {
          if (obj._keys) {
            obj._keys.push(arrIndex);
          }

          obj[arrIndex] = val;
          arrIndex++;
        });
      } else {
        keyset = value._keys || Object.keys(value);
        keyset.forEach(function (key) {
          obj[key] = value[key];

          obj._keys.push(key); // Handle edge case where a number index in an object is greater than
          //   the array counter. In such a case, the array counter is increased
          //   one past the index.
          //
          // Example {{ ["a", "b"]|merge({"4":"value"}, ["c", "d"])
          // Without this, d would have an index of "4" and overwrite the value
          //   of "value"


          var intKey = parseInt(key, 10);

          if (!isNaN(intKey) && intKey >= arrIndex) {
            arrIndex = intKey + 1;
          }
        });
      } // Mixin the merge arrays


      params.forEach(function (param) {
        if (is('Array', param)) {
          param.forEach(function (val) {
            if (obj._keys) {
              obj._keys.push(arrIndex);
            }

            obj[arrIndex] = val;
            arrIndex++;
          });
        } else {
          keyset = param._keys || Object.keys(param);
          keyset.forEach(function (key) {
            if (!obj[key]) {
              obj._keys.push(key);
            }

            obj[key] = param[key];
            var intKey = parseInt(key, 10);

            if (!isNaN(intKey) && intKey >= arrIndex) {
              arrIndex = intKey + 1;
            }
          });
        }
      });

      if (params.length === 0) {
        throw new Twig.Error('Filter merge expects at least one parameter');
      }

      return obj;
    },
    date: function date(value, params) {
      var date = Twig.functions.date(value);
      var format = params && Boolean(params.length) ? params[0] : 'F j, Y H:i';
      return Twig.lib.date(format.replace(/\\\\/g, '\\'), date);
    },

    /* eslint-disable-next-line camelcase */
    date_modify: function date_modify(value, params) {
      if (value === undefined || value === null) {
        return;
      }

      if (params === undefined || params.length !== 1) {
        throw new Twig.Error('date_modify filter expects 1 argument');
      }

      var modifyText = params[0];
      var time;

      if (Twig.lib.is('Date', value)) {
        time = Twig.lib.strtotime(modifyText, value.getTime() / 1000);
      }

      if (Twig.lib.is('String', value)) {
        time = Twig.lib.strtotime(modifyText, Twig.lib.strtotime(value));
      }

      if (Twig.lib.is('Number', value)) {
        time = Twig.lib.strtotime(modifyText, value);
      }

      return new Date(time * 1000);
    },
    replace: function replace(value, params) {
      if (value === undefined || value === null) {
        return;
      }

      var pairs = params[0];
      var tag;

      for (tag in pairs) {
        if (Object.hasOwnProperty.call(pairs, tag) && tag !== '_keys') {
          value = Twig.lib.replaceAll(value, tag, pairs[tag]);
        }
      }

      return value;
    },
    format: function format(value, params) {
      if (value === undefined || value === null) {
        return;
      }

      return Twig.lib.vsprintf(value, params);
    },
    striptags: function striptags(value, allowed) {
      if (value === undefined || value === null) {
        return;
      }

      return Twig.lib.stripTags(value, allowed);
    },
    escape: function escape(value, params) {
      if (value === undefined || value === null || value === '') {
        return;
      }

      var strategy = 'html';

      if (params && Boolean(params.length) && params[0] !== true) {
        strategy = params[0];
      }

      if (strategy === 'html') {
        var rawValue = value.toString().replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
        return new Twig.Markup(rawValue, 'html');
      }

      if (strategy === 'js') {
        var _rawValue = value.toString();

        var result = '';

        for (var i = 0; i < _rawValue.length; i++) {
          if (_rawValue[i].match(/^[a-zA-Z0-9,._]$/)) {
            result += _rawValue[i];
          } else {
            var _char = _rawValue.charAt(i);

            var charCode = _rawValue.charCodeAt(i); // A few characters have short escape sequences in JSON and JavaScript.
            // Escape sequences supported only by JavaScript, not JSON, are ommitted.
            // \" is also supported but omitted, because the resulting string is not HTML safe.


            var shortMap = {
              '\\': '\\\\',
              '/': '\\/',
              "\b": '\\b',
              "\f": '\\f',
              "\n": '\\n',
              "\r": '\\r',
              "\t": '\\t'
            };

            if (shortMap[_char]) {
              result += shortMap[_char];
            } else {
              result += Twig.lib.sprintf("\\u%04s", charCode.toString(16).toUpperCase());
            }
          }
        }

        return new Twig.Markup(result, 'js');
      }

      if (strategy === 'css') {
        var _rawValue2 = value.toString();

        var _result = '';

        for (var _i = 0; _i < _rawValue2.length; _i++) {
          if (_rawValue2[_i].match(/^[a-zA-Z0-9]$/)) {
            _result += _rawValue2[_i];
          } else {
            var _charCode = _rawValue2.charCodeAt(_i);

            _result += '\\' + _charCode.toString(16).toUpperCase() + ' ';
          }
        }

        return new Twig.Markup(_result, 'css');
      }

      if (strategy === 'url') {
        var _result2 = Twig.filters.url_encode(value);

        return new Twig.Markup(_result2, 'url');
      }

      if (strategy === 'html_attr') {
        var _rawValue3 = value.toString();

        var _result3 = '';

        for (var _i2 = 0; _i2 < _rawValue3.length; _i2++) {
          if (_rawValue3[_i2].match(/^[a-zA-Z0-9,.\-_]$/)) {
            _result3 += _rawValue3[_i2];
          } else if (_rawValue3[_i2].match(/^[&<>"]$/)) {
            _result3 += _rawValue3[_i2].replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
          } else {
            var _charCode2 = _rawValue3.charCodeAt(_i2); // The following replaces characters undefined in HTML with
            // the hex entity for the Unicode replacement character.


            if (_charCode2 <= 0x1F && _charCode2 !== 0x09 && _charCode2 !== 0x0A && _charCode2 !== 0x0D) {
              _result3 += '&#xFFFD;';
            } else if (_charCode2 < 0x80) {
              _result3 += Twig.lib.sprintf('&#x%02s;', _charCode2.toString(16).toUpperCase());
            } else {
              _result3 += Twig.lib.sprintf('&#x%04s;', _charCode2.toString(16).toUpperCase());
            }
          }
        }

        return new Twig.Markup(_result3, 'html_attr');
      }

      throw new Twig.Error('escape strategy unsupported');
    },

    /* Alias of escape */
    e: function e(value, params) {
      return Twig.filters.escape(value, params);
    },
    nl2br: function nl2br(value) {
      if (value === undefined || value === null || value === '') {
        return;
      }

      var linebreakTag = 'BACKSLASH_n_replace';
      var br = '<br />' + linebreakTag;
      value = Twig.filters.escape(value).replace(/\r\n/g, br).replace(/\r/g, br).replace(/\n/g, br);
      value = Twig.lib.replaceAll(value, linebreakTag, '\n');
      return new Twig.Markup(value);
    },

    /**
     * Adapted from: http://phpjs.org/functions/number_format:481
     */

    /* eslint-disable-next-line camelcase */
    number_format: function number_format(value, params) {
      var number = value;
      var decimals = params && params[0] ? params[0] : undefined;
      var dec = params && params[1] !== undefined ? params[1] : '.';
      var sep = params && params[2] !== undefined ? params[2] : ',';
      number = String(number).replace(/[^0-9+\-Ee.]/g, '');
      var n = isFinite(Number(number)) ? Number(number) : 0;
      var prec = isFinite(Number(decimals)) ? Math.abs(decimals) : 0;
      var s = '';

      var toFixedFix = function toFixedFix(n, prec) {
        var k = Math.pow(10, prec);
        return String(Math.round(n * k) / k);
      }; // Fix for IE parseFloat(0.55).toFixed(0) = 0;


      s = (prec ? toFixedFix(n, prec) : String(Math.round(n))).split('.');

      if (s[0].length > 3) {
        s[0] = s[0].replace(/\B(?=(?:\d{3})+(?!\d))/g, sep);
      }

      if ((s[1] || '').length < prec) {
        s[1] = s[1] || '';
        s[1] += new Array(prec - s[1].length + 1).join('0');
      }

      return s.join(dec);
    },
    trim: function trim(value, params) {
      if (value === undefined || value === null) {
        return;
      }

      var str = String(value);
      var whitespace;

      if (params && params[0]) {
        whitespace = String(params[0]);
      } else {
        whitespace = " \n\r\t\f\x0B\xA0\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u200B\u2028\u2029\u3000";
      }

      for (var i = 0; i < str.length; i++) {
        if (!whitespace.includes(str.charAt(i))) {
          str = str.slice(Math.max(0, i));
          break;
        }
      }

      for (var _i3 = str.length - 1; _i3 >= 0; _i3--) {
        if (!whitespace.includes(str.charAt(_i3))) {
          str = str.slice(0, Math.max(0, _i3 + 1));
          break;
        }
      }

      return whitespace.includes(str.charAt(0)) ? '' : str;
    },
    truncate: function truncate(value, params) {
      var length = 30;
      var preserve = false;
      var separator = '...';
      value = String(value);

      if (params) {
        if (params[0]) {
          length = params[0];
        }

        if (params[1]) {
          preserve = params[1];
        }

        if (params[2]) {
          separator = params[2];
        }
      }

      if (value.length > length) {
        if (preserve) {
          length = value.indexOf(' ', length);

          if (length === -1) {
            return value;
          }
        }

        value = value.slice(0, length) + separator;
      }

      return value;
    },
    slice: function slice(value, params) {
      if (value === undefined || value === null) {
        return;
      }

      if (params === undefined || params.length === 0) {
        throw new Twig.Error('slice filter expects at least 1 argument');
      } // Default to start of string


      var start = params[0] || 0; // Default to length of string

      var length = params.length > 1 ? params[1] : value.length; // Handle negative start values

      var startIndex = start >= 0 ? start : Math.max(value.length + start, 0);

      if (Twig.lib.is('Array', value)) {
        var output = [];

        for (var i = startIndex; i < startIndex + length && i < value.length; i++) {
          output.push(value[i]);
        }

        return output;
      }

      if (Twig.lib.is('String', value)) {
        return value.slice(startIndex, startIndex + length);
      }

      throw new Twig.Error('slice filter expects value to be an array or string');
    },
    abs: function abs(value) {
      if (value === undefined || value === null) {
        return;
      }

      return Math.abs(value);
    },
    first: function first(value) {
      if (is('Array', value)) {
        return value[0];
      }

      if (is('Object', value)) {
        if ('_keys' in value) {
          return value[value._keys[0]];
        }
      } else if (typeof value === 'string') {
        return value.slice(0, 1);
      }
    },
    split: function split(value, params) {
      if (value === undefined || value === null) {
        return;
      }

      if (params === undefined || params.length === 0 || params.length > 2) {
        throw new Twig.Error('split filter expects 1 or 2 argument');
      }

      if (Twig.lib.is('String', value)) {
        var delimiter = params[0];
        var limit = params[1];
        var split = value.split(delimiter);

        if (limit === undefined) {
          return split;
        }

        if (limit < 0) {
          return value.split(delimiter, split.length + limit);
        }

        var limitedSplit = [];

        if (delimiter === '') {
          // Empty delimiter
          // "aabbcc"|split('', 2)
          //     -> ['aa', 'bb', 'cc']
          while (split.length > 0) {
            var temp = '';

            for (var i = 0; i < limit && split.length > 0; i++) {
              temp += split.shift();
            }

            limitedSplit.push(temp);
          }
        } else {
          // Non-empty delimiter
          // "one,two,three,four,five"|split(',', 3)
          //     -> ['one', 'two', 'three,four,five']
          for (var _i4 = 0; _i4 < limit - 1 && split.length > 0; _i4++) {
            limitedSplit.push(split.shift());
          }

          if (split.length > 0) {
            limitedSplit.push(split.join(delimiter));
          }
        }

        return limitedSplit;
      }

      throw new Twig.Error('split filter expects value to be a string');
    },
    last: function last(value) {
      if (Twig.lib.is('Object', value)) {
        var keys;

        if (value._keys === undefined) {
          keys = Object.keys(value);
        } else {
          keys = value._keys;
        }

        return value[keys[keys.length - 1]];
      }

      if (Twig.lib.is('Number', value)) {
        return value.toString().slice(-1);
      } // String|array


      return value[value.length - 1];
    },
    raw: function raw(value) {
      return new Twig.Markup(value || '');
    },
    batch: function batch(items, params) {
      var size = params.shift();
      var fill = params.shift();
      var last;
      var missing;

      if (!Twig.lib.is('Array', items)) {
        throw new Twig.Error('batch filter expects items to be an array');
      }

      if (!Twig.lib.is('Number', size)) {
        throw new Twig.Error('batch filter expects size to be a number');
      }

      size = Math.ceil(size);
      var result = Twig.lib.chunkArray(items, size);

      if (fill && items.length % size !== 0) {
        last = result.pop();
        missing = size - last.length;

        while (missing--) {
          last.push(fill);
        }

        result.push(last);
      }

      return result;
    },
    round: function round(value, params) {
      params = params || [];
      var precision = params.length > 0 ? params[0] : 0;
      var method = params.length > 1 ? params[1] : 'common';
      value = parseFloat(value);

      if (precision && !Twig.lib.is('Number', precision)) {
        throw new Twig.Error('round filter expects precision to be a number');
      }

      if (method === 'common') {
        return Twig.lib.round(value, precision);
      }

      if (!Twig.lib.is('Function', Math[method])) {
        throw new Twig.Error('round filter expects method to be \'floor\', \'ceil\', or \'common\'');
      }

      return Math[method](value * Math.pow(10, precision)) / Math.pow(10, precision);
    },
    spaceless: function spaceless(value) {
      return value.replace(/>\s+</g, '><').trim();
    }
  };

  Twig.filter = function (filter, value, params) {
    var state = this;

    if (!Twig.filters[filter]) {
      throw new Twig.Error('Unable to find filter ' + filter);
    }

    return Twig.filters[filter].call(state, value, params);
  };

  Twig.filter.extend = function (filter, definition) {
    Twig.filters[filter] = definition;
  };

  return Twig;
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(0);

var _typeof2 = _interopRequireDefault(__webpack_require__(1));

// ## twig.functions.js
//
// This file handles parsing filters.
module.exports = function (Twig) {
  /**
   * @constant
   * @type {string}
   */
  var TEMPLATE_NOT_FOUND_MESSAGE = 'Template "{name}" is not defined.';
  Twig.functions = {
    //  Attribute, block, constant, date, dump, parent, random,.
    // Range function from http://phpjs.org/functions/range:499
    // Used under an MIT License
    range: function range(low, high, step) {
      // http://kevin.vanzonneveld.net
      // +   original by: Waldo Malqui Silva
      // *     example 1: range ( 0, 12 );
      // *     returns 1: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
      // *     example 2: range( 0, 100, 10 );
      // *     returns 2: [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
      // *     example 3: range( 'a', 'i' );
      // *     returns 3: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i']
      // *     example 4: range( 'c', 'a' );
      // *     returns 4: ['c', 'b', 'a']
      var matrix = [];
      var inival;
      var endval;
      var walker = step || 1;
      var chars = false;

      if (!isNaN(low) && !isNaN(high)) {
        inival = parseInt(low, 10);
        endval = parseInt(high, 10);
      } else if (isNaN(low) && isNaN(high)) {
        chars = true;
        inival = low.charCodeAt(0);
        endval = high.charCodeAt(0);
      } else {
        inival = isNaN(low) ? 0 : low;
        endval = isNaN(high) ? 0 : high;
      }

      var plus = !(inival > endval);

      if (plus) {
        while (inival <= endval) {
          matrix.push(chars ? String.fromCharCode(inival) : inival);
          inival += walker;
        }
      } else {
        while (inival >= endval) {
          matrix.push(chars ? String.fromCharCode(inival) : inival);
          inival -= walker;
        }
      }

      return matrix;
    },
    cycle: function cycle(arr, i) {
      var pos = i % arr.length;
      return arr[pos];
    },
    dump: function dump() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Don't pass arguments to `Array.slice`, that is a performance killer
      var argsCopy = [].concat(args);
      var state = this;
      var EOL = '\n';
      var indentChar = '  ';
      var indentTimes = 0;
      var out = '';

      var indent = function indent(times) {
        var ind = '';

        while (times > 0) {
          times--;
          ind += indentChar;
        }

        return ind;
      };

      var displayVar = function displayVar(variable) {
        out += indent(indentTimes);

        if ((0, _typeof2["default"])(variable) === 'object') {
          dumpVar(variable);
        } else if (typeof variable === 'function') {
          out += 'function()' + EOL;
        } else if (typeof variable === 'string') {
          out += 'string(' + variable.length + ') "' + variable + '"' + EOL;
        } else if (typeof variable === 'number') {
          out += 'number(' + variable + ')' + EOL;
        } else if (typeof variable === 'boolean') {
          out += 'bool(' + variable + ')' + EOL;
        }
      };

      var dumpVar = function dumpVar(variable) {
        var i;

        if (variable === null) {
          out += 'NULL' + EOL;
        } else if (variable === undefined) {
          out += 'undefined' + EOL;
        } else if ((0, _typeof2["default"])(variable) === 'object') {
          out += indent(indentTimes) + (0, _typeof2["default"])(variable);
          indentTimes++;

          out += '(' + function (obj) {
            var size = 0;
            var key;

            for (key in obj) {
              if (Object.hasOwnProperty.call(obj, key)) {
                size++;
              }
            }

            return size;
          }(variable) + ') {' + EOL;

          for (i in variable) {
            if (Object.hasOwnProperty.call(variable, i)) {
              out += indent(indentTimes) + '[' + i + ']=> ' + EOL;
              displayVar(variable[i]);
            }
          }

          indentTimes--;
          out += indent(indentTimes) + '}' + EOL;
        } else {
          displayVar(variable);
        }
      }; // Handle no argument case by dumping the entire render context


      if (argsCopy.length === 0) {
        argsCopy.push(state.context);
      }

      argsCopy.forEach(function (variable) {
        dumpVar(variable);
      });
      return out;
    },
    date: function date(_date) {
      var dateObj;

      if (_date === undefined || _date === null || _date === '') {
        dateObj = new Date();
      } else if (Twig.lib.is('Date', _date)) {
        dateObj = _date;
      } else if (Twig.lib.is('String', _date)) {
        if (_date.match(/^\d+$/)) {
          dateObj = new Date(_date * 1000);
        } else {
          dateObj = new Date(Twig.lib.strtotime(_date) * 1000);
        }
      } else if (Twig.lib.is('Number', _date)) {
        // Timestamp
        dateObj = new Date(_date * 1000);
      } else {
        throw new Twig.Error('Unable to parse date ' + _date);
      }

      return dateObj;
    },
    block: function block(blockName) {
      var state = this;
      var block = state.getBlock(blockName);

      if (block !== undefined) {
        return block.render(state, state.context);
      }
    },
    parent: function parent() {
      var state = this;
      return state.getBlock(state.getNestingStackToken(Twig.logic.type.block).blockName, true).render(state, state.context);
    },
    attribute: function attribute(object, method, params) {
      if (Twig.lib.is('Object', object)) {
        if (Object.hasOwnProperty.call(object, method)) {
          if (typeof object[method] === 'function') {
            return object[method].apply(undefined, params);
          }

          return object[method];
        }
      } // Array will return element 0-index


      return object ? object[method] || undefined : undefined;
    },
    max: function max(values) {
      if (Twig.lib.is('Object', values)) {
        delete values._keys;
        return Twig.lib.max(values);
      }

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return Reflect.apply(Twig.lib.max, null, [values].concat(args));
    },
    min: function min(values) {
      if (Twig.lib.is('Object', values)) {
        delete values._keys;
        return Twig.lib.min(values);
      }

      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      return Reflect.apply(Twig.lib.min, null, [values].concat(args));
    },

    /* eslint-disable-next-line camelcase */
    template_from_string: function template_from_string(template) {
      var state = this;

      if (template === undefined) {
        template = '';
      }

      return Twig.Templates.parsers.twig({
        options: state.template.options,
        data: template
      });
    },
    random: function random(value) {
      var LIMIT_INT31 = 0x80000000;

      function getRandomNumber(n) {
        var random = Math.floor(Math.random() * LIMIT_INT31);
        var min = Math.min.call(null, 0, n);
        var max = Math.max.call(null, 0, n);
        return min + Math.floor((max - min + 1) * random / LIMIT_INT31);
      }

      if (Twig.lib.is('Number', value)) {
        return getRandomNumber(value);
      }

      if (Twig.lib.is('String', value)) {
        return value.charAt(getRandomNumber(value.length - 1));
      }

      if (Twig.lib.is('Array', value)) {
        return value[getRandomNumber(value.length - 1)];
      }

      if (Twig.lib.is('Object', value)) {
        var keys = Object.keys(value);
        return value[keys[getRandomNumber(keys.length - 1)]];
      }

      return getRandomNumber(LIMIT_INT31 - 1);
    },

    /**
     * Returns the content of a template without rendering it
     * @param {string} name
     * @param {boolean} [ignoreMissing=false]
     * @returns {string}
     */
    source: function source(name, ignoreMissing) {
      var templateSource;
      var templateFound = false;
      var isNodeEnvironment =   true && typeof module.exports !== 'undefined' && typeof window === 'undefined';
      var loader;
      var path = name; // If we are running in a node.js environment, set the loader to 'fs'.

      if (isNodeEnvironment) {
        loader = 'fs';
      } else {
        loader = 'ajax';
      } // Build the params object


      var params = {
        id: name,
        path: path,
        method: loader,
        parser: 'source',
        async: false,
        fetchTemplateSource: true
      }; // Default ignoreMissing to false

      if (typeof ignoreMissing === 'undefined') {
        ignoreMissing = false;
      } // Try to load the remote template
      //
      // on exception, log it


      try {
        templateSource = Twig.Templates.loadRemote(name, params); // If the template is undefined or null, set the template to an empty string and do NOT flip the
        // boolean indicating we found the template
        //
        // else, all is good! flip the boolean indicating we found the template

        if (typeof templateSource === 'undefined' || templateSource === null) {
          templateSource = '';
        } else {
          templateFound = true;
        }
      } catch (error) {
        Twig.log.debug('Twig.functions.source: ', 'Problem loading template  ', error);
      } // If the template was NOT found AND we are not ignoring missing templates, return the same message
      // that is returned by the PHP implementation of the twig source() function
      //
      // else, return the template source


      if (!templateFound && !ignoreMissing) {
        return TEMPLATE_NOT_FOUND_MESSAGE.replace('{name}', name);
      }

      return templateSource;
    }
  };

  Twig._function = function (_function, value, params) {
    if (!Twig.functions[_function]) {
      throw new Twig.Error('Unable to find function ' + _function);
    }

    return Twig.functions[_function](value, params);
  };

  Twig._function.extend = function (_function, definition) {
    Twig.functions[_function] = definition;
  };

  return Twig;
};

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// ## twig.lib.js
//
// This file contains 3rd party libraries used within twig.
//
// Copies of the licenses for the code included here can be found in the
// LICENSES.md file.
//
module.exports = function (Twig) {
  // Namespace for libraries
  Twig.lib = {};
  Twig.lib.sprintf = __webpack_require__(3);
  Twig.lib.vsprintf = __webpack_require__(18);
  Twig.lib.round = __webpack_require__(19);
  Twig.lib.max = __webpack_require__(20);
  Twig.lib.min = __webpack_require__(21);
  Twig.lib.stripTags = __webpack_require__(22);
  Twig.lib.strtotime = __webpack_require__(24);
  Twig.lib.date = __webpack_require__(25);
  Twig.lib.boolval = __webpack_require__(26);

  Twig.lib.is = function (type, obj) {
    if (typeof obj === 'undefined' || obj === null) {
      return false;
    }

    switch (type) {
      case 'Array':
        return Array.isArray(obj);

      case 'Date':
        return obj instanceof Date;

      case 'String':
        return typeof obj === 'string' || obj instanceof String;

      case 'Number':
        return typeof obj === 'number' || obj instanceof Number;

      case 'Function':
        return typeof obj === 'function';

      case 'Object':
        return obj instanceof Object;

      default:
        return false;
    }
  };

  Twig.lib.replaceAll = function (string, search, replace) {
    // Escape possible regular expression syntax
    var searchEscaped = search.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    return string.replace(new RegExp(searchEscaped, 'g'), replace);
  }; // Chunk an array (arr) into arrays of (size) items, returns an array of arrays, or an empty array on invalid input


  Twig.lib.chunkArray = function (arr, size) {
    var returnVal = [];
    var x = 0;
    var len = arr.length;

    if (size < 1 || !Array.isArray(arr)) {
      return [];
    }

    while (x < len) {
      returnVal.push(arr.slice(x, x += size));
    }

    return returnVal;
  };

  return Twig;
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function vsprintf(format, args) {
  //  discuss at: http://locutus.io/php/vsprintf/
  // original by: ejsanders
  //   example 1: vsprintf('%04d-%02d-%02d', [1988, 8, 1])
  //   returns 1: '1988-08-01'

  var sprintf = __webpack_require__(3);

  return sprintf.apply(this, [format].concat(args));
};
//# sourceMappingURL=vsprintf.js.map

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function round(value, precision, mode) {
  //  discuss at: http://locutus.io/php/round/
  // original by: Philip Peterson
  //  revised by: Onno Marsman (https://twitter.com/onnomarsman)
  //  revised by: T.Wild
  //  revised by: Rafał Kukawski (http://blog.kukawski.pl)
  //    input by: Greenseed
  //    input by: meo
  //    input by: William
  //    input by: Josep Sanz (http://www.ws3.es/)
  // bugfixed by: Brett Zamir (http://brett-zamir.me)
  //      note 1: Great work. Ideas for improvement:
  //      note 1: - code more compliant with developer guidelines
  //      note 1: - for implementing PHP constant arguments look at
  //      note 1: the pathinfo() function, it offers the greatest
  //      note 1: flexibility & compatibility possible
  //   example 1: round(1241757, -3)
  //   returns 1: 1242000
  //   example 2: round(3.6)
  //   returns 2: 4
  //   example 3: round(2.835, 2)
  //   returns 3: 2.84
  //   example 4: round(1.1749999999999, 2)
  //   returns 4: 1.17
  //   example 5: round(58551.799999999996, 2)
  //   returns 5: 58551.8

  var m, f, isHalf, sgn; // helper variables
  // making sure precision is integer
  precision |= 0;
  m = Math.pow(10, precision);
  value *= m;
  // sign of the number
  sgn = value > 0 | -(value < 0);
  isHalf = value % 1 === 0.5 * sgn;
  f = Math.floor(value);

  if (isHalf) {
    switch (mode) {
      case 'PHP_ROUND_HALF_DOWN':
        // rounds .5 toward zero
        value = f + (sgn < 0);
        break;
      case 'PHP_ROUND_HALF_EVEN':
        // rouds .5 towards the next even integer
        value = f + f % 2 * sgn;
        break;
      case 'PHP_ROUND_HALF_ODD':
        // rounds .5 towards the next odd integer
        value = f + !(f % 2);
        break;
      default:
        // rounds .5 away from zero
        value = f + (sgn > 0);
    }
  }

  return (isHalf ? value : Math.round(value)) / m;
};
//# sourceMappingURL=round.js.map

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = function max() {
  //  discuss at: http://locutus.io/php/max/
  // original by: Onno Marsman (https://twitter.com/onnomarsman)
  //  revised by: Onno Marsman (https://twitter.com/onnomarsman)
  // improved by: Jack
  //      note 1: Long code cause we're aiming for maximum PHP compatibility
  //   example 1: max(1, 3, 5, 6, 7)
  //   returns 1: 7
  //   example 2: max([2, 4, 5])
  //   returns 2: 5
  //   example 3: max(0, 'hello')
  //   returns 3: 0
  //   example 4: max('hello', 0)
  //   returns 4: 'hello'
  //   example 5: max(-1, 'hello')
  //   returns 5: 'hello'
  //   example 6: max([2, 4, 8], [2, 5, 7])
  //   returns 6: [2, 5, 7]

  var ar;
  var retVal;
  var i = 0;
  var n = 0;
  var argv = arguments;
  var argc = argv.length;
  var _obj2Array = function _obj2Array(obj) {
    if (Object.prototype.toString.call(obj) === '[object Array]') {
      return obj;
    } else {
      var ar = [];
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          ar.push(obj[i]);
        }
      }
      return ar;
    }
  };
  var _compare = function _compare(current, next) {
    var i = 0;
    var n = 0;
    var tmp = 0;
    var nl = 0;
    var cl = 0;

    if (current === next) {
      return 0;
    } else if ((typeof current === 'undefined' ? 'undefined' : _typeof(current)) === 'object') {
      if ((typeof next === 'undefined' ? 'undefined' : _typeof(next)) === 'object') {
        current = _obj2Array(current);
        next = _obj2Array(next);
        cl = current.length;
        nl = next.length;
        if (nl > cl) {
          return 1;
        } else if (nl < cl) {
          return -1;
        }
        for (i = 0, n = cl; i < n; ++i) {
          tmp = _compare(current[i], next[i]);
          if (tmp === 1) {
            return 1;
          } else if (tmp === -1) {
            return -1;
          }
        }
        return 0;
      }
      return -1;
    } else if ((typeof next === 'undefined' ? 'undefined' : _typeof(next)) === 'object') {
      return 1;
    } else if (isNaN(next) && !isNaN(current)) {
      if (current === 0) {
        return 0;
      }
      return current < 0 ? 1 : -1;
    } else if (isNaN(current) && !isNaN(next)) {
      if (next === 0) {
        return 0;
      }
      return next > 0 ? 1 : -1;
    }

    if (next === current) {
      return 0;
    }

    return next > current ? 1 : -1;
  };

  if (argc === 0) {
    throw new Error('At least one value should be passed to max()');
  } else if (argc === 1) {
    if (_typeof(argv[0]) === 'object') {
      ar = _obj2Array(argv[0]);
    } else {
      throw new Error('Wrong parameter count for max()');
    }
    if (ar.length === 0) {
      throw new Error('Array must contain at least one element for max()');
    }
  } else {
    ar = argv;
  }

  retVal = ar[0];
  for (i = 1, n = ar.length; i < n; ++i) {
    if (_compare(retVal, ar[i]) === 1) {
      retVal = ar[i];
    }
  }

  return retVal;
};
//# sourceMappingURL=max.js.map

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = function min() {
  //  discuss at: http://locutus.io/php/min/
  // original by: Onno Marsman (https://twitter.com/onnomarsman)
  //  revised by: Onno Marsman (https://twitter.com/onnomarsman)
  // improved by: Jack
  //      note 1: Long code cause we're aiming for maximum PHP compatibility
  //   example 1: min(1, 3, 5, 6, 7)
  //   returns 1: 1
  //   example 2: min([2, 4, 5])
  //   returns 2: 2
  //   example 3: min(0, 'hello')
  //   returns 3: 0
  //   example 4: min('hello', 0)
  //   returns 4: 'hello'
  //   example 5: min(-1, 'hello')
  //   returns 5: -1
  //   example 6: min([2, 4, 8], [2, 5, 7])
  //   returns 6: [2, 4, 8]

  var ar;
  var retVal;
  var i = 0;
  var n = 0;
  var argv = arguments;
  var argc = argv.length;
  var _obj2Array = function _obj2Array(obj) {
    if (Object.prototype.toString.call(obj) === '[object Array]') {
      return obj;
    }
    var ar = [];
    for (var i in obj) {
      if (obj.hasOwnProperty(i)) {
        ar.push(obj[i]);
      }
    }
    return ar;
  };

  var _compare = function _compare(current, next) {
    var i = 0;
    var n = 0;
    var tmp = 0;
    var nl = 0;
    var cl = 0;

    if (current === next) {
      return 0;
    } else if ((typeof current === 'undefined' ? 'undefined' : _typeof(current)) === 'object') {
      if ((typeof next === 'undefined' ? 'undefined' : _typeof(next)) === 'object') {
        current = _obj2Array(current);
        next = _obj2Array(next);
        cl = current.length;
        nl = next.length;
        if (nl > cl) {
          return 1;
        } else if (nl < cl) {
          return -1;
        }
        for (i = 0, n = cl; i < n; ++i) {
          tmp = _compare(current[i], next[i]);
          if (tmp === 1) {
            return 1;
          } else if (tmp === -1) {
            return -1;
          }
        }
        return 0;
      }
      return -1;
    } else if ((typeof next === 'undefined' ? 'undefined' : _typeof(next)) === 'object') {
      return 1;
    } else if (isNaN(next) && !isNaN(current)) {
      if (current === 0) {
        return 0;
      }
      return current < 0 ? 1 : -1;
    } else if (isNaN(current) && !isNaN(next)) {
      if (next === 0) {
        return 0;
      }
      return next > 0 ? 1 : -1;
    }

    if (next === current) {
      return 0;
    }

    return next > current ? 1 : -1;
  };

  if (argc === 0) {
    throw new Error('At least one value should be passed to min()');
  } else if (argc === 1) {
    if (_typeof(argv[0]) === 'object') {
      ar = _obj2Array(argv[0]);
    } else {
      throw new Error('Wrong parameter count for min()');
    }

    if (ar.length === 0) {
      throw new Error('Array must contain at least one element for min()');
    }
  } else {
    ar = argv;
  }

  retVal = ar[0];

  for (i = 1, n = ar.length; i < n; ++i) {
    if (_compare(retVal, ar[i]) === -1) {
      retVal = ar[i];
    }
  }

  return retVal;
};
//# sourceMappingURL=min.js.map

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function strip_tags(input, allowed) {
  // eslint-disable-line camelcase
  //  discuss at: http://locutus.io/php/strip_tags/
  // original by: Kevin van Zonneveld (http://kvz.io)
  // improved by: Luke Godfrey
  // improved by: Kevin van Zonneveld (http://kvz.io)
  //    input by: Pul
  //    input by: Alex
  //    input by: Marc Palau
  //    input by: Brett Zamir (http://brett-zamir.me)
  //    input by: Bobby Drake
  //    input by: Evertjan Garretsen
  // bugfixed by: Kevin van Zonneveld (http://kvz.io)
  // bugfixed by: Onno Marsman (https://twitter.com/onnomarsman)
  // bugfixed by: Kevin van Zonneveld (http://kvz.io)
  // bugfixed by: Kevin van Zonneveld (http://kvz.io)
  // bugfixed by: Eric Nagel
  // bugfixed by: Kevin van Zonneveld (http://kvz.io)
  // bugfixed by: Tomasz Wesolowski
  // bugfixed by: Tymon Sturgeon (https://scryptonite.com)
  // bugfixed by: Tim de Koning (https://www.kingsquare.nl)
  //  revised by: Rafał Kukawski (http://blog.kukawski.pl)
  //   example 1: strip_tags('<p>Kevin</p> <br /><b>van</b> <i>Zonneveld</i>', '<i><b>')
  //   returns 1: 'Kevin <b>van</b> <i>Zonneveld</i>'
  //   example 2: strip_tags('<p>Kevin <img src="someimage.png" onmouseover="someFunction()">van <i>Zonneveld</i></p>', '<p>')
  //   returns 2: '<p>Kevin van Zonneveld</p>'
  //   example 3: strip_tags("<a href='http://kvz.io'>Kevin van Zonneveld</a>", "<a>")
  //   returns 3: "<a href='http://kvz.io'>Kevin van Zonneveld</a>"
  //   example 4: strip_tags('1 < 5 5 > 1')
  //   returns 4: '1 < 5 5 > 1'
  //   example 5: strip_tags('1 <br/> 1')
  //   returns 5: '1  1'
  //   example 6: strip_tags('1 <br/> 1', '<br>')
  //   returns 6: '1 <br/> 1'
  //   example 7: strip_tags('1 <br/> 1', '<br><br/>')
  //   returns 7: '1 <br/> 1'
  //   example 8: strip_tags('<i>hello</i> <<foo>script>world<</foo>/script>')
  //   returns 8: 'hello world'
  //   example 9: strip_tags(4)
  //   returns 9: '4'

  var _phpCastString = __webpack_require__(23);

  // making sure the allowed arg is a string containing only tags in lowercase (<a><b><c>)
  allowed = (((allowed || '') + '').toLowerCase().match(/<[a-z][a-z0-9]*>/g) || []).join('');

  var tags = /<\/?([a-z0-9]*)\b[^>]*>?/gi;
  var commentsAndPhpTags = /<!--[\s\S]*?-->|<\?(?:php)?[\s\S]*?\?>/gi;

  var after = _phpCastString(input);
  // removes tha '<' char at the end of the string to replicate PHP's behaviour
  after = after.substring(after.length - 1) === '<' ? after.substring(0, after.length - 1) : after;

  // recursively remove tags to ensure that the returned string doesn't contain forbidden tags after previous passes (e.g. '<<bait/>switch/>')
  while (true) {
    var before = after;
    after = before.replace(commentsAndPhpTags, '').replace(tags, function ($0, $1) {
      return allowed.indexOf('<' + $1.toLowerCase() + '>') > -1 ? $0 : '';
    });

    // return once no more tags are removed
    if (before === after) {
      return after;
    }
  }
};
//# sourceMappingURL=strip_tags.js.map

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

module.exports = function _phpCastString(value) {
  // original by: Rafał Kukawski
  //   example 1: _phpCastString(true)
  //   returns 1: '1'
  //   example 2: _phpCastString(false)
  //   returns 2: ''
  //   example 3: _phpCastString('foo')
  //   returns 3: 'foo'
  //   example 4: _phpCastString(0/0)
  //   returns 4: 'NAN'
  //   example 5: _phpCastString(1/0)
  //   returns 5: 'INF'
  //   example 6: _phpCastString(-1/0)
  //   returns 6: '-INF'
  //   example 7: _phpCastString(null)
  //   returns 7: ''
  //   example 8: _phpCastString(undefined)
  //   returns 8: ''
  //   example 9: _phpCastString([])
  //   returns 9: 'Array'
  //   example 10: _phpCastString({})
  //   returns 10: 'Object'
  //   example 11: _phpCastString(0)
  //   returns 11: '0'
  //   example 12: _phpCastString(1)
  //   returns 12: '1'
  //   example 13: _phpCastString(3.14)
  //   returns 13: '3.14'

  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);

  switch (type) {
    case 'boolean':
      return value ? '1' : '';
    case 'string':
      return value;
    case 'number':
      if (isNaN(value)) {
        return 'NAN';
      }

      if (!isFinite(value)) {
        return (value < 0 ? '-' : '') + 'INF';
      }

      return value + '';
    case 'undefined':
      return '';
    case 'object':
      if (Array.isArray(value)) {
        return 'Array';
      }

      if (value !== null) {
        return 'Object';
      }

      return '';
    case 'function':
    // fall through
    default:
      throw new Error('Unsupported value type');
  }
};
//# sourceMappingURL=_phpCastString.js.map

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var reSpace = '[ \\t]+';
var reSpaceOpt = '[ \\t]*';
var reMeridian = '(?:([ap])\\.?m\\.?([\\t ]|$))';
var reHour24 = '(2[0-4]|[01]?[0-9])';
var reHour24lz = '([01][0-9]|2[0-4])';
var reHour12 = '(0?[1-9]|1[0-2])';
var reMinute = '([0-5]?[0-9])';
var reMinutelz = '([0-5][0-9])';
var reSecond = '(60|[0-5]?[0-9])';
var reSecondlz = '(60|[0-5][0-9])';
var reFrac = '(?:\\.([0-9]+))';

var reDayfull = 'sunday|monday|tuesday|wednesday|thursday|friday|saturday';
var reDayabbr = 'sun|mon|tue|wed|thu|fri|sat';
var reDaytext = reDayfull + '|' + reDayabbr + '|weekdays?';

var reReltextnumber = 'first|second|third|fourth|fifth|sixth|seventh|eighth?|ninth|tenth|eleventh|twelfth';
var reReltexttext = 'next|last|previous|this';
var reReltextunit = '(?:second|sec|minute|min|hour|day|fortnight|forthnight|month|year)s?|weeks|' + reDaytext;

var reYear = '([0-9]{1,4})';
var reYear2 = '([0-9]{2})';
var reYear4 = '([0-9]{4})';
var reYear4withSign = '([+-]?[0-9]{4})';
var reMonth = '(1[0-2]|0?[0-9])';
var reMonthlz = '(0[0-9]|1[0-2])';
var reDay = '(?:(3[01]|[0-2]?[0-9])(?:st|nd|rd|th)?)';
var reDaylz = '(0[0-9]|[1-2][0-9]|3[01])';

var reMonthFull = 'january|february|march|april|may|june|july|august|september|october|november|december';
var reMonthAbbr = 'jan|feb|mar|apr|may|jun|jul|aug|sept?|oct|nov|dec';
var reMonthroman = 'i[vx]|vi{0,3}|xi{0,2}|i{1,3}';
var reMonthText = '(' + reMonthFull + '|' + reMonthAbbr + '|' + reMonthroman + ')';

var reTzCorrection = '((?:GMT)?([+-])' + reHour24 + ':?' + reMinute + '?)';
var reDayOfYear = '(00[1-9]|0[1-9][0-9]|[12][0-9][0-9]|3[0-5][0-9]|36[0-6])';
var reWeekOfYear = '(0[1-9]|[1-4][0-9]|5[0-3])';

function processMeridian(hour, meridian) {
  meridian = meridian && meridian.toLowerCase();

  switch (meridian) {
    case 'a':
      hour += hour === 12 ? -12 : 0;
      break;
    case 'p':
      hour += hour !== 12 ? 12 : 0;
      break;
  }

  return hour;
}

function processYear(yearStr) {
  var year = +yearStr;

  if (yearStr.length < 4 && year < 100) {
    year += year < 70 ? 2000 : 1900;
  }

  return year;
}

function lookupMonth(monthStr) {
  return {
    jan: 0,
    january: 0,
    i: 0,
    feb: 1,
    february: 1,
    ii: 1,
    mar: 2,
    march: 2,
    iii: 2,
    apr: 3,
    april: 3,
    iv: 3,
    may: 4,
    v: 4,
    jun: 5,
    june: 5,
    vi: 5,
    jul: 6,
    july: 6,
    vii: 6,
    aug: 7,
    august: 7,
    viii: 7,
    sep: 8,
    sept: 8,
    september: 8,
    ix: 8,
    oct: 9,
    october: 9,
    x: 9,
    nov: 10,
    november: 10,
    xi: 10,
    dec: 11,
    december: 11,
    xii: 11
  }[monthStr.toLowerCase()];
}

function lookupWeekday(dayStr) {
  var desiredSundayNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  var dayNumbers = {
    mon: 1,
    monday: 1,
    tue: 2,
    tuesday: 2,
    wed: 3,
    wednesday: 3,
    thu: 4,
    thursday: 4,
    fri: 5,
    friday: 5,
    sat: 6,
    saturday: 6,
    sun: 0,
    sunday: 0
  };

  return dayNumbers[dayStr.toLowerCase()] || desiredSundayNumber;
}

function lookupRelative(relText) {
  var relativeNumbers = {
    last: -1,
    previous: -1,
    this: 0,
    first: 1,
    next: 1,
    second: 2,
    third: 3,
    fourth: 4,
    fifth: 5,
    sixth: 6,
    seventh: 7,
    eight: 8,
    eighth: 8,
    ninth: 9,
    tenth: 10,
    eleventh: 11,
    twelfth: 12
  };

  var relativeBehavior = {
    this: 1
  };

  var relTextLower = relText.toLowerCase();

  return {
    amount: relativeNumbers[relTextLower],
    behavior: relativeBehavior[relTextLower] || 0
  };
}

function processTzCorrection(tzOffset, oldValue) {
  var reTzCorrectionLoose = /(?:GMT)?([+-])(\d+)(:?)(\d{0,2})/i;
  tzOffset = tzOffset && tzOffset.match(reTzCorrectionLoose);

  if (!tzOffset) {
    return oldValue;
  }

  var sign = tzOffset[1] === '-' ? 1 : -1;
  var hours = +tzOffset[2];
  var minutes = +tzOffset[4];

  if (!tzOffset[4] && !tzOffset[3]) {
    minutes = Math.floor(hours % 100);
    hours = Math.floor(hours / 100);
  }

  return sign * (hours * 60 + minutes);
}

var formats = {
  yesterday: {
    regex: /^yesterday/i,
    name: 'yesterday',
    callback: function callback() {
      this.rd -= 1;
      return this.resetTime();
    }
  },

  now: {
    regex: /^now/i,
    name: 'now'
    // do nothing
  },

  noon: {
    regex: /^noon/i,
    name: 'noon',
    callback: function callback() {
      return this.resetTime() && this.time(12, 0, 0, 0);
    }
  },

  midnightOrToday: {
    regex: /^(midnight|today)/i,
    name: 'midnight | today',
    callback: function callback() {
      return this.resetTime();
    }
  },

  tomorrow: {
    regex: /^tomorrow/i,
    name: 'tomorrow',
    callback: function callback() {
      this.rd += 1;
      return this.resetTime();
    }
  },

  timestamp: {
    regex: /^@(-?\d+)/i,
    name: 'timestamp',
    callback: function callback(match, timestamp) {
      this.rs += +timestamp;
      this.y = 1970;
      this.m = 0;
      this.d = 1;
      this.dates = 0;

      return this.resetTime() && this.zone(0);
    }
  },

  firstOrLastDay: {
    regex: /^(first|last) day of/i,
    name: 'firstdayof | lastdayof',
    callback: function callback(match, day) {
      if (day.toLowerCase() === 'first') {
        this.firstOrLastDayOfMonth = 1;
      } else {
        this.firstOrLastDayOfMonth = -1;
      }
    }
  },

  backOrFrontOf: {
    regex: RegExp('^(back|front) of ' + reHour24 + reSpaceOpt + reMeridian + '?', 'i'),
    name: 'backof | frontof',
    callback: function callback(match, side, hours, meridian) {
      var back = side.toLowerCase() === 'back';
      var hour = +hours;
      var minute = 15;

      if (!back) {
        hour -= 1;
        minute = 45;
      }

      hour = processMeridian(hour, meridian);

      return this.resetTime() && this.time(hour, minute, 0, 0);
    }
  },

  weekdayOf: {
    regex: RegExp('^(' + reReltextnumber + '|' + reReltexttext + ')' + reSpace + '(' + reDayfull + '|' + reDayabbr + ')' + reSpace + 'of', 'i'),
    name: 'weekdayof'
    // todo
  },

  mssqltime: {
    regex: RegExp('^' + reHour12 + ':' + reMinutelz + ':' + reSecondlz + '[:.]([0-9]+)' + reMeridian, 'i'),
    name: 'mssqltime',
    callback: function callback(match, hour, minute, second, frac, meridian) {
      return this.time(processMeridian(+hour, meridian), +minute, +second, +frac.substr(0, 3));
    }
  },

  timeLong12: {
    regex: RegExp('^' + reHour12 + '[:.]' + reMinute + '[:.]' + reSecondlz + reSpaceOpt + reMeridian, 'i'),
    name: 'timelong12',
    callback: function callback(match, hour, minute, second, meridian) {
      return this.time(processMeridian(+hour, meridian), +minute, +second, 0);
    }
  },

  timeShort12: {
    regex: RegExp('^' + reHour12 + '[:.]' + reMinutelz + reSpaceOpt + reMeridian, 'i'),
    name: 'timeshort12',
    callback: function callback(match, hour, minute, meridian) {
      return this.time(processMeridian(+hour, meridian), +minute, 0, 0);
    }
  },

  timeTiny12: {
    regex: RegExp('^' + reHour12 + reSpaceOpt + reMeridian, 'i'),
    name: 'timetiny12',
    callback: function callback(match, hour, meridian) {
      return this.time(processMeridian(+hour, meridian), 0, 0, 0);
    }
  },

  soap: {
    regex: RegExp('^' + reYear4 + '-' + reMonthlz + '-' + reDaylz + 'T' + reHour24lz + ':' + reMinutelz + ':' + reSecondlz + reFrac + reTzCorrection + '?', 'i'),
    name: 'soap',
    callback: function callback(match, year, month, day, hour, minute, second, frac, tzCorrection) {
      return this.ymd(+year, month - 1, +day) && this.time(+hour, +minute, +second, +frac.substr(0, 3)) && this.zone(processTzCorrection(tzCorrection));
    }
  },

  wddx: {
    regex: RegExp('^' + reYear4 + '-' + reMonth + '-' + reDay + 'T' + reHour24 + ':' + reMinute + ':' + reSecond),
    name: 'wddx',
    callback: function callback(match, year, month, day, hour, minute, second) {
      return this.ymd(+year, month - 1, +day) && this.time(+hour, +minute, +second, 0);
    }
  },

  exif: {
    regex: RegExp('^' + reYear4 + ':' + reMonthlz + ':' + reDaylz + ' ' + reHour24lz + ':' + reMinutelz + ':' + reSecondlz, 'i'),
    name: 'exif',
    callback: function callback(match, year, month, day, hour, minute, second) {
      return this.ymd(+year, month - 1, +day) && this.time(+hour, +minute, +second, 0);
    }
  },

  xmlRpc: {
    regex: RegExp('^' + reYear4 + reMonthlz + reDaylz + 'T' + reHour24 + ':' + reMinutelz + ':' + reSecondlz),
    name: 'xmlrpc',
    callback: function callback(match, year, month, day, hour, minute, second) {
      return this.ymd(+year, month - 1, +day) && this.time(+hour, +minute, +second, 0);
    }
  },

  xmlRpcNoColon: {
    regex: RegExp('^' + reYear4 + reMonthlz + reDaylz + '[Tt]' + reHour24 + reMinutelz + reSecondlz),
    name: 'xmlrpcnocolon',
    callback: function callback(match, year, month, day, hour, minute, second) {
      return this.ymd(+year, month - 1, +day) && this.time(+hour, +minute, +second, 0);
    }
  },

  clf: {
    regex: RegExp('^' + reDay + '/(' + reMonthAbbr + ')/' + reYear4 + ':' + reHour24lz + ':' + reMinutelz + ':' + reSecondlz + reSpace + reTzCorrection, 'i'),
    name: 'clf',
    callback: function callback(match, day, month, year, hour, minute, second, tzCorrection) {
      return this.ymd(+year, lookupMonth(month), +day) && this.time(+hour, +minute, +second, 0) && this.zone(processTzCorrection(tzCorrection));
    }
  },

  iso8601long: {
    regex: RegExp('^t?' + reHour24 + '[:.]' + reMinute + '[:.]' + reSecond + reFrac, 'i'),
    name: 'iso8601long',
    callback: function callback(match, hour, minute, second, frac) {
      return this.time(+hour, +minute, +second, +frac.substr(0, 3));
    }
  },

  dateTextual: {
    regex: RegExp('^' + reMonthText + '[ .\\t-]*' + reDay + '[,.stndrh\\t ]+' + reYear, 'i'),
    name: 'datetextual',
    callback: function callback(match, month, day, year) {
      return this.ymd(processYear(year), lookupMonth(month), +day);
    }
  },

  pointedDate4: {
    regex: RegExp('^' + reDay + '[.\\t-]' + reMonth + '[.-]' + reYear4),
    name: 'pointeddate4',
    callback: function callback(match, day, month, year) {
      return this.ymd(+year, month - 1, +day);
    }
  },

  pointedDate2: {
    regex: RegExp('^' + reDay + '[.\\t]' + reMonth + '\\.' + reYear2),
    name: 'pointeddate2',
    callback: function callback(match, day, month, year) {
      return this.ymd(processYear(year), month - 1, +day);
    }
  },

  timeLong24: {
    regex: RegExp('^t?' + reHour24 + '[:.]' + reMinute + '[:.]' + reSecond),
    name: 'timelong24',
    callback: function callback(match, hour, minute, second) {
      return this.time(+hour, +minute, +second, 0);
    }
  },

  dateNoColon: {
    regex: RegExp('^' + reYear4 + reMonthlz + reDaylz),
    name: 'datenocolon',
    callback: function callback(match, year, month, day) {
      return this.ymd(+year, month - 1, +day);
    }
  },

  pgydotd: {
    regex: RegExp('^' + reYear4 + '\\.?' + reDayOfYear),
    name: 'pgydotd',
    callback: function callback(match, year, day) {
      return this.ymd(+year, 0, +day);
    }
  },

  timeShort24: {
    regex: RegExp('^t?' + reHour24 + '[:.]' + reMinute, 'i'),
    name: 'timeshort24',
    callback: function callback(match, hour, minute) {
      return this.time(+hour, +minute, 0, 0);
    }
  },

  iso8601noColon: {
    regex: RegExp('^t?' + reHour24lz + reMinutelz + reSecondlz, 'i'),
    name: 'iso8601nocolon',
    callback: function callback(match, hour, minute, second) {
      return this.time(+hour, +minute, +second, 0);
    }
  },

  iso8601dateSlash: {
    // eventhough the trailing slash is optional in PHP
    // here it's mandatory and inputs without the slash
    // are handled by dateslash
    regex: RegExp('^' + reYear4 + '/' + reMonthlz + '/' + reDaylz + '/'),
    name: 'iso8601dateslash',
    callback: function callback(match, year, month, day) {
      return this.ymd(+year, month - 1, +day);
    }
  },

  dateSlash: {
    regex: RegExp('^' + reYear4 + '/' + reMonth + '/' + reDay),
    name: 'dateslash',
    callback: function callback(match, year, month, day) {
      return this.ymd(+year, month - 1, +day);
    }
  },

  american: {
    regex: RegExp('^' + reMonth + '/' + reDay + '/' + reYear),
    name: 'american',
    callback: function callback(match, month, day, year) {
      return this.ymd(processYear(year), month - 1, +day);
    }
  },

  americanShort: {
    regex: RegExp('^' + reMonth + '/' + reDay),
    name: 'americanshort',
    callback: function callback(match, month, day) {
      return this.ymd(this.y, month - 1, +day);
    }
  },

  gnuDateShortOrIso8601date2: {
    // iso8601date2 is complete subset of gnudateshort
    regex: RegExp('^' + reYear + '-' + reMonth + '-' + reDay),
    name: 'gnudateshort | iso8601date2',
    callback: function callback(match, year, month, day) {
      return this.ymd(processYear(year), month - 1, +day);
    }
  },

  iso8601date4: {
    regex: RegExp('^' + reYear4withSign + '-' + reMonthlz + '-' + reDaylz),
    name: 'iso8601date4',
    callback: function callback(match, year, month, day) {
      return this.ymd(+year, month - 1, +day);
    }
  },

  gnuNoColon: {
    regex: RegExp('^t' + reHour24lz + reMinutelz, 'i'),
    name: 'gnunocolon',
    callback: function callback(match, hour, minute) {
      return this.time(+hour, +minute, 0, this.f);
    }
  },

  gnuDateShorter: {
    regex: RegExp('^' + reYear4 + '-' + reMonth),
    name: 'gnudateshorter',
    callback: function callback(match, year, month) {
      return this.ymd(+year, month - 1, 1);
    }
  },

  pgTextReverse: {
    // note: allowed years are from 32-9999
    // years below 32 should be treated as days in datefull
    regex: RegExp('^' + '(\\d{3,4}|[4-9]\\d|3[2-9])-(' + reMonthAbbr + ')-' + reDaylz, 'i'),
    name: 'pgtextreverse',
    callback: function callback(match, year, month, day) {
      return this.ymd(processYear(year), lookupMonth(month), +day);
    }
  },

  dateFull: {
    regex: RegExp('^' + reDay + '[ \\t.-]*' + reMonthText + '[ \\t.-]*' + reYear, 'i'),
    name: 'datefull',
    callback: function callback(match, day, month, year) {
      return this.ymd(processYear(year), lookupMonth(month), +day);
    }
  },

  dateNoDay: {
    regex: RegExp('^' + reMonthText + '[ .\\t-]*' + reYear4, 'i'),
    name: 'datenoday',
    callback: function callback(match, month, year) {
      return this.ymd(+year, lookupMonth(month), 1);
    }
  },

  dateNoDayRev: {
    regex: RegExp('^' + reYear4 + '[ .\\t-]*' + reMonthText, 'i'),
    name: 'datenodayrev',
    callback: function callback(match, year, month) {
      return this.ymd(+year, lookupMonth(month), 1);
    }
  },

  pgTextShort: {
    regex: RegExp('^(' + reMonthAbbr + ')-' + reDaylz + '-' + reYear, 'i'),
    name: 'pgtextshort',
    callback: function callback(match, month, day, year) {
      return this.ymd(processYear(year), lookupMonth(month), +day);
    }
  },

  dateNoYear: {
    regex: RegExp('^' + reMonthText + '[ .\\t-]*' + reDay + '[,.stndrh\\t ]*', 'i'),
    name: 'datenoyear',
    callback: function callback(match, month, day) {
      return this.ymd(this.y, lookupMonth(month), +day);
    }
  },

  dateNoYearRev: {
    regex: RegExp('^' + reDay + '[ .\\t-]*' + reMonthText, 'i'),
    name: 'datenoyearrev',
    callback: function callback(match, day, month) {
      return this.ymd(this.y, lookupMonth(month), +day);
    }
  },

  isoWeekDay: {
    regex: RegExp('^' + reYear4 + '-?W' + reWeekOfYear + '(?:-?([0-7]))?'),
    name: 'isoweekday | isoweek',
    callback: function callback(match, year, week, day) {
      day = day ? +day : 1;

      if (!this.ymd(+year, 0, 1)) {
        return false;
      }

      // get day of week for Jan 1st
      var dayOfWeek = new Date(this.y, this.m, this.d).getDay();

      // and use the day to figure out the offset for day 1 of week 1
      dayOfWeek = 0 - (dayOfWeek > 4 ? dayOfWeek - 7 : dayOfWeek);

      this.rd += dayOfWeek + (week - 1) * 7 + day;
    }
  },

  relativeText: {
    regex: RegExp('^(' + reReltextnumber + '|' + reReltexttext + ')' + reSpace + '(' + reReltextunit + ')', 'i'),
    name: 'relativetext',
    callback: function callback(match, relValue, relUnit) {
      // todo: implement handling of 'this time-unit'
      // eslint-disable-next-line no-unused-vars
      var _lookupRelative = lookupRelative(relValue),
          amount = _lookupRelative.amount,
          behavior = _lookupRelative.behavior;

      switch (relUnit.toLowerCase()) {
        case 'sec':
        case 'secs':
        case 'second':
        case 'seconds':
          this.rs += amount;
          break;
        case 'min':
        case 'mins':
        case 'minute':
        case 'minutes':
          this.ri += amount;
          break;
        case 'hour':
        case 'hours':
          this.rh += amount;
          break;
        case 'day':
        case 'days':
          this.rd += amount;
          break;
        case 'fortnight':
        case 'fortnights':
        case 'forthnight':
        case 'forthnights':
          this.rd += amount * 14;
          break;
        case 'week':
        case 'weeks':
          this.rd += amount * 7;
          break;
        case 'month':
        case 'months':
          this.rm += amount;
          break;
        case 'year':
        case 'years':
          this.ry += amount;
          break;
        case 'mon':case 'monday':
        case 'tue':case 'tuesday':
        case 'wed':case 'wednesday':
        case 'thu':case 'thursday':
        case 'fri':case 'friday':
        case 'sat':case 'saturday':
        case 'sun':case 'sunday':
          this.resetTime();
          this.weekday = lookupWeekday(relUnit, 7);
          this.weekdayBehavior = 1;
          this.rd += (amount > 0 ? amount - 1 : amount) * 7;
          break;
        case 'weekday':
        case 'weekdays':
          // todo
          break;
      }
    }
  },

  relative: {
    regex: RegExp('^([+-]*)[ \\t]*(\\d+)' + reSpaceOpt + '(' + reReltextunit + '|week)', 'i'),
    name: 'relative',
    callback: function callback(match, signs, relValue, relUnit) {
      var minuses = signs.replace(/[^-]/g, '').length;

      var amount = +relValue * Math.pow(-1, minuses);

      switch (relUnit.toLowerCase()) {
        case 'sec':
        case 'secs':
        case 'second':
        case 'seconds':
          this.rs += amount;
          break;
        case 'min':
        case 'mins':
        case 'minute':
        case 'minutes':
          this.ri += amount;
          break;
        case 'hour':
        case 'hours':
          this.rh += amount;
          break;
        case 'day':
        case 'days':
          this.rd += amount;
          break;
        case 'fortnight':
        case 'fortnights':
        case 'forthnight':
        case 'forthnights':
          this.rd += amount * 14;
          break;
        case 'week':
        case 'weeks':
          this.rd += amount * 7;
          break;
        case 'month':
        case 'months':
          this.rm += amount;
          break;
        case 'year':
        case 'years':
          this.ry += amount;
          break;
        case 'mon':case 'monday':
        case 'tue':case 'tuesday':
        case 'wed':case 'wednesday':
        case 'thu':case 'thursday':
        case 'fri':case 'friday':
        case 'sat':case 'saturday':
        case 'sun':case 'sunday':
          this.resetTime();
          this.weekday = lookupWeekday(relUnit, 7);
          this.weekdayBehavior = 1;
          this.rd += (amount > 0 ? amount - 1 : amount) * 7;
          break;
        case 'weekday':
        case 'weekdays':
          // todo
          break;
      }
    }
  },

  dayText: {
    regex: RegExp('^(' + reDaytext + ')', 'i'),
    name: 'daytext',
    callback: function callback(match, dayText) {
      this.resetTime();
      this.weekday = lookupWeekday(dayText, 0);

      if (this.weekdayBehavior !== 2) {
        this.weekdayBehavior = 1;
      }
    }
  },

  relativeTextWeek: {
    regex: RegExp('^(' + reReltexttext + ')' + reSpace + 'week', 'i'),
    name: 'relativetextweek',
    callback: function callback(match, relText) {
      this.weekdayBehavior = 2;

      switch (relText.toLowerCase()) {
        case 'this':
          this.rd += 0;
          break;
        case 'next':
          this.rd += 7;
          break;
        case 'last':
        case 'previous':
          this.rd -= 7;
          break;
      }

      if (isNaN(this.weekday)) {
        this.weekday = 1;
      }
    }
  },

  monthFullOrMonthAbbr: {
    regex: RegExp('^(' + reMonthFull + '|' + reMonthAbbr + ')', 'i'),
    name: 'monthfull | monthabbr',
    callback: function callback(match, month) {
      return this.ymd(this.y, lookupMonth(month), this.d);
    }
  },

  tzCorrection: {
    regex: RegExp('^' + reTzCorrection, 'i'),
    name: 'tzcorrection',
    callback: function callback(tzCorrection) {
      return this.zone(processTzCorrection(tzCorrection));
    }
  },

  ago: {
    regex: /^ago/i,
    name: 'ago',
    callback: function callback() {
      this.ry = -this.ry;
      this.rm = -this.rm;
      this.rd = -this.rd;
      this.rh = -this.rh;
      this.ri = -this.ri;
      this.rs = -this.rs;
      this.rf = -this.rf;
    }
  },

  gnuNoColon2: {
    // second instance of gnunocolon, without leading 't'
    // it's down here, because it is very generic (4 digits in a row)
    // thus conflicts with many rules above
    // only year4 should come afterwards
    regex: RegExp('^' + reHour24lz + reMinutelz, 'i'),
    name: 'gnunocolon',
    callback: function callback(match, hour, minute) {
      return this.time(+hour, +minute, 0, this.f);
    }
  },

  year4: {
    regex: RegExp('^' + reYear4),
    name: 'year4',
    callback: function callback(match, year) {
      this.y = +year;
      return true;
    }
  },

  whitespace: {
    regex: /^[ .,\t]+/,
    name: 'whitespace'
    // do nothing
  },

  any: {
    regex: /^[\s\S]+/,
    name: 'any',
    callback: function callback() {
      return false;
    }
  }
};

var resultProto = {
  // date
  y: NaN,
  m: NaN,
  d: NaN,
  // time
  h: NaN,
  i: NaN,
  s: NaN,
  f: NaN,

  // relative shifts
  ry: 0,
  rm: 0,
  rd: 0,
  rh: 0,
  ri: 0,
  rs: 0,
  rf: 0,

  // weekday related shifts
  weekday: NaN,
  weekdayBehavior: 0,

  // first or last day of month
  // 0 none, 1 first, -1 last
  firstOrLastDayOfMonth: 0,

  // timezone correction in minutes
  z: NaN,

  // counters
  dates: 0,
  times: 0,
  zones: 0,

  // helper functions
  ymd: function ymd(y, m, d) {
    if (this.dates > 0) {
      return false;
    }

    this.dates++;
    this.y = y;
    this.m = m;
    this.d = d;
    return true;
  },
  time: function time(h, i, s, f) {
    if (this.times > 0) {
      return false;
    }

    this.times++;
    this.h = h;
    this.i = i;
    this.s = s;
    this.f = f;

    return true;
  },
  resetTime: function resetTime() {
    this.h = 0;
    this.i = 0;
    this.s = 0;
    this.f = 0;
    this.times = 0;

    return true;
  },
  zone: function zone(minutes) {
    if (this.zones <= 1) {
      this.zones++;
      this.z = minutes;
      return true;
    }

    return false;
  },
  toDate: function toDate(relativeTo) {
    if (this.dates && !this.times) {
      this.h = this.i = this.s = this.f = 0;
    }

    // fill holes
    if (isNaN(this.y)) {
      this.y = relativeTo.getFullYear();
    }

    if (isNaN(this.m)) {
      this.m = relativeTo.getMonth();
    }

    if (isNaN(this.d)) {
      this.d = relativeTo.getDate();
    }

    if (isNaN(this.h)) {
      this.h = relativeTo.getHours();
    }

    if (isNaN(this.i)) {
      this.i = relativeTo.getMinutes();
    }

    if (isNaN(this.s)) {
      this.s = relativeTo.getSeconds();
    }

    if (isNaN(this.f)) {
      this.f = relativeTo.getMilliseconds();
    }

    // adjust special early
    switch (this.firstOrLastDayOfMonth) {
      case 1:
        this.d = 1;
        break;
      case -1:
        this.d = 0;
        this.m += 1;
        break;
    }

    if (!isNaN(this.weekday)) {
      var date = new Date(relativeTo.getTime());
      date.setFullYear(this.y, this.m, this.d);
      date.setHours(this.h, this.i, this.s, this.f);

      var dow = date.getDay();

      if (this.weekdayBehavior === 2) {
        // To make "this week" work, where the current day of week is a "sunday"
        if (dow === 0 && this.weekday !== 0) {
          this.weekday = -6;
        }

        // To make "sunday this week" work, where the current day of week is not a "sunday"
        if (this.weekday === 0 && dow !== 0) {
          this.weekday = 7;
        }

        this.d -= dow;
        this.d += this.weekday;
      } else {
        var diff = this.weekday - dow;

        // some PHP magic
        if (this.rd < 0 && diff < 0 || this.rd >= 0 && diff <= -this.weekdayBehavior) {
          diff += 7;
        }

        if (this.weekday >= 0) {
          this.d += diff;
        } else {
          this.d -= 7 - (Math.abs(this.weekday) - dow);
        }

        this.weekday = NaN;
      }
    }

    // adjust relative
    this.y += this.ry;
    this.m += this.rm;
    this.d += this.rd;

    this.h += this.rh;
    this.i += this.ri;
    this.s += this.rs;
    this.f += this.rf;

    this.ry = this.rm = this.rd = 0;
    this.rh = this.ri = this.rs = this.rf = 0;

    var result = new Date(relativeTo.getTime());
    // since Date constructor treats years <= 99 as 1900+
    // it can't be used, thus this weird way
    result.setFullYear(this.y, this.m, this.d);
    result.setHours(this.h, this.i, this.s, this.f);

    // note: this is done twice in PHP
    // early when processing special relatives
    // and late
    // todo: check if the logic can be reduced
    // to just one time action
    switch (this.firstOrLastDayOfMonth) {
      case 1:
        result.setDate(1);
        break;
      case -1:
        result.setMonth(result.getMonth() + 1, 0);
        break;
    }

    // adjust timezone
    if (!isNaN(this.z) && result.getTimezoneOffset() !== this.z) {
      result.setUTCFullYear(result.getFullYear(), result.getMonth(), result.getDate());

      result.setUTCHours(result.getHours(), result.getMinutes() + this.z, result.getSeconds(), result.getMilliseconds());
    }

    return result;
  }
};

module.exports = function strtotime(str, now) {
  //       discuss at: http://locutus.io/php/strtotime/
  //      original by: Caio Ariede (http://caioariede.com)
  //      improved by: Kevin van Zonneveld (http://kvz.io)
  //      improved by: Caio Ariede (http://caioariede.com)
  //      improved by: A. Matías Quezada (http://amatiasq.com)
  //      improved by: preuter
  //      improved by: Brett Zamir (http://brett-zamir.me)
  //      improved by: Mirko Faber
  //         input by: David
  //      bugfixed by: Wagner B. Soares
  //      bugfixed by: Artur Tchernychev
  //      bugfixed by: Stephan Bösch-Plepelits (http://github.com/plepe)
  // reimplemented by: Rafał Kukawski
  //           note 1: Examples all have a fixed timestamp to prevent
  //           note 1: tests to fail because of variable time(zones)
  //        example 1: strtotime('+1 day', 1129633200)
  //        returns 1: 1129719600
  //        example 2: strtotime('+1 week 2 days 4 hours 2 seconds', 1129633200)
  //        returns 2: 1130425202
  //        example 3: strtotime('last month', 1129633200)
  //        returns 3: 1127041200
  //        example 4: strtotime('2009-05-04 08:30:00+00')
  //        returns 4: 1241425800
  //        example 5: strtotime('2009-05-04 08:30:00+02:00')
  //        returns 5: 1241418600
  if (now == null) {
    now = Math.floor(Date.now() / 1000);
  }

  // the rule order is very fragile
  // as many formats are similar to others
  // so small change can cause
  // input misinterpretation
  var rules = [formats.yesterday, formats.now, formats.noon, formats.midnightOrToday, formats.tomorrow, formats.timestamp, formats.firstOrLastDay, formats.backOrFrontOf,
  // formats.weekdayOf, // not yet implemented
  formats.mssqltime, formats.timeLong12, formats.timeShort12, formats.timeTiny12, formats.soap, formats.wddx, formats.exif, formats.xmlRpc, formats.xmlRpcNoColon, formats.clf, formats.iso8601long, formats.dateTextual, formats.pointedDate4, formats.pointedDate2, formats.timeLong24, formats.dateNoColon, formats.pgydotd, formats.timeShort24, formats.iso8601noColon,
  // iso8601dateSlash needs to come before dateSlash
  formats.iso8601dateSlash, formats.dateSlash, formats.american, formats.americanShort, formats.gnuDateShortOrIso8601date2, formats.iso8601date4, formats.gnuNoColon, formats.gnuDateShorter, formats.pgTextReverse, formats.dateFull, formats.dateNoDay, formats.dateNoDayRev, formats.pgTextShort, formats.dateNoYear, formats.dateNoYearRev, formats.isoWeekDay, formats.relativeText, formats.relative, formats.dayText, formats.relativeTextWeek, formats.monthFullOrMonthAbbr, formats.tzCorrection, formats.ago, formats.gnuNoColon2, formats.year4,
  // note: the two rules below
  // should always come last
  formats.whitespace, formats.any];

  var result = Object.create(resultProto);

  while (str.length) {
    for (var i = 0, l = rules.length; i < l; i++) {
      var format = rules[i];

      var match = str.match(format.regex);

      if (match) {
        // care only about false results. Ignore other values
        if (format.callback && format.callback.apply(result, match) === false) {
          return false;
        }

        str = str.substr(match[0].length);
        break;
      }
    }
  }

  return Math.floor(result.toDate(new Date(now * 1000)) / 1000);
};
//# sourceMappingURL=strtotime.js.map

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function date(format, timestamp) {
  //  discuss at: http://locutus.io/php/date/
  // original by: Carlos R. L. Rodrigues (http://www.jsfromhell.com)
  // original by: gettimeofday
  //    parts by: Peter-Paul Koch (http://www.quirksmode.org/js/beat.html)
  // improved by: Kevin van Zonneveld (http://kvz.io)
  // improved by: MeEtc (http://yass.meetcweb.com)
  // improved by: Brad Touesnard
  // improved by: Tim Wiel
  // improved by: Bryan Elliott
  // improved by: David Randall
  // improved by: Theriault (https://github.com/Theriault)
  // improved by: Theriault (https://github.com/Theriault)
  // improved by: Brett Zamir (http://brett-zamir.me)
  // improved by: Theriault (https://github.com/Theriault)
  // improved by: Thomas Beaucourt (http://www.webapp.fr)
  // improved by: JT
  // improved by: Theriault (https://github.com/Theriault)
  // improved by: Rafał Kukawski (http://blog.kukawski.pl)
  // improved by: Theriault (https://github.com/Theriault)
  //    input by: Brett Zamir (http://brett-zamir.me)
  //    input by: majak
  //    input by: Alex
  //    input by: Martin
  //    input by: Alex Wilson
  //    input by: Haravikk
  // bugfixed by: Kevin van Zonneveld (http://kvz.io)
  // bugfixed by: majak
  // bugfixed by: Kevin van Zonneveld (http://kvz.io)
  // bugfixed by: Brett Zamir (http://brett-zamir.me)
  // bugfixed by: omid (http://locutus.io/php/380:380#comment_137122)
  // bugfixed by: Chris (http://www.devotis.nl/)
  //      note 1: Uses global: locutus to store the default timezone
  //      note 1: Although the function potentially allows timezone info
  //      note 1: (see notes), it currently does not set
  //      note 1: per a timezone specified by date_default_timezone_set(). Implementers might use
  //      note 1: $locutus.currentTimezoneOffset and
  //      note 1: $locutus.currentTimezoneDST set by that function
  //      note 1: in order to adjust the dates in this function
  //      note 1: (or our other date functions!) accordingly
  //   example 1: date('H:m:s \\m \\i\\s \\m\\o\\n\\t\\h', 1062402400)
  //   returns 1: '07:09:40 m is month'
  //   example 2: date('F j, Y, g:i a', 1062462400)
  //   returns 2: 'September 2, 2003, 12:26 am'
  //   example 3: date('Y W o', 1062462400)
  //   returns 3: '2003 36 2003'
  //   example 4: var $x = date('Y m d', (new Date()).getTime() / 1000)
  //   example 4: $x = $x + ''
  //   example 4: var $result = $x.length // 2009 01 09
  //   returns 4: 10
  //   example 5: date('W', 1104534000)
  //   returns 5: '52'
  //   example 6: date('B t', 1104534000)
  //   returns 6: '999 31'
  //   example 7: date('W U', 1293750000.82); // 2010-12-31
  //   returns 7: '52 1293750000'
  //   example 8: date('W', 1293836400); // 2011-01-01
  //   returns 8: '52'
  //   example 9: date('W Y-m-d', 1293974054); // 2011-01-02
  //   returns 9: '52 2011-01-02'
  //        test: skip-1 skip-2 skip-5

  var jsdate, f;
  // Keep this here (works, but for code commented-out below for file size reasons)
  // var tal= [];
  var txtWords = ['Sun', 'Mon', 'Tues', 'Wednes', 'Thurs', 'Fri', 'Satur', 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  // trailing backslash -> (dropped)
  // a backslash followed by any character (including backslash) -> the character
  // empty string -> empty string
  var formatChr = /\\?(.?)/gi;
  var formatChrCb = function formatChrCb(t, s) {
    return f[t] ? f[t]() : s;
  };
  var _pad = function _pad(n, c) {
    n = String(n);
    while (n.length < c) {
      n = '0' + n;
    }
    return n;
  };
  f = {
    // Day
    d: function d() {
      // Day of month w/leading 0; 01..31
      return _pad(f.j(), 2);
    },
    D: function D() {
      // Shorthand day name; Mon...Sun
      return f.l().slice(0, 3);
    },
    j: function j() {
      // Day of month; 1..31
      return jsdate.getDate();
    },
    l: function l() {
      // Full day name; Monday...Sunday
      return txtWords[f.w()] + 'day';
    },
    N: function N() {
      // ISO-8601 day of week; 1[Mon]..7[Sun]
      return f.w() || 7;
    },
    S: function S() {
      // Ordinal suffix for day of month; st, nd, rd, th
      var j = f.j();
      var i = j % 10;
      if (i <= 3 && parseInt(j % 100 / 10, 10) === 1) {
        i = 0;
      }
      return ['st', 'nd', 'rd'][i - 1] || 'th';
    },
    w: function w() {
      // Day of week; 0[Sun]..6[Sat]
      return jsdate.getDay();
    },
    z: function z() {
      // Day of year; 0..365
      var a = new Date(f.Y(), f.n() - 1, f.j());
      var b = new Date(f.Y(), 0, 1);
      return Math.round((a - b) / 864e5);
    },

    // Week
    W: function W() {
      // ISO-8601 week number
      var a = new Date(f.Y(), f.n() - 1, f.j() - f.N() + 3);
      var b = new Date(a.getFullYear(), 0, 4);
      return _pad(1 + Math.round((a - b) / 864e5 / 7), 2);
    },

    // Month
    F: function F() {
      // Full month name; January...December
      return txtWords[6 + f.n()];
    },
    m: function m() {
      // Month w/leading 0; 01...12
      return _pad(f.n(), 2);
    },
    M: function M() {
      // Shorthand month name; Jan...Dec
      return f.F().slice(0, 3);
    },
    n: function n() {
      // Month; 1...12
      return jsdate.getMonth() + 1;
    },
    t: function t() {
      // Days in month; 28...31
      return new Date(f.Y(), f.n(), 0).getDate();
    },

    // Year
    L: function L() {
      // Is leap year?; 0 or 1
      var j = f.Y();
      return j % 4 === 0 & j % 100 !== 0 | j % 400 === 0;
    },
    o: function o() {
      // ISO-8601 year
      var n = f.n();
      var W = f.W();
      var Y = f.Y();
      return Y + (n === 12 && W < 9 ? 1 : n === 1 && W > 9 ? -1 : 0);
    },
    Y: function Y() {
      // Full year; e.g. 1980...2010
      return jsdate.getFullYear();
    },
    y: function y() {
      // Last two digits of year; 00...99
      return f.Y().toString().slice(-2);
    },

    // Time
    a: function a() {
      // am or pm
      return jsdate.getHours() > 11 ? 'pm' : 'am';
    },
    A: function A() {
      // AM or PM
      return f.a().toUpperCase();
    },
    B: function B() {
      // Swatch Internet time; 000..999
      var H = jsdate.getUTCHours() * 36e2;
      // Hours
      var i = jsdate.getUTCMinutes() * 60;
      // Minutes
      // Seconds
      var s = jsdate.getUTCSeconds();
      return _pad(Math.floor((H + i + s + 36e2) / 86.4) % 1e3, 3);
    },
    g: function g() {
      // 12-Hours; 1..12
      return f.G() % 12 || 12;
    },
    G: function G() {
      // 24-Hours; 0..23
      return jsdate.getHours();
    },
    h: function h() {
      // 12-Hours w/leading 0; 01..12
      return _pad(f.g(), 2);
    },
    H: function H() {
      // 24-Hours w/leading 0; 00..23
      return _pad(f.G(), 2);
    },
    i: function i() {
      // Minutes w/leading 0; 00..59
      return _pad(jsdate.getMinutes(), 2);
    },
    s: function s() {
      // Seconds w/leading 0; 00..59
      return _pad(jsdate.getSeconds(), 2);
    },
    u: function u() {
      // Microseconds; 000000-999000
      return _pad(jsdate.getMilliseconds() * 1000, 6);
    },

    // Timezone
    e: function e() {
      // Timezone identifier; e.g. Atlantic/Azores, ...
      // The following works, but requires inclusion of the very large
      // timezone_abbreviations_list() function.
      /*              return that.date_default_timezone_get();
       */
      var msg = 'Not supported (see source code of date() for timezone on how to add support)';
      throw new Error(msg);
    },
    I: function I() {
      // DST observed?; 0 or 1
      // Compares Jan 1 minus Jan 1 UTC to Jul 1 minus Jul 1 UTC.
      // If they are not equal, then DST is observed.
      var a = new Date(f.Y(), 0);
      // Jan 1
      var c = Date.UTC(f.Y(), 0);
      // Jan 1 UTC
      var b = new Date(f.Y(), 6);
      // Jul 1
      // Jul 1 UTC
      var d = Date.UTC(f.Y(), 6);
      return a - c !== b - d ? 1 : 0;
    },
    O: function O() {
      // Difference to GMT in hour format; e.g. +0200
      var tzo = jsdate.getTimezoneOffset();
      var a = Math.abs(tzo);
      return (tzo > 0 ? '-' : '+') + _pad(Math.floor(a / 60) * 100 + a % 60, 4);
    },
    P: function P() {
      // Difference to GMT w/colon; e.g. +02:00
      var O = f.O();
      return O.substr(0, 3) + ':' + O.substr(3, 2);
    },
    T: function T() {
      // The following works, but requires inclusion of the very
      // large timezone_abbreviations_list() function.
      /*              var abbr, i, os, _default;
      if (!tal.length) {
        tal = that.timezone_abbreviations_list();
      }
      if ($locutus && $locutus.default_timezone) {
        _default = $locutus.default_timezone;
        for (abbr in tal) {
          for (i = 0; i < tal[abbr].length; i++) {
            if (tal[abbr][i].timezone_id === _default) {
              return abbr.toUpperCase();
            }
          }
        }
      }
      for (abbr in tal) {
        for (i = 0; i < tal[abbr].length; i++) {
          os = -jsdate.getTimezoneOffset() * 60;
          if (tal[abbr][i].offset === os) {
            return abbr.toUpperCase();
          }
        }
      }
      */
      return 'UTC';
    },
    Z: function Z() {
      // Timezone offset in seconds (-43200...50400)
      return -jsdate.getTimezoneOffset() * 60;
    },

    // Full Date/Time
    c: function c() {
      // ISO-8601 date.
      return 'Y-m-d\\TH:i:sP'.replace(formatChr, formatChrCb);
    },
    r: function r() {
      // RFC 2822
      return 'D, d M Y H:i:s O'.replace(formatChr, formatChrCb);
    },
    U: function U() {
      // Seconds since UNIX epoch
      return jsdate / 1000 | 0;
    }
  };

  var _date = function _date(format, timestamp) {
    jsdate = timestamp === undefined ? new Date() // Not provided
    : timestamp instanceof Date ? new Date(timestamp) // JS Date()
    : new Date(timestamp * 1000) // UNIX timestamp (auto-convert to int)
    ;
    return format.replace(formatChr, formatChrCb);
  };

  return _date(format, timestamp);
};
//# sourceMappingURL=date.js.map

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function boolval(mixedVar) {
  // original by: Will Rowe
  //   example 1: boolval(true)
  //   returns 1: true
  //   example 2: boolval(false)
  //   returns 2: false
  //   example 3: boolval(0)
  //   returns 3: false
  //   example 4: boolval(0.0)
  //   returns 4: false
  //   example 5: boolval('')
  //   returns 5: false
  //   example 6: boolval('0')
  //   returns 6: false
  //   example 7: boolval([])
  //   returns 7: false
  //   example 8: boolval('')
  //   returns 8: false
  //   example 9: boolval(null)
  //   returns 9: false
  //   example 10: boolval(undefined)
  //   returns 10: false
  //   example 11: boolval('true')
  //   returns 11: true

  if (mixedVar === false) {
    return false;
  }

  if (mixedVar === 0 || mixedVar === 0.0) {
    return false;
  }

  if (mixedVar === '' || mixedVar === '0') {
    return false;
  }

  if (Array.isArray(mixedVar) && mixedVar.length === 0) {
    return false;
  }

  if (mixedVar === null || mixedVar === undefined) {
    return false;
  }

  return true;
};
//# sourceMappingURL=boolval.js.map

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Twig) {
  'use strict';

  Twig.Templates.registerLoader('ajax', function (location, params, callback, errorCallback) {
    var template;
    var precompiled = params.precompiled;
    var parser = this.parsers[params.parser] || this.parser.twig;

    if (typeof XMLHttpRequest === 'undefined') {
      throw new Twig.Error('Unsupported platform: Unable to do ajax requests ' + 'because there is no "XMLHTTPRequest" implementation');
    }

    var xmlhttp = new XMLHttpRequest();

    xmlhttp.onreadystatechange = function () {
      var data = null;

      if (xmlhttp.readyState === 4) {
        if (xmlhttp.status === 200 || window.cordova && xmlhttp.status === 0) {
          Twig.log.debug('Got template ', xmlhttp.responseText);

          if (precompiled === true) {
            data = JSON.parse(xmlhttp.responseText);
          } else {
            data = xmlhttp.responseText;
          }

          params.url = location;
          params.data = data;
          template = parser.call(this, params);

          if (typeof callback === 'function') {
            callback(template);
          }
        } else if (typeof errorCallback === 'function') {
          errorCallback(xmlhttp);
        }
      }
    };

    xmlhttp.open('GET', location, Boolean(params.async));
    xmlhttp.send();

    if (params.async) {
      // TODO: return deferred promise
      return true;
    }

    return template;
  });
};

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Twig) {
  'use strict';

  var fs;
  var path;

  try {
    // Require lib dependencies at runtime
    fs = __webpack_require__(29);
    path = __webpack_require__(4);
  } catch (error) {
    // NOTE: this is in a try/catch to avoid errors cross platform
    console.warn('Missing fs and path modules. ' + error);
  }

  Twig.Templates.registerLoader('fs', function (location, params, callback, errorCallback) {
    var template;
    var data = null;
    var precompiled = params.precompiled;
    var parser = this.parsers[params.parser] || this.parser.twig;

    if (!fs || !path) {
      throw new Twig.Error('Unsupported platform: Unable to load from file ' + 'because there is no "fs" or "path" implementation');
    }

    var loadTemplateFn = function loadTemplateFn(err, data) {
      if (err) {
        if (typeof errorCallback === 'function') {
          errorCallback(err);
        }

        return;
      }

      if (precompiled === true) {
        data = JSON.parse(data);
      }

      params.data = data;
      params.path = params.path || location; // Template is in data

      template = parser.call(this, params);

      if (typeof callback === 'function') {
        callback(template);
      }
    };

    params.path = params.path || location;

    if (params.async) {
      fs.stat(params.path, function (err, stats) {
        if (err || !stats.isFile()) {
          if (typeof errorCallback === 'function') {
            errorCallback(new Twig.Error('Unable to find template file ' + params.path));
          }

          return;
        }

        fs.readFile(params.path, 'utf8', loadTemplateFn);
      }); // TODO: return deferred promise

      return true;
    }

    try {
      if (!fs.statSync(params.path).isFile()) {
        throw new Twig.Error('Unable to find template file ' + params.path);
      }
    } catch (error) {
      throw new Twig.Error('Unable to find template file ' + params.path + '. ' + error);
    }

    data = fs.readFileSync(params.path, 'utf8');
    loadTemplateFn(undefined, data);
    return template;
  });
};

/***/ }),
/* 29 */
/***/ (function(module, exports) {

module.exports = __webpack_require__(/*! fs */ 19);

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(0);

var _defineProperty2 = _interopRequireDefault(__webpack_require__(2));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// ## twig.logic.js
//
// This file handles tokenizing, compiling and parsing logic tokens. {% ... %}
module.exports = function (Twig) {
  'use strict';
  /**
   * Namespace for logic handling.
   */

  Twig.logic = {};
  /**
   * Logic token types.
   */

  Twig.logic.type = {
    if_: 'Twig.logic.type.if',
    endif: 'Twig.logic.type.endif',
    for_: 'Twig.logic.type.for',
    endfor: 'Twig.logic.type.endfor',
    else_: 'Twig.logic.type.else',
    elseif: 'Twig.logic.type.elseif',
    set: 'Twig.logic.type.set',
    setcapture: 'Twig.logic.type.setcapture',
    endset: 'Twig.logic.type.endset',
    filter: 'Twig.logic.type.filter',
    endfilter: 'Twig.logic.type.endfilter',
    apply: 'Twig.logic.type.apply',
    endapply: 'Twig.logic.type.endapply',
    "do": 'Twig.logic.type.do',
    shortblock: 'Twig.logic.type.shortblock',
    block: 'Twig.logic.type.block',
    endblock: 'Twig.logic.type.endblock',
    extends_: 'Twig.logic.type.extends',
    use: 'Twig.logic.type.use',
    include: 'Twig.logic.type.include',
    spaceless: 'Twig.logic.type.spaceless',
    endspaceless: 'Twig.logic.type.endspaceless',
    macro: 'Twig.logic.type.macro',
    endmacro: 'Twig.logic.type.endmacro',
    import_: 'Twig.logic.type.import',
    from: 'Twig.logic.type.from',
    embed: 'Twig.logic.type.embed',
    endembed: 'Twig.logic.type.endembed',
    "with": 'Twig.logic.type.with',
    endwith: 'Twig.logic.type.endwith',
    deprecated: 'Twig.logic.type.deprecated'
  }; // Regular expressions for handling logic tokens.
  //
  // Properties:
  //
  //      type:  The type of expression this matches
  //
  //      regex: A regular expression that matches the format of the token
  //
  //      next:  What logic tokens (if any) pop this token off the logic stack. If empty, the
  //             logic token is assumed to not require an end tag and isn't push onto the stack.
  //
  //      open:  Does this tag open a logic expression or is it standalone. For example,
  //             {% endif %} cannot exist without an opening {% if ... %} tag, so open = false.
  //
  //  Functions:
  //
  //      compile: A function that handles compiling the token into an output token ready for
  //               parsing with the parse function.
  //
  //      parse:   A function that parses the compiled token into output (HTML / whatever the
  //               template represents).

  Twig.logic.definitions = [{
    /**
     * If type logic tokens.
     *
     *  Format: {% if expression %}
     */
    type: Twig.logic.type.if_,
    regex: /^if\s?([\s\S]+)$/,
    next: [Twig.logic.type.else_, Twig.logic.type.elseif, Twig.logic.type.endif],
    open: true,
    compile: function compile(token) {
      var expression = token.match[1]; // Compile the expression.

      token.stack = Twig.expression.compile.call(this, {
        type: Twig.expression.type.expression,
        value: expression
      }).stack;
      delete token.match;
      return token;
    },
    parse: function parse(token, context, chain) {
      var state = this;
      return Twig.expression.parseAsync.call(state, token.stack, context).then(function (result) {
        chain = true;

        if (Twig.lib.boolval(result)) {
          chain = false;
          return state.parseAsync(token.output, context);
        }

        return '';
      }).then(function (output) {
        return {
          chain: chain,
          output: output
        };
      });
    }
  }, {
    /**
     * Else if type logic tokens.
     *
     *  Format: {% elseif expression %}
     */
    type: Twig.logic.type.elseif,
    regex: /^elseif\s?([^\s].*)$/,
    next: [Twig.logic.type.else_, Twig.logic.type.elseif, Twig.logic.type.endif],
    open: false,
    compile: function compile(token) {
      var expression = token.match[1]; // Compile the expression.

      token.stack = Twig.expression.compile.call(this, {
        type: Twig.expression.type.expression,
        value: expression
      }).stack;
      delete token.match;
      return token;
    },
    parse: function parse(token, context, chain) {
      var state = this;
      return Twig.expression.parseAsync.call(state, token.stack, context).then(function (result) {
        if (chain && Twig.lib.boolval(result)) {
          chain = false;
          return state.parseAsync(token.output, context);
        }

        return '';
      }).then(function (output) {
        return {
          chain: chain,
          output: output
        };
      });
    }
  }, {
    /**
     * Else type logic tokens.
     *
     *  Format: {% else %}
     */
    type: Twig.logic.type.else_,
    regex: /^else$/,
    next: [Twig.logic.type.endif, Twig.logic.type.endfor],
    open: false,
    parse: function parse(token, context, chain) {
      var promise = Twig.Promise.resolve('');
      var state = this;

      if (chain) {
        promise = state.parseAsync(token.output, context);
      }

      return promise.then(function (output) {
        return {
          chain: chain,
          output: output
        };
      });
    }
  }, {
    /**
     * End if type logic tokens.
     *
     *  Format: {% endif %}
     */
    type: Twig.logic.type.endif,
    regex: /^endif$/,
    next: [],
    open: false
  }, {
    /**
     * For type logic tokens.
     *
     *  Format: {% for expression %}
     */
    type: Twig.logic.type.for_,
    regex: /^for\s+([a-zA-Z0-9_,\s]+)\s+in\s+([\S\s]+?)(?:\s+if\s+([^\s].*))?$/,
    next: [Twig.logic.type.else_, Twig.logic.type.endfor],
    open: true,
    compile: function compile(token) {
      var keyValue = token.match[1];
      var expression = token.match[2];
      var conditional = token.match[3];
      var kvSplit = null;
      token.keyVar = null;
      token.valueVar = null;

      if (keyValue.includes(',')) {
        kvSplit = keyValue.split(',');

        if (kvSplit.length === 2) {
          token.keyVar = kvSplit[0].trim();
          token.valueVar = kvSplit[1].trim();
        } else {
          throw new Twig.Error('Invalid expression in for loop: ' + keyValue);
        }
      } else {
        token.valueVar = keyValue.trim();
      } // Valid expressions for a for loop
      //   for item     in expression
      //   for key,item in expression
      // Compile the expression.


      token.expression = Twig.expression.compile.call(this, {
        type: Twig.expression.type.expression,
        value: expression
      }).stack; // Compile the conditional (if available)

      if (conditional) {
        token.conditional = Twig.expression.compile.call(this, {
          type: Twig.expression.type.expression,
          value: conditional
        }).stack;
      }

      delete token.match;
      return token;
    },
    parse: function parse(token, context, continueChain) {
      // Parse expression
      var output = [];
      var len;
      var index = 0;
      var keyset;
      var state = this;
      var conditional = token.conditional;

      var buildLoop = function buildLoop(index, len) {
        var isConditional = conditional !== undefined;
        return {
          index: index + 1,
          index0: index,
          revindex: isConditional ? undefined : len - index,
          revindex0: isConditional ? undefined : len - index - 1,
          first: index === 0,
          last: isConditional ? undefined : index === len - 1,
          length: isConditional ? undefined : len,
          parent: context
        };
      }; // Run once for each iteration of the loop


      var loop = function loop(key, value) {
        var innerContext = _objectSpread({}, context);

        innerContext[token.valueVar] = value;

        if (token.keyVar) {
          innerContext[token.keyVar] = key;
        } // Loop object


        innerContext.loop = buildLoop(index, len);
        var promise = conditional === undefined ? Twig.Promise.resolve(true) : Twig.expression.parseAsync.call(state, conditional, innerContext);
        return promise.then(function (condition) {
          if (!condition) {
            return;
          }

          return state.parseAsync(token.output, innerContext).then(function (tokenOutput) {
            output.push(tokenOutput);
            index += 1;
          });
        }).then(function () {
          // Delete loop-related variables from the context
          delete innerContext.loop;
          delete innerContext[token.valueVar];
          delete innerContext[token.keyVar]; // Merge in values that exist in context but have changed
          // in inner_context.

          Twig.merge(context, innerContext, true);
        });
      };

      return Twig.expression.parseAsync.call(state, token.expression, context).then(function (result) {
        if (Array.isArray(result)) {
          len = result.length;
          return Twig.async.forEach(result, function (value) {
            var key = index;
            return loop(key, value);
          });
        }

        if (Twig.lib.is('Object', result)) {
          if (result._keys === undefined) {
            keyset = Object.keys(result);
          } else {
            keyset = result._keys;
          }

          len = keyset.length;
          return Twig.async.forEach(keyset, function (key) {
            // Ignore the _keys property, it's internal to twig.js
            if (key === '_keys') {
              return;
            }

            return loop(key, result[key]);
          });
        }
      }).then(function () {
        // Only allow else statements if no output was generated
        continueChain = output.length === 0;
        return {
          chain: continueChain,
          context: context,
          output: Twig.output.call(state.template, output)
        };
      });
    }
  }, {
    /**
     * End for type logic tokens.
     *
     *  Format: {% endfor %}
     */
    type: Twig.logic.type.endfor,
    regex: /^endfor$/,
    next: [],
    open: false
  }, {
    /**
     * Set type logic tokens.
     *
     *  Format: {% set key = expression %}
     */
    type: Twig.logic.type.set,
    regex: /^set\s+([a-zA-Z0-9_,\s]+)\s*=\s*([\s\S]+)$/,
    next: [],
    open: true,
    compile: function compile(token) {
      //
      var key = token.match[1].trim();
      var expression = token.match[2]; // Compile the expression.

      var expressionStack = Twig.expression.compile.call(this, {
        type: Twig.expression.type.expression,
        value: expression
      }).stack;
      token.key = key;
      token.expression = expressionStack;
      delete token.match;
      return token;
    },
    parse: function parse(token, context, continueChain) {
      var key = token.key;
      var state = this;
      return Twig.expression.parseAsync.call(state, token.expression, context).then(function (value) {
        if (value === context) {
          /*  If storing the context in a variable, it needs to be a clone of the current state of context.
              Otherwise we have a context with infinite recursion.
              Fixes #341
          */
          value = _objectSpread({}, value);
        }

        context[key] = value;
        return {
          chain: continueChain,
          context: context
        };
      });
    }
  }, {
    /**
     * Set capture type logic tokens.
     *
     *  Format: {% set key %}
     */
    type: Twig.logic.type.setcapture,
    regex: /^set\s+([a-zA-Z0-9_,\s]+)$/,
    next: [Twig.logic.type.endset],
    open: true,
    compile: function compile(token) {
      var key = token.match[1].trim();
      token.key = key;
      delete token.match;
      return token;
    },
    parse: function parse(token, context, continueChain) {
      var state = this;
      var key = token.key;
      return state.parseAsync(token.output, context).then(function (output) {
        // Set on both the global and local context
        state.context[key] = output;
        context[key] = output;
        return {
          chain: continueChain,
          context: context
        };
      });
    }
  }, {
    /**
     * End set type block logic tokens.
     *
     *  Format: {% endset %}
     */
    type: Twig.logic.type.endset,
    regex: /^endset$/,
    next: [],
    open: false
  }, {
    /**
     * Filter logic tokens.
     *
     *  Format: {% filter upper %} or {% filter lower|escape %}
     */
    type: Twig.logic.type.filter,
    regex: /^filter\s+(.+)$/,
    next: [Twig.logic.type.endfilter],
    open: true,
    compile: function compile(token) {
      var expression = '|' + token.match[1].trim(); // Compile the expression.

      token.stack = Twig.expression.compile.call(this, {
        type: Twig.expression.type.expression,
        value: expression
      }).stack;
      delete token.match;
      return token;
    },
    parse: function parse(token, context, chain) {
      var state = this;
      return state.parseAsync(token.output, context).then(function (output) {
        var stack = [{
          type: Twig.expression.type.string,
          value: output
        }].concat(token.stack);
        return Twig.expression.parseAsync.call(state, stack, context);
      }).then(function (output) {
        return {
          chain: chain,
          output: output
        };
      });
    }
  }, {
    /**
     * End filter logic tokens.
     *
     *  Format: {% endfilter %}
     */
    type: Twig.logic.type.endfilter,
    regex: /^endfilter$/,
    next: [],
    open: false
  }, {
    /**
     * Apply logic tokens.
     *
     *  Format: {% apply upper %} or {% apply lower|escape %}
     */
    type: Twig.logic.type.apply,
    regex: /^apply\s+(.+)$/,
    next: [Twig.logic.type.endapply],
    open: true,
    compile: function compile(token) {
      var expression = '|' + token.match[1].trim(); // Compile the expression.

      token.stack = Twig.expression.compile.call(this, {
        type: Twig.expression.type.expression,
        value: expression
      }).stack;
      delete token.match;
      return token;
    },
    parse: function parse(token, context, chain) {
      var state = this;
      return state.parseAsync(token.output, context).then(function (output) {
        var stack = [{
          type: Twig.expression.type.string,
          value: output
        }].concat(token.stack);
        return Twig.expression.parseAsync.call(state, stack, context);
      }).then(function (output) {
        return {
          chain: chain,
          output: output
        };
      });
    }
  }, {
    /**
     * End apply logic tokens.
     *
     *  Format: {% endapply %}
     */
    type: Twig.logic.type.endapply,
    regex: /^endapply$/,
    next: [],
    open: false
  }, {
    /**
     * Set type logic tokens.
     *
     *  Format: {% do expression %}
     */
    type: Twig.logic.type["do"],
    regex: /^do\s+([\S\s]+)$/,
    next: [],
    open: true,
    compile: function compile(token) {
      //
      var expression = token.match[1]; // Compile the expression.

      var expressionStack = Twig.expression.compile.call(this, {
        type: Twig.expression.type.expression,
        value: expression
      }).stack;
      token.expression = expressionStack;
      delete token.match;
      return token;
    },
    parse: function parse(token, context, continueChain) {
      var state = this;
      return Twig.expression.parseAsync.call(state, token.expression, context).then(function () {
        return {
          chain: continueChain,
          context: context
        };
      });
    }
  }, {
    /**
     * Block logic tokens.
     *
     *  Format: {% block title %}
     */
    type: Twig.logic.type.block,
    regex: /^block\s+(\w+)$/,
    next: [Twig.logic.type.endblock],
    open: true,
    compile: function compile(token) {
      token.blockName = token.match[1].trim();
      delete token.match;
      return token;
    },
    parse: function parse(token, context, chain) {
      var state = this;
      var promise = Twig.Promise.resolve();
      state.template.blocks.defined[token.blockName] = new Twig.Block(state.template, token);

      if (state.template.parentTemplate === null || state.template.parentTemplate instanceof Twig.Template) {
        promise = state.getBlock(token.blockName).render(state, context);
      }

      return promise.then(function (output) {
        return {
          chain: chain,
          output: output
        };
      });
    }
  }, {
    /**
     * Block shorthand logic tokens.
     *
     *  Format: {% block title expression %}
     */
    type: Twig.logic.type.shortblock,
    regex: /^block\s+(\w+)\s+(.+)$/,
    next: [],
    open: true,
    compile: function compile(token) {
      var template = this;
      token.expression = token.match[2].trim();
      token.output = Twig.expression.compile({
        type: Twig.expression.type.expression,
        value: token.expression
      }).stack;
      return Twig.logic.handler[Twig.logic.type.block].compile.apply(template, [token]);
    },
    parse: function parse() {
      var state = this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return Twig.logic.handler[Twig.logic.type.block].parse.apply(state, args);
    }
  }, {
    /**
     * End block logic tokens.
     *
     *  Format: {% endblock %}
     */
    type: Twig.logic.type.endblock,
    regex: /^endblock(?:\s+(\w+))?$/,
    next: [],
    open: false
  }, {
    /**
     * Block logic tokens.
     *
     *  Format: {% extends "template.twig" %}
     */
    type: Twig.logic.type.extends_,
    regex: /^extends\s+(.+)$/,
    next: [],
    open: true,
    compile: function compile(token) {
      var expression = token.match[1].trim();
      delete token.match;
      token.stack = Twig.expression.compile.call(this, {
        type: Twig.expression.type.expression,
        value: expression
      }).stack;
      return token;
    },
    parse: function parse(token, context, chain) {
      var state = this;
      return Twig.expression.parseAsync.call(state, token.stack, context).then(function (fileName) {
        state.template.parentTemplate = fileName;
        return {
          chain: chain,
          output: ''
        };
      });
    }
  }, {
    /**
     * Block logic tokens.
     *
     *  Format: {% use "template.twig" %}
     */
    type: Twig.logic.type.use,
    regex: /^use\s+(.+)$/,
    next: [],
    open: true,
    compile: function compile(token) {
      var expression = token.match[1].trim();
      delete token.match;
      token.stack = Twig.expression.compile.call(this, {
        type: Twig.expression.type.expression,
        value: expression
      }).stack;
      return token;
    },
    parse: function parse(token, context, chain) {
      var state = this;
      return Twig.expression.parseAsync.call(state, token.stack, context).then(function (filePath) {
        // Create a new state instead of using the current state
        // any defined blocks will be created in isolation
        var useTemplate = state.template.importFile(filePath);
        var useState = new Twig.ParseState(useTemplate);
        return useState.parseAsync(useTemplate.tokens).then(function () {
          state.template.blocks.imported = _objectSpread({}, state.template.blocks.imported, {}, useState.getBlocks());
        });
      }).then(function () {
        return {
          chain: chain,
          output: ''
        };
      });
    }
  }, {
    /**
     * Block logic tokens.
     *
     *  Format: {% includes "template.twig" [with {some: 'values'} only] %}
     */
    type: Twig.logic.type.include,
    regex: /^include\s+(.+?)(?:\s|$)(ignore missing(?:\s|$))?(?:with\s+([\S\s]+?))?(?:\s|$)(only)?$/,
    next: [],
    open: true,
    compile: function compile(token) {
      var match = token.match;
      var expression = match[1].trim();
      var ignoreMissing = match[2] !== undefined;
      var withContext = match[3];
      var only = match[4] !== undefined && match[4].length;
      delete token.match;
      token.only = only;
      token.ignoreMissing = ignoreMissing;
      token.stack = Twig.expression.compile.call(this, {
        type: Twig.expression.type.expression,
        value: expression
      }).stack;

      if (withContext !== undefined) {
        token.withStack = Twig.expression.compile.call(this, {
          type: Twig.expression.type.expression,
          value: withContext.trim()
        }).stack;
      }

      return token;
    },
    parse: function parse(token, context, chain) {
      // Resolve filename
      var innerContext = token.only ? {} : _objectSpread({}, context);
      var ignoreMissing = token.ignoreMissing;
      var state = this;
      var promise = null;
      var result = {
        chain: chain,
        output: ''
      };

      if (typeof token.withStack === 'undefined') {
        promise = Twig.Promise.resolve();
      } else {
        promise = Twig.expression.parseAsync.call(state, token.withStack, context).then(function (withContext) {
          innerContext = _objectSpread({}, innerContext, {}, withContext);
        });
      }

      return promise.then(function () {
        return Twig.expression.parseAsync.call(state, token.stack, context);
      }).then(function (file) {
        var files;

        if (Array.isArray(file)) {
          files = file;
        } else {
          files = [file];
        }

        var result = files.reduce(function (acc, file) {
          if (acc.render === null) {
            if (file instanceof Twig.Template) {
              return {
                render: file.renderAsync(innerContext, {
                  isInclude: true
                }),
                lastError: null
              };
            }

            try {
              return {
                render: state.template.importFile(file).renderAsync(innerContext, {
                  isInclude: true
                }),
                lastError: null
              };
            } catch (error) {
              return {
                render: null,
                lastError: error
              };
            }
          }

          return acc;
        }, {
          render: null,
          lastError: null
        });

        if (result.render !== null) {
          return result.render;
        }

        if (result.render === null && ignoreMissing) {
          return '';
        }

        throw result.lastError;
      }).then(function (output) {
        if (output !== '') {
          result.output = output;
        }

        return result;
      });
    }
  }, {
    type: Twig.logic.type.spaceless,
    regex: /^spaceless$/,
    next: [Twig.logic.type.endspaceless],
    open: true,
    // Parse the html and return it without any spaces between tags
    parse: function parse(token, context, chain) {
      var state = this; // Parse the output without any filter

      return state.parseAsync(token.output, context).then(function (tokenOutput) {
        var // A regular expression to find closing and opening tags with spaces between them
        rBetweenTagSpaces = />\s+</g; // Replace all space between closing and opening html tags

        var output = tokenOutput.replace(rBetweenTagSpaces, '><').trim(); // Rewrap output as a Twig.Markup

        output = new Twig.Markup(output);
        return {
          chain: chain,
          output: output
        };
      });
    }
  }, // Add the {% endspaceless %} token
  {
    type: Twig.logic.type.endspaceless,
    regex: /^endspaceless$/,
    next: [],
    open: false
  }, {
    /**
     * Macro logic tokens.
     *
     * Format: {% macro input(name = default, value, type, size) %}
     *
     */
    type: Twig.logic.type.macro,
    regex: /^macro\s+(\w+)\s*\(\s*((?:\w+(?:\s*=\s*([\s\S]+))?(?:,\s*)?)*)\s*\)$/,
    next: [Twig.logic.type.endmacro],
    open: true,
    compile: function compile(token) {
      var macroName = token.match[1];
      var rawParameters = token.match[2].split(/\s*,\s*/);
      var parameters = rawParameters.map(function (rawParameter) {
        return rawParameter.split(/\s*=\s*/)[0];
      });
      var parametersCount = parameters.length; // Duplicate check

      if (parametersCount > 1) {
        var uniq = {};

        for (var i = 0; i < parametersCount; i++) {
          var parameter = parameters[i];

          if (uniq[parameter]) {
            throw new Twig.Error('Duplicate arguments for parameter: ' + parameter);
          } else {
            uniq[parameter] = 1;
          }
        }
      }

      token.macroName = macroName;
      token.parameters = parameters;
      token.defaults = rawParameters.reduce(function (defaults, rawParameter) {
        var pair = rawParameter.split(/\s*=\s*/);
        var key = pair[0];
        var expression = pair[1];

        if (expression) {
          defaults[key] = Twig.expression.compile.call(this, {
            type: Twig.expression.type.expression,
            value: expression
          }).stack;
        } else {
          defaults[key] = undefined;
        }

        return defaults;
      }, {});
      delete token.match;
      return token;
    },
    parse: function parse(token, context, chain) {
      var state = this;

      state.macros[token.macroName] = function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        // Pass global context and other macros
        var macroContext = {
          _self: state.macros
        }; // Save arguments

        return Twig.async.forEach(token.parameters, function (prop, i) {
          // Add parameters from context to macroContext
          if (typeof args[i] !== 'undefined') {
            macroContext[prop] = args[i];
            return true;
          }

          if (typeof token.defaults[prop] !== 'undefined') {
            return Twig.expression.parseAsync.call(this, token.defaults[prop], context).then(function (value) {
              macroContext[prop] = value;
              return Twig.Promise.resolve();
            });
          }

          macroContext[prop] = undefined;
          return true;
        }).then(function () {
          // Render
          return state.parseAsync(token.output, macroContext);
        });
      };

      return {
        chain: chain,
        output: ''
      };
    }
  }, {
    /**
     * End macro logic tokens.
     *
     * Format: {% endmacro %}
     */
    type: Twig.logic.type.endmacro,
    regex: /^endmacro$/,
    next: [],
    open: false
  }, {
    /*
    * Import logic tokens.
    *
    * Format: {% import "template.twig" as form %}
    */
    type: Twig.logic.type.import_,
    regex: /^import\s+(.+)\s+as\s+(\w+)$/,
    next: [],
    open: true,
    compile: function compile(token) {
      var expression = token.match[1].trim();
      var contextName = token.match[2].trim();
      delete token.match;
      token.expression = expression;
      token.contextName = contextName;
      token.stack = Twig.expression.compile.call(this, {
        type: Twig.expression.type.expression,
        value: expression
      }).stack;
      return token;
    },
    parse: function parse(token, context, chain) {
      var state = this;
      var output = {
        chain: chain,
        output: ''
      };

      if (token.expression === '_self') {
        context[token.contextName] = state.macros;
        return output;
      }

      return Twig.expression.parseAsync.call(state, token.stack, context).then(function (filePath) {
        return state.template.importFile(filePath || token.expression);
      }).then(function (importTemplate) {
        var importState = new Twig.ParseState(importTemplate);
        return importState.parseAsync(importTemplate.tokens).then(function () {
          context[token.contextName] = importState.macros;
          return output;
        });
      });
    }
  }, {
    /*
    * From logic tokens.
    *
    * Format: {% from "template.twig" import func as form %}
    */
    type: Twig.logic.type.from,
    regex: /^from\s+(.+)\s+import\s+([a-zA-Z0-9_, ]+)$/,
    next: [],
    open: true,
    compile: function compile(token) {
      var expression = token.match[1].trim();
      var macroExpressions = token.match[2].trim().split(/\s*,\s*/);
      var macroNames = {};
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = macroExpressions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var res = _step.value;
          // Match function as variable
          var macroMatch = res.match(/^(\w+)\s+as\s+(\w+)$/);

          if (macroMatch) {
            macroNames[macroMatch[1].trim()] = macroMatch[2].trim();
          } else if (res.match(/^(\w+)$/)) {
            macroNames[res] = res;
          } else {// ignore import
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      delete token.match;
      token.expression = expression;
      token.macroNames = macroNames;
      token.stack = Twig.expression.compile.call(this, {
        type: Twig.expression.type.expression,
        value: expression
      }).stack;
      return token;
    },
    parse: function parse(token, context, chain) {
      var state = this;
      var promise;

      if (token.expression === '_self') {
        promise = Twig.Promise.resolve(state.macros);
      } else {
        promise = Twig.expression.parseAsync.call(state, token.stack, context).then(function (filePath) {
          return state.template.importFile(filePath || token.expression);
        }).then(function (importTemplate) {
          var importState = new Twig.ParseState(importTemplate);
          return importState.parseAsync(importTemplate.tokens).then(function () {
            return importState.macros;
          });
        });
      }

      return promise.then(function (macros) {
        for (var macroName in token.macroNames) {
          if (macros[macroName] !== undefined) {
            context[token.macroNames[macroName]] = macros[macroName];
          }
        }

        return {
          chain: chain,
          output: ''
        };
      });
    }
  }, {
    /**
     * The embed tag combines the behaviour of include and extends.
     * It allows you to include another template's contents, just like include does.
     *
     *  Format: {% embed "template.twig" [with {some: 'values'} only] %}
     */
    type: Twig.logic.type.embed,
    regex: /^embed\s+(.+?)(?:\s+(ignore missing))?(?:\s+with\s+([\S\s]+?))?(?:\s+(only))?$/,
    next: [Twig.logic.type.endembed],
    open: true,
    compile: function compile(token) {
      var match = token.match;
      var expression = match[1].trim();
      var ignoreMissing = match[2] !== undefined;
      var withContext = match[3];
      var only = match[4] !== undefined && match[4].length;
      delete token.match;
      token.only = only;
      token.ignoreMissing = ignoreMissing;
      token.stack = Twig.expression.compile.call(this, {
        type: Twig.expression.type.expression,
        value: expression
      }).stack;

      if (withContext !== undefined) {
        token.withStack = Twig.expression.compile.call(this, {
          type: Twig.expression.type.expression,
          value: withContext.trim()
        }).stack;
      }

      return token;
    },
    parse: function parse(token, context, chain) {
      var embedContext = {};
      var promise = Twig.Promise.resolve();
      var state = this;

      if (!token.only) {
        embedContext = _objectSpread({}, context);
      }

      if (token.withStack !== undefined) {
        promise = Twig.expression.parseAsync.call(state, token.withStack, context).then(function (withContext) {
          embedContext = _objectSpread({}, embedContext, {}, withContext);
        });
      }

      return promise.then(function () {
        return Twig.expression.parseAsync.call(state, token.stack, embedContext);
      }).then(function (fileName) {
        var embedOverrideTemplate = new Twig.Template({
          data: token.output,
          id: state.template.id,
          base: state.template.base,
          path: state.template.path,
          url: state.template.url,
          name: state.template.name,
          method: state.template.method,
          options: state.template.options
        });

        try {
          embedOverrideTemplate.importFile(fileName);
        } catch (error) {
          if (token.ignoreMissing) {
            return '';
          } // Errors preserve references to variables in scope,
          // this removes `this` from the scope.


          state = null;
          throw error;
        }

        embedOverrideTemplate.parentTemplate = fileName;
        return embedOverrideTemplate.renderAsync(embedContext, {
          isInclude: true
        });
      }).then(function (output) {
        return {
          chain: chain,
          output: output
        };
      });
    }
  },
  /* Add the {% endembed %} token
   *
   */
  {
    type: Twig.logic.type.endembed,
    regex: /^endembed$/,
    next: [],
    open: false
  }, {
    /**
     * Block logic tokens.
     *
     *  Format: {% with {some: 'values'} [only] %}
     */
    type: Twig.logic.type["with"],
    regex: /^(?:with\s+([\S\s]+?))(?:\s|$)(only)?$/,
    next: [Twig.logic.type.endwith],
    open: true,
    compile: function compile(token) {
      var match = token.match;
      var withContext = match[1];
      var only = match[2] !== undefined && match[2].length;
      delete token.match;
      token.only = only;

      if (withContext !== undefined) {
        token.withStack = Twig.expression.compile.call(this, {
          type: Twig.expression.type.expression,
          value: withContext.trim()
        }).stack;
      }

      return token;
    },
    parse: function parse(token, context, chain) {
      // Resolve filename
      var innerContext = {};
      var i;
      var state = this;
      var promise = Twig.Promise.resolve();

      if (!token.only) {
        innerContext = _objectSpread({}, context);
      }

      if (token.withStack !== undefined) {
        promise = Twig.expression.parseAsync.call(state, token.withStack, context).then(function (withContext) {
          for (i in withContext) {
            if (Object.hasOwnProperty.call(withContext, i)) {
              innerContext[i] = withContext[i];
            }
          }
        });
      }

      return promise.then(function () {
        return state.parseAsync(token.output, innerContext);
      }).then(function (output) {
        return {
          chain: chain,
          output: output
        };
      });
    }
  }, {
    type: Twig.logic.type.endwith,
    regex: /^endwith$/,
    next: [],
    open: false
  }, {
    /**
     * Deprecated type logic tokens.
     *
     *  Format: {% deprecated 'Description' %}
     */
    type: Twig.logic.type.deprecated,
    regex: /^deprecated\s+(.+)$/,
    next: [],
    open: true,
    compile: function compile(token) {
      console.warn('Deprecation notice: ' + token.match[1]);
      return token;
    },
    parse: function parse() {
      return {};
    }
  }];
  /**
   * Registry for logic handlers.
   */

  Twig.logic.handler = {};
  /**
   * Define a new token type, available at Twig.logic.type.{type}
   */

  Twig.logic.extendType = function (type, value) {
    value = value || 'Twig.logic.type' + type;
    Twig.logic.type[type] = value;
  };
  /**
   * Extend the logic parsing functionality with a new token definition.
   *
   * // Define a new tag
   * Twig.logic.extend({
   *     type: Twig.logic.type.{type},
   *     // The pattern to match for this token
   *     regex: ...,
   *     // What token types can follow this token, leave blank if any.
   *     next: [ ... ]
   *     // Create and return compiled version of the token
   *     compile: function(token) { ... }
   *     // Parse the compiled token with the context provided by the render call
   *     //   and whether this token chain is complete.
   *     parse: function(token, context, chain) { ... }
   * });
   *
   * @param {Object} definition The new logic expression.
   */


  Twig.logic.extend = function (definition) {
    if (definition.type) {
      Twig.logic.extendType(definition.type);
    } else {
      throw new Twig.Error('Unable to extend logic definition. No type provided for ' + definition);
    }

    Twig.logic.handler[definition.type] = definition;
  }; // Extend with built-in expressions


  while (Twig.logic.definitions.length > 0) {
    Twig.logic.extend(Twig.logic.definitions.shift());
  }
  /**
   * Compile a logic token into an object ready for parsing.
   *
   * @param {Object} rawToken An uncompiled logic token.
   *
   * @return {Object} A compiled logic token, ready for parsing.
   */


  Twig.logic.compile = function (rawToken) {
    var expression = rawToken.value.trim();
    var token = Twig.logic.tokenize.call(this, expression);
    var tokenTemplate = Twig.logic.handler[token.type]; // Check if the token needs compiling

    if (tokenTemplate.compile) {
      token = tokenTemplate.compile.call(this, token);
      Twig.log.trace('Twig.logic.compile: ', 'Compiled logic token to ', token);
    }

    return token;
  };
  /**
   * Tokenize logic expressions. This function matches token expressions against regular
   * expressions provided in token definitions provided with Twig.logic.extend.
   *
   * @param {string} expression the logic token expression to tokenize
   *                (i.e. what's between {% and %})
   *
   * @return {Object} The matched token with type set to the token type and match to the regex match.
   */


  Twig.logic.tokenize = function (expression) {
    var tokenTemplateType = null;
    var tokenType = null;
    var tokenRegex = null;
    var regexArray = null;
    var regexLen = null;
    var regexI = null;
    var match = null; // Ignore whitespace around expressions.

    expression = expression.trim();

    for (tokenTemplateType in Twig.logic.handler) {
      if (Object.hasOwnProperty.call(Twig.logic.handler, tokenTemplateType)) {
        // Get the type and regex for this template type
        tokenType = Twig.logic.handler[tokenTemplateType].type;
        tokenRegex = Twig.logic.handler[tokenTemplateType].regex; // Handle multiple regular expressions per type.

        regexArray = tokenRegex;

        if (!Array.isArray(tokenRegex)) {
          regexArray = [tokenRegex];
        }

        regexLen = regexArray.length; // Check regular expressions in the order they were specified in the definition.

        for (regexI = 0; regexI < regexLen; regexI++) {
          match = regexArray[regexI].exec(expression);

          if (match !== null) {
            Twig.log.trace('Twig.logic.tokenize: ', 'Matched a ', tokenType, ' regular expression of ', match);
            return {
              type: tokenType,
              match: match
            };
          }
        }
      }
    } // No regex matches


    throw new Twig.Error('Unable to parse \'' + expression.trim() + '\'');
  };
  /**
   * Parse a logic token within a given context.
   *
   * What are logic chains?
   *      Logic chains represent a series of tokens that are connected,
   *          for example:
   *          {% if ... %} {% else %} {% endif %}
   *
   *      The chain parameter is used to signify if a chain is open of closed.
   *      open:
   *          More tokens in this chain should be parsed.
   *      closed:
   *          This token chain has completed parsing and any additional
   *          tokens (else, elseif, etc...) should be ignored.
   *
   * @param {Object} token The compiled token.
   * @param {Object} context The render context.
   * @param {boolean} chain Is this an open logic chain. If false, that means a
   *                        chain is closed and no further cases should be parsed.
   */


  Twig.logic.parse = function (token, context, chain, allowAsync) {
    return Twig.async.potentiallyAsync(this, allowAsync, function () {
      Twig.log.debug('Twig.logic.parse: ', 'Parsing logic token ', token);
      var tokenTemplate = Twig.logic.handler[token.type];
      var result;
      var state = this;

      if (!tokenTemplate.parse) {
        return '';
      }

      state.nestingStack.unshift(token);
      result = tokenTemplate.parse.call(state, token, context || {}, chain);

      if (Twig.isPromise(result)) {
        result = result.then(function (result) {
          state.nestingStack.shift();
          return result;
        });
      } else {
        state.nestingStack.shift();
      }

      return result;
    });
  };

  return Twig;
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Twig) {
  'use strict';

  Twig.Templates.registerParser('source', function (params) {
    return params.data || '';
  });
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Twig) {
  'use strict';

  Twig.Templates.registerParser('twig', function (params) {
    return new Twig.Template(params);
  });
};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(0);

var _typeof2 = _interopRequireDefault(__webpack_require__(1));

// ## twig.path.js
//
// This file handles path parsing
module.exports = function (Twig) {
  'use strict';
  /**
   * Namespace for path handling.
   */

  Twig.path = {};
  /**
   * Generate the canonical version of a url based on the given base path and file path and in
   * the previously registered namespaces.
   *
   * @param  {string} template The Twig Template
   * @param  {string} _file    The file path, may be relative and may contain namespaces.
   *
   * @return {string}          The canonical version of the path
   */

  Twig.path.parsePath = function (template, _file) {
    var k = null;
    var namespaces = template.options.namespaces;
    var file = _file || '';
    var hasNamespaces = namespaces && (0, _typeof2["default"])(namespaces) === 'object';

    if (hasNamespaces) {
      for (k in namespaces) {
        if (!file.includes(k)) {
          continue;
        } // Check if keyed namespace exists at path's start


        var colon = new RegExp('^' + k + '::');
        var atSign = new RegExp('^@' + k + '/'); // Add slash to the end of path

        var namespacePath = namespaces[k].replace(/([^/])$/, '$1/');

        if (colon.test(file)) {
          file = file.replace(colon, namespacePath);
          return file;
        }

        if (atSign.test(file)) {
          file = file.replace(atSign, namespacePath);
          return file;
        }
      }
    }

    return Twig.path.relativePath(template, file);
  };
  /**
   * Generate the relative canonical version of a url based on the given base path and file path.
   *
   * @param {Twig.Template} template The Twig.Template.
   * @param {string} _file The file path, relative to the base path.
   *
   * @return {string} The canonical version of the path.
   */


  Twig.path.relativePath = function (template, _file) {
    var base;
    var basePath;
    var sepChr = '/';
    var newPath = [];
    var file = _file || '';
    var val;

    if (template.url) {
      if (typeof template.base === 'undefined') {
        base = template.url;
      } else {
        // Add slash to the end of path
        base = template.base.replace(/([^/])$/, '$1/');
      }
    } else if (template.path) {
      // Get the system-specific path separator
      var path = __webpack_require__(4);

      var sep = path.sep || sepChr;
      var relative = new RegExp('^\\.{1,2}' + sep.replace('\\', '\\\\'));
      file = file.replace(/\//g, sep);

      if (template.base !== undefined && file.match(relative) === null) {
        file = file.replace(template.base, '');
        base = template.base + sep;
      } else {
        base = path.normalize(template.path);
      }

      base = base.replace(sep + sep, sep);
      sepChr = sep;
    } else if ((template.name || template.id) && template.method && template.method !== 'fs' && template.method !== 'ajax') {
      // Custom registered loader
      base = template.base || template.name || template.id;
    } else {
      throw new Twig.Error('Cannot extend an inline template.');
    }

    basePath = base.split(sepChr); // Remove file from url

    basePath.pop();
    basePath = basePath.concat(file.split(sepChr));

    while (basePath.length > 0) {
      val = basePath.shift();

      if (val === '.') {// Ignore
      } else if (val === '..' && newPath.length > 0 && newPath[newPath.length - 1] !== '..') {
        newPath.pop();
      } else {
        newPath.push(val);
      }
    }

    return newPath.join(sepChr);
  };

  return Twig;
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// ## twig.tests.js
//
// This file handles expression tests. (is empty, is not defined, etc...)
module.exports = function (Twig) {
  'use strict';

  Twig.tests = {
    empty: function empty(value) {
      if (value === null || value === undefined) {
        return true;
      } // Handler numbers


      if (typeof value === 'number') {
        return false;
      } // Numbers are never "empty"
      // Handle strings and arrays


      if (value.length > 0) {
        return false;
      } // Handle objects


      for (var key in value) {
        if (Object.hasOwnProperty.call(value, key)) {
          return false;
        }
      }

      return true;
    },
    odd: function odd(value) {
      return value % 2 === 1;
    },
    even: function even(value) {
      return value % 2 === 0;
    },
    divisibleby: function divisibleby(value, params) {
      return value % params[0] === 0;
    },
    defined: function defined(value) {
      return value !== undefined;
    },
    none: function none(value) {
      return value === null;
    },
    "null": function _null(value) {
      return this.none(value); // Alias of none
    },
    'same as': function sameAs(value, params) {
      return value === params[0];
    },
    sameas: function sameas(value, params) {
      console.warn('`sameas` is deprecated use `same as`');
      return Twig.tests['same as'](value, params);
    },
    iterable: function iterable(value) {
      return value && (Twig.lib.is('Array', value) || Twig.lib.is('Object', value));
    }
    /*
    Constant ?
     */

  };

  Twig.test = function (test, value, params) {
    if (!Twig.tests[test]) {
      throw Twig.Error('Test ' + test + ' is not defined.');
    }

    return Twig.tests[test](value, params);
  };

  Twig.test.extend = function (test, definition) {
    Twig.tests[test] = definition;
  };

  return Twig;
};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// ## twig.async.js
//
// This file handles asynchronous tasks within twig.
module.exports = function (Twig) {
  'use strict';

  var STATE_UNKNOWN = 0;
  var STATE_RESOLVED = 1;
  var STATE_REJECTED = 2;

  Twig.ParseState.prototype.parseAsync = function (tokens, context) {
    return this.parse(tokens, context, true);
  };

  Twig.expression.parseAsync = function (tokens, context, tokensAreParameters) {
    var state = this;
    return Twig.expression.parse.call(state, tokens, context, tokensAreParameters, true);
  };

  Twig.logic.parseAsync = function (token, context, chain) {
    var state = this;
    return Twig.logic.parse.call(state, token, context, chain, true);
  };

  Twig.Template.prototype.renderAsync = function (context, params) {
    return this.render(context, params, true);
  };

  Twig.async = {};
  /**
   * Checks for `thenable` objects
   */

  Twig.isPromise = function (obj) {
    return obj && obj.then && typeof obj.then === 'function';
  };
  /**
   * Handling of code paths that might either return a promise
   * or a value depending on whether async code is used.
   *
   * @see https://github.com/twigjs/twig.js/blob/master/ASYNC.md#detecting-asynchronous-behaviour
   */


  function potentiallyAsyncSlow(that, allowAsync, action) {
    var result = action.call(that);
    var err = null;
    var isAsync = true;

    if (!Twig.isPromise(result)) {
      return result;
    }

    result.then(function (res) {
      result = res;
      isAsync = false;
    })["catch"](function (error) {
      err = error;
    });

    if (err !== null) {
      throw err;
    }

    if (isAsync) {
      throw new Twig.Error('You are using Twig.js in sync mode in combination with async extensions.');
    }

    return result;
  }

  Twig.async.potentiallyAsync = function (that, allowAsync, action) {
    if (allowAsync) {
      return Twig.Promise.resolve(action.call(that));
    }

    return potentiallyAsyncSlow(that, allowAsync, action);
  };

  function run(fn, resolve, reject) {
    try {
      fn(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }

  function pending(handlers, onResolved, onRejected) {
    var h = [onResolved, onRejected, -2]; // The promise has yet to be rejected or resolved.

    if (!handlers) {
      handlers = h;
    } else if (handlers[2] === -2) {
      // Only allocate an array when there are multiple handlers
      handlers = [handlers, h];
    } else {
      handlers.push(h);
    }

    return handlers;
  }
  /**
   * Really small thenable to represent promises that resolve immediately.
   *
   */


  Twig.Thenable = function (then, value, state) {
    this.then = then;
    this._value = state ? value : null;
    this._state = state || STATE_UNKNOWN;
  };

  Twig.Thenable.prototype["catch"] = function (onRejected) {
    // THe promise will not throw, it has already resolved.
    if (this._state === STATE_RESOLVED) {
      return this;
    }

    return this.then(null, onRejected);
  };
  /**
   * The `then` method attached to a Thenable when it has resolved.
   *
   */


  Twig.Thenable.resolvedThen = function (onResolved) {
    try {
      return Twig.Promise.resolve(onResolved(this._value));
    } catch (error) {
      return Twig.Promise.reject(error);
    }
  };
  /**
   * The `then` method attached to a Thenable when it has rejected.
   *
   */


  Twig.Thenable.rejectedThen = function (onResolved, onRejected) {
    // Shortcut for rejected twig promises
    if (!onRejected || typeof onRejected !== 'function') {
      return this;
    }

    var value = this._value;
    var result;

    try {
      result = onRejected(value);
    } catch (error) {
      result = Twig.Promise.reject(error);
    }

    return Twig.Promise.resolve(result);
  };
  /**
   * An alternate implementation of a Promise that does not fully follow
   * the spec, but instead works fully synchronous while still being
   * thenable.
   *
   * These promises can be mixed with regular promises at which point
   * the synchronous behaviour is lost.
   */


  Twig.Promise = function (executor) {
    var state = STATE_UNKNOWN;
    var value = null;

    var changeState = function changeState(nextState, nextValue) {
      state = nextState;
      value = nextValue;
    };

    function onReady(v) {
      changeState(STATE_RESOLVED, v);
    }

    function onReject(e) {
      changeState(STATE_REJECTED, e);
    }

    run(executor, onReady, onReject); // If the promise settles right after running the executor we can
    // return a Promise with it's state already set.
    //
    // Twig.Promise.resolve and Twig.Promise.reject both use the more
    // efficient `Twig.Thenable` for this purpose.

    if (state === STATE_RESOLVED) {
      return Twig.Promise.resolve(value);
    }

    if (state === STATE_REJECTED) {
      return Twig.Promise.reject(value);
    } // If we managed to get here our promise is going to resolve asynchronous.


    changeState = new Twig.FullPromise();
    return changeState.promise;
  };
  /**
   * Promise implementation that can handle being resolved at any later time.
   *
   */


  Twig.FullPromise = function () {
    var handlers = null; // The state has been changed to either resolve, or reject
    // which means we should call the handler.

    function resolved(onResolved) {
      onResolved(p._value);
    }

    function rejected(onResolved, onRejected) {
      onRejected(p._value);
    }

    var append = function append(onResolved, onRejected) {
      handlers = pending(handlers, onResolved, onRejected);
    };

    function changeState(newState, v) {
      if (p._state) {
        return;
      }

      p._value = v;
      p._state = newState;
      append = newState === STATE_RESOLVED ? resolved : rejected;

      if (!handlers) {
        return;
      }

      if (handlers[2] === -2) {
        append(handlers[0], handlers[1]);
        handlers = null;
        return;
      }

      handlers.forEach(function (h) {
        append(h[0], h[1]);
      });
      handlers = null;
    }

    var p = new Twig.Thenable(function (onResolved, onRejected) {
      var hasResolved = typeof onResolved === 'function'; // Shortcut for resolved twig promises

      if (p._state === STATE_RESOLVED && !hasResolved) {
        return Twig.Promise.resolve(p._value);
      }

      if (p._state === STATE_RESOLVED) {
        try {
          return Twig.Promise.resolve(onResolved(p._value));
        } catch (error) {
          return Twig.Promise.reject(error);
        }
      }

      var hasRejected = typeof onRejected === 'function';
      return new Twig.Promise(function (resolve, reject) {
        append(hasResolved ? function (result) {
          try {
            resolve(onResolved(result));
          } catch (error) {
            reject(error);
          }
        } : resolve, hasRejected ? function (err) {
          try {
            resolve(onRejected(err));
          } catch (error) {
            reject(error);
          }
        } : reject);
      });
    });
    changeState.promise = p;
    return changeState;
  };

  Twig.Promise.defaultResolved = new Twig.Thenable(Twig.Thenable.resolvedThen, undefined, STATE_RESOLVED);
  Twig.Promise.emptyStringResolved = new Twig.Thenable(Twig.Thenable.resolvedThen, '', STATE_RESOLVED);

  Twig.Promise.resolve = function (value) {
    if (arguments.length === 0 || typeof value === 'undefined') {
      return Twig.Promise.defaultResolved;
    }

    if (Twig.isPromise(value)) {
      return value;
    } // Twig often resolves with an empty string, we optimize for this
    // scenario by returning a fixed promise. This reduces the load on
    // garbage collection.


    if (value === '') {
      return Twig.Promise.emptyStringResolved;
    }

    return new Twig.Thenable(Twig.Thenable.resolvedThen, value, STATE_RESOLVED);
  };

  Twig.Promise.reject = function (e) {
    // `e` should never be a promise.
    return new Twig.Thenable(Twig.Thenable.rejectedThen, e, STATE_REJECTED);
  };

  Twig.Promise.all = function (promises) {
    var results = new Array(promises.length);
    return Twig.async.forEach(promises, function (p, index) {
      if (!Twig.isPromise(p)) {
        results[index] = p;
        return;
      }

      if (p._state === STATE_RESOLVED) {
        results[index] = p._value;
        return;
      }

      return p.then(function (v) {
        results[index] = v;
      });
    }).then(function () {
      return results;
    });
  };
  /**
  * Go over each item in a fashion compatible with Twig.forEach,
  * allow the function to return a promise or call the third argument
  * to signal it is finished.
  *
  * Each item in the array will be called sequentially.
  */


  Twig.async.forEach = function (arr, callback) {
    var len = arr.length;
    var index = 0;

    function next() {
      var resp = null;

      do {
        if (index === len) {
          return Twig.Promise.resolve();
        }

        resp = callback(arr[index], index);
        index++; // While the result of the callback is not a promise or it is
        // a promise that has settled we can use a regular loop which
        // is much faster.
      } while (!resp || !Twig.isPromise(resp) || resp._state === STATE_RESOLVED);

      return resp.then(next);
    }

    return next();
  };

  return Twig;
};

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// ## twig.exports.js
//
// This file provides extension points and other hooks into the twig functionality.
module.exports = function (Twig) {
  'use strict';

  Twig.exports = {
    VERSION: Twig.VERSION
  };
  /**
   * Create and compile a twig.js template.
   *
   * @param {Object} param Paramteres for creating a Twig template.
   *
   * @return {Twig.Template} A Twig template ready for rendering.
   */

  Twig.exports.twig = function (params) {
    'use strict';

    var id = params.id;
    var options = {
      strictVariables: params.strict_variables || false,
      // TODO: turn autoscape on in the next major version
      autoescape: params.autoescape !== null && params.autoescape || false,
      allowInlineIncludes: params.allowInlineIncludes || false,
      rethrow: params.rethrow || false,
      namespaces: params.namespaces
    };

    if (Twig.cache && id) {
      Twig.validateId(id);
    }

    if (params.debug !== undefined) {
      Twig.debug = params.debug;
    }

    if (params.trace !== undefined) {
      Twig.trace = params.trace;
    }

    if (params.data !== undefined) {
      return Twig.Templates.parsers.twig({
        data: params.data,
        path: Object.hasOwnProperty.call(params, 'path') ? params.path : undefined,
        module: params.module,
        id: id,
        options: options
      });
    }

    if (params.ref !== undefined) {
      if (params.id !== undefined) {
        throw new Twig.Error('Both ref and id cannot be set on a twig.js template.');
      }

      return Twig.Templates.load(params.ref);
    }

    if (params.method !== undefined) {
      if (!Twig.Templates.isRegisteredLoader(params.method)) {
        throw new Twig.Error('Loader for "' + params.method + '" is not defined.');
      }

      return Twig.Templates.loadRemote(params.name || params.href || params.path || id || undefined, {
        id: id,
        method: params.method,
        parser: params.parser || 'twig',
        base: params.base,
        module: params.module,
        precompiled: params.precompiled,
        async: params.async,
        options: options
      }, params.load, params.error);
    }

    if (params.href !== undefined) {
      return Twig.Templates.loadRemote(params.href, {
        id: id,
        method: 'ajax',
        parser: params.parser || 'twig',
        base: params.base,
        module: params.module,
        precompiled: params.precompiled,
        async: params.async,
        options: options
      }, params.load, params.error);
    }

    if (params.path !== undefined) {
      return Twig.Templates.loadRemote(params.path, {
        id: id,
        method: 'fs',
        parser: params.parser || 'twig',
        base: params.base,
        module: params.module,
        precompiled: params.precompiled,
        async: params.async,
        options: options
      }, params.load, params.error);
    }
  }; // Extend Twig with a new filter.


  Twig.exports.extendFilter = function (filter, definition) {
    Twig.filter.extend(filter, definition);
  }; // Extend Twig with a new function.


  Twig.exports.extendFunction = function (fn, definition) {
    Twig._function.extend(fn, definition);
  }; // Extend Twig with a new test.


  Twig.exports.extendTest = function (test, definition) {
    Twig.test.extend(test, definition);
  }; // Extend Twig with a new definition.


  Twig.exports.extendTag = function (definition) {
    Twig.logic.extend(definition);
  }; // Provide an environment for extending Twig core.
  // Calls fn with the internal Twig object.


  Twig.exports.extend = function (fn) {
    fn(Twig);
  };
  /**
   * Provide an extension for use with express 2.
   *
   * @param {string} markup The template markup.
   * @param {array} options The express options.
   *
   * @return {string} The rendered template.
   */


  Twig.exports.compile = function (markup, options) {
    var id = options.filename;
    var path = options.filename; // Try to load the template from the cache

    var template = new Twig.Template({
      data: markup,
      path: path,
      id: id,
      options: options.settings['twig options']
    }); // Twig.Templates.load(id) ||

    return function (context) {
      return template.render(context);
    };
  };
  /**
   * Provide an extension for use with express 3.
   *
   * @param {string} path The location of the template file on disk.
   * @param {Object|Function} The options or callback.
   * @param {Function} fn callback.
   *
   * @throws Twig.Error
   */


  Twig.exports.renderFile = function (path, options, fn) {
    // Handle callback in options
    if (typeof options === 'function') {
      fn = options;
      options = {};
    }

    options = options || {};
    var settings = options.settings || {}; // Mixin any options provided to the express app.

    var viewOptions = settings['twig options'];
    var params = {
      path: path,
      base: settings.views,
      load: function load(template) {
        // Render and return template as a simple string, see https://github.com/twigjs/twig.js/pull/348 for more information
        if (!viewOptions || !viewOptions.allowAsync) {
          fn(null, String(template.render(options)));
          return;
        }

        template.renderAsync(options).then(function (out) {
          return fn(null, out);
        }, fn);
      }
    };

    if (viewOptions) {
      for (var option in viewOptions) {
        if (Object.hasOwnProperty.call(viewOptions, option)) {
          params[option] = viewOptions[option];
        }
      }
    }

    Twig.exports.twig(params);
  }; // Express 3 handler


  Twig.exports.__express = Twig.exports.renderFile;
  /**
   * Shoud Twig.js cache templates.
   * Disable during development to see changes to templates without
   * reloading, and disable in production to improve performance.
   *
   * @param {boolean} cache
   */

  Twig.exports.cache = function (cache) {
    Twig.cache = cache;
  }; // We need to export the path module so we can effectively test it


  Twig.exports.path = Twig.path; // Export our filters.
  // Resolves #307

  Twig.exports.filters = Twig.filters; // Export our tests.

  Twig.exports.tests = Twig.tests;
  Twig.exports.Promise = Twig.Promise;
  return Twig;
};

/***/ })
/******/ ]);
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ 19:
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R3aWcvdHdpZy5qcyIsIndlYnBhY2s6Ly8vZnMgKGlnbm9yZWQpIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE1BQU07QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsOEJBQThCO0FBQ2xFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxvQkFBb0I7QUFDOUI7QUFDQTs7QUFFQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN1NBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7Ozs7Ozs7Ozs7OztBQ3ZMdEM7QUFDQSxJQUFJLElBQXlEO0FBQzdEO0FBQ0EsTUFBTSxFQUtxQjtBQUMzQixDQUFDO0FBQ0Qsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdDQUFnQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usa0JBQWtCO0FBQ2xGO0FBQ0EseURBQXlELGNBQWM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUNBQWlDO0FBQ2xGLHdIQUF3SCxtQkFBbUIsRUFBRTtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMEJBQTBCLEVBQUU7QUFDL0QseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwrREFBK0Q7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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aURBQWlELGdCQUFnQjtBQUNqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7OztBQUdBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYOzs7QUFHQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDaEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSwrQ0FBK0MsS0FBSztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5RUFBeUUsYUFBYTtBQUN0RjtBQUNBOztBQUVBO0FBQ0E7QUFD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TDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBLG9HQUFvRyxtQkFBbUIsRUFBRSxtQkFBbUIsOEhBQThIOztBQUUxUTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQSxvR0FBb0csbUJBQW1CLEVBQUUsbUJBQW1CLDhIQUE4SDs7QUFFMVE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLElBQUk7QUFDekIsc0JBQXNCLEVBQUU7QUFDeEIsc0JBQXNCLEVBQUU7QUFDeEIsbUNBQW1DLEVBQUU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixJQUFJLElBQUksSUFBSSxHQUFHLElBQUk7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RCxJQUFJO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLElBQUk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQ0FBcUMsT0FBTztBQUM1Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0Qzs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLEVBQUU7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyxZQUFJOztBQUU3QixPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUEsMENBQTBDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELDhEQUE4RCxnRUFBZ0UsRUFBRSxFQUFFLGdDQUFnQyxFQUFFLGFBQWE7O0FBRW5WLGdDQUFnQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEsdURBQXVELDREQUE0RCxFQUFFLEVBQUUsRUFBRSw2Q0FBNkMsMkVBQTJFLEVBQUUsT0FBTyxpREFBaUQsa0ZBQWtGLEVBQUUsRUFBRSxFQUFFLEVBQUUsZUFBZTs7QUFFcmlCO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVSxrQ0FBa0MsV0FBVztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxRQUFROztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBLDJDQUEyQzs7QUFFM0M7O0FBRUE7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFF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QSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEIsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4QkFBOEI7QUFDOUIsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxjQUFjLGNBQWM7QUFDNUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCOzs7QUFHQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSixnQ0FBZ0M7QUFDaEM7O0FBRUEsc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxDQUFDLEU7Ozs7Ozs7Ozs7OztBQ3ovUkQsZSIsImZpbGUiOiJ0d2lnL3R3aWcubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gLmRpcm5hbWUsIC5iYXNlbmFtZSwgYW5kIC5leHRuYW1lIG1ldGhvZHMgYXJlIGV4dHJhY3RlZCBmcm9tIE5vZGUuanMgdjguMTEuMSxcbi8vIGJhY2twb3J0ZWQgYW5kIHRyYW5zcGxpdGVkIHdpdGggQmFiZWwsIHdpdGggYmFja3dhcmRzLWNvbXBhdCBmaXhlc1xuXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbiAocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuICBpZiAocGF0aC5sZW5ndGggPT09IDApIHJldHVybiAnLic7XG4gIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDApO1xuICB2YXIgaGFzUm9vdCA9IGNvZGUgPT09IDQ3IC8qLyovO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDE7IC0taSkge1xuICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yXG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgcmV0dXJuIGhhc1Jvb3QgPyAnLycgOiAnLic7XG4gIGlmIChoYXNSb290ICYmIGVuZCA9PT0gMSkge1xuICAgIC8vIHJldHVybiAnLy8nO1xuICAgIC8vIEJhY2t3YXJkcy1jb21wYXQgZml4OlxuICAgIHJldHVybiAnLyc7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2UoMCwgZW5kKTtcbn07XG5cbmZ1bmN0aW9uIGJhc2VuYW1lKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcblxuICB2YXIgc3RhcnQgPSAwO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICB2YXIgaTtcblxuICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgaWYgKHBhdGguY2hhckNvZGVBdChpKSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAvLyBwYXRoIGNvbXBvbmVudFxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICBlbmQgPSBpICsgMTtcbiAgICB9XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgcmV0dXJuICcnO1xuICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcbn1cblxuLy8gVXNlcyBhIG1peGVkIGFwcHJvYWNoIGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSwgYXMgZXh0IGJlaGF2aW9yIGNoYW5nZWRcbi8vIGluIG5ldyBOb2RlLmpzIHZlcnNpb25zLCBzbyBvbmx5IGJhc2VuYW1lKCkgYWJvdmUgaXMgYmFja3BvcnRlZCBoZXJlXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24gKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IGJhc2VuYW1lKHBhdGgpO1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcbiAgdmFyIHN0YXJ0RG90ID0gLTE7XG4gIHZhciBzdGFydFBhcnQgPSAwO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAvLyBUcmFjayB0aGUgc3RhdGUgb2YgY2hhcmFjdGVycyAoaWYgYW55KSB3ZSBzZWUgYmVmb3JlIG91ciBmaXJzdCBkb3QgYW5kXG4gIC8vIGFmdGVyIGFueSBwYXRoIHNlcGFyYXRvciB3ZSBmaW5kXG4gIHZhciBwcmVEb3RTdGF0ZSA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAvLyBleHRlbnNpb25cbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgZW5kID0gaSArIDE7XG4gICAgfVxuICAgIGlmIChjb2RlID09PSA0NiAvKi4qLykge1xuICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cbiAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSlcbiAgICAgICAgICBzdGFydERvdCA9IGk7XG4gICAgICAgIGVsc2UgaWYgKHByZURvdFN0YXRlICE9PSAxKVxuICAgICAgICAgIHByZURvdFN0YXRlID0gMTtcbiAgICB9IGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcbiAgICAgIC8vIGhhdmUgYSBnb29kIGNoYW5jZSBhdCBoYXZpbmcgYSBub24tZW1wdHkgZXh0ZW5zaW9uXG4gICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGFydERvdCA9PT0gLTEgfHwgZW5kID09PSAtMSB8fFxuICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3RcbiAgICAgIHByZURvdFN0YXRlID09PSAwIHx8XG4gICAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXG4gICAgICBwcmVEb3RTdGF0ZSA9PT0gMSAmJiBzdGFydERvdCA9PT0gZW5kIC0gMSAmJiBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gcGF0aC5zbGljZShzdGFydERvdCwgZW5kKTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJUd2lnXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlR3aWdcIl0gPSBmYWN0b3J5KCk7XG59KShnbG9iYWwsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNSk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgXCJkZWZhdWx0XCI6IG9ialxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQ7XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHk7XG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNwcmludGYoKSB7XG4gIC8vICBkaXNjdXNzIGF0OiBodHRwOi8vbG9jdXR1cy5pby9waHAvc3ByaW50Zi9cbiAgLy8gb3JpZ2luYWwgYnk6IEFzaCBTZWFybGUgKGh0dHA6Ly9oZXhtZW4uY29tL2Jsb2cvKVxuICAvLyBpbXByb3ZlZCBieTogTWljaGFlbCBXaGl0ZSAoaHR0cDovL2dldHNwcmluay5jb20pXG4gIC8vIGltcHJvdmVkIGJ5OiBKYWNrXG4gIC8vIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va3Z6LmlvKVxuICAvLyBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2t2ei5pbylcbiAgLy8gaW1wcm92ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rdnouaW8pXG4gIC8vIGltcHJvdmVkIGJ5OiBEalxuICAvLyBpbXByb3ZlZCBieTogQWxsaWR5bGxzXG4gIC8vICAgIGlucHV0IGJ5OiBQYXVsbyBGcmVpdGFzXG4gIC8vICAgIGlucHV0IGJ5OiBCcmV0dCBaYW1pciAoaHR0cDovL2JyZXR0LXphbWlyLm1lKVxuICAvLyBpbXByb3ZlZCBieTogUmFmYcWCIEt1a2F3c2tpIChodHRwOi8va3VrYXdza2kucGwpXG4gIC8vICAgZXhhbXBsZSAxOiBzcHJpbnRmKFwiJTAxLjJmXCIsIDEyMy4xKVxuICAvLyAgIHJldHVybnMgMTogJzEyMy4xMCdcbiAgLy8gICBleGFtcGxlIDI6IHNwcmludGYoXCJbJTEwc11cIiwgJ21vbmtleScpXG4gIC8vICAgcmV0dXJucyAyOiAnWyAgICBtb25rZXldJ1xuICAvLyAgIGV4YW1wbGUgMzogc3ByaW50ZihcIlslJyMxMHNdXCIsICdtb25rZXknKVxuICAvLyAgIHJldHVybnMgMzogJ1sjIyMjbW9ua2V5XSdcbiAgLy8gICBleGFtcGxlIDQ6IHNwcmludGYoXCIlZFwiLCAxMjM0NTY3ODkwMTIzNDUpXG4gIC8vICAgcmV0dXJucyA0OiAnMTIzNDU2Nzg5MDEyMzQ1J1xuICAvLyAgIGV4YW1wbGUgNTogc3ByaW50ZignJS0wM3MnLCAnRScpXG4gIC8vICAgcmV0dXJucyA1OiAnRTAwJ1xuICAvLyAgIGV4YW1wbGUgNjogc3ByaW50ZignJSswMTBkJywgOSlcbiAgLy8gICByZXR1cm5zIDY6ICcrMDAwMDAwMDA5J1xuICAvLyAgIGV4YW1wbGUgNzogc3ByaW50ZignJSswXFwnQDEwZCcsIDkpXG4gIC8vICAgcmV0dXJucyA3OiAnQEBAQEBAQEArOSdcbiAgLy8gICBleGFtcGxlIDg6IHNwcmludGYoJyUuZicsIDMuMTQpXG4gIC8vICAgcmV0dXJucyA4OiAnMy4xNDAwMDAnXG4gIC8vICAgZXhhbXBsZSA5OiBzcHJpbnRmKCclJSAlMiRkJywgMSwgMilcbiAgLy8gICByZXR1cm5zIDk6ICclIDInXG5cbiAgdmFyIHJlZ2V4ID0gLyUlfCUoPzooXFxkKylcXCQpPygoPzpbLSsjMCBdfCdbXFxzXFxTXSkqKShcXGQrKT8oPzpcXC4oXFxkKikpPyhbXFxzXFxTXSkvZztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBpID0gMDtcbiAgdmFyIGZvcm1hdCA9IGFyZ3NbaSsrXTtcblxuICB2YXIgX3BhZCA9IGZ1bmN0aW9uIF9wYWQoc3RyLCBsZW4sIGNociwgbGVmdEp1c3RpZnkpIHtcbiAgICBpZiAoIWNocikge1xuICAgICAgY2hyID0gJyAnO1xuICAgIH1cbiAgICB2YXIgcGFkZGluZyA9IHN0ci5sZW5ndGggPj0gbGVuID8gJycgOiBuZXcgQXJyYXkoMSArIGxlbiAtIHN0ci5sZW5ndGggPj4+IDApLmpvaW4oY2hyKTtcbiAgICByZXR1cm4gbGVmdEp1c3RpZnkgPyBzdHIgKyBwYWRkaW5nIDogcGFkZGluZyArIHN0cjtcbiAgfTtcblxuICB2YXIganVzdGlmeSA9IGZ1bmN0aW9uIGp1c3RpZnkodmFsdWUsIHByZWZpeCwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCBwYWRDaGFyKSB7XG4gICAgdmFyIGRpZmYgPSBtaW5XaWR0aCAtIHZhbHVlLmxlbmd0aDtcbiAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgIC8vIHdoZW4gcGFkZGluZyB3aXRoIHplcm9zXG4gICAgICAvLyBvbiB0aGUgbGVmdCBzaWRlXG4gICAgICAvLyBrZWVwIHNpZ24gKCsgb3IgLSkgaW4gZnJvbnRcbiAgICAgIGlmICghbGVmdEp1c3RpZnkgJiYgcGFkQ2hhciA9PT0gJzAnKSB7XG4gICAgICAgIHZhbHVlID0gW3ZhbHVlLnNsaWNlKDAsIHByZWZpeC5sZW5ndGgpLCBfcGFkKCcnLCBkaWZmLCAnMCcsIHRydWUpLCB2YWx1ZS5zbGljZShwcmVmaXgubGVuZ3RoKV0uam9pbignJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IF9wYWQodmFsdWUsIG1pbldpZHRoLCBwYWRDaGFyLCBsZWZ0SnVzdGlmeSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICB2YXIgX2Zvcm1hdEJhc2VYID0gZnVuY3Rpb24gX2Zvcm1hdEJhc2VYKHZhbHVlLCBiYXNlLCBsZWZ0SnVzdGlmeSwgbWluV2lkdGgsIHByZWNpc2lvbiwgcGFkQ2hhcikge1xuICAgIC8vIE5vdGU6IGNhc3RzIG5lZ2F0aXZlIG51bWJlcnMgdG8gcG9zaXRpdmUgb25lc1xuICAgIHZhciBudW1iZXIgPSB2YWx1ZSA+Pj4gMDtcbiAgICB2YWx1ZSA9IF9wYWQobnVtYmVyLnRvU3RyaW5nKGJhc2UpLCBwcmVjaXNpb24gfHwgMCwgJzAnLCBmYWxzZSk7XG4gICAgcmV0dXJuIGp1c3RpZnkodmFsdWUsICcnLCBsZWZ0SnVzdGlmeSwgbWluV2lkdGgsIHBhZENoYXIpO1xuICB9O1xuXG4gIC8vIF9mb3JtYXRTdHJpbmcoKVxuICB2YXIgX2Zvcm1hdFN0cmluZyA9IGZ1bmN0aW9uIF9mb3JtYXRTdHJpbmcodmFsdWUsIGxlZnRKdXN0aWZ5LCBtaW5XaWR0aCwgcHJlY2lzaW9uLCBjdXN0b21QYWRDaGFyKSB7XG4gICAgaWYgKHByZWNpc2lvbiAhPT0gbnVsbCAmJiBwcmVjaXNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBwcmVjaXNpb24pO1xuICAgIH1cbiAgICByZXR1cm4ganVzdGlmeSh2YWx1ZSwgJycsIGxlZnRKdXN0aWZ5LCBtaW5XaWR0aCwgY3VzdG9tUGFkQ2hhcik7XG4gIH07XG5cbiAgLy8gZG9Gb3JtYXQoKVxuICB2YXIgZG9Gb3JtYXQgPSBmdW5jdGlvbiBkb0Zvcm1hdChzdWJzdHJpbmcsIGFyZ0luZGV4LCBtb2RpZmllcnMsIG1pbldpZHRoLCBwcmVjaXNpb24sIHNwZWNpZmllcikge1xuICAgIHZhciBudW1iZXIsIHByZWZpeCwgbWV0aG9kLCB0ZXh0VHJhbnNmb3JtLCB2YWx1ZTtcblxuICAgIGlmIChzdWJzdHJpbmcgPT09ICclJScpIHtcbiAgICAgIHJldHVybiAnJSc7XG4gICAgfVxuXG4gICAgLy8gcGFyc2UgbW9kaWZpZXJzXG4gICAgdmFyIHBhZENoYXIgPSAnICc7IC8vIHBhZCB3aXRoIHNwYWNlcyBieSBkZWZhdWx0XG4gICAgdmFyIGxlZnRKdXN0aWZ5ID0gZmFsc2U7XG4gICAgdmFyIHBvc2l0aXZlTnVtYmVyUHJlZml4ID0gJyc7XG4gICAgdmFyIGosIGw7XG5cbiAgICBmb3IgKGogPSAwLCBsID0gbW9kaWZpZXJzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgc3dpdGNoIChtb2RpZmllcnMuY2hhckF0KGopKSB7XG4gICAgICAgIGNhc2UgJyAnOlxuICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgICBwYWRDaGFyID0gbW9kaWZpZXJzLmNoYXJBdChqKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgcG9zaXRpdmVOdW1iZXJQcmVmaXggPSAnKyc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgIGxlZnRKdXN0aWZ5ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICBpZiAoaiArIDEgPCBsKSB7XG4gICAgICAgICAgICBwYWRDaGFyID0gbW9kaWZpZXJzLmNoYXJBdChqICsgMSk7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghbWluV2lkdGgpIHtcbiAgICAgIG1pbldpZHRoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWluV2lkdGggPSArbWluV2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKCFpc0Zpbml0ZShtaW5XaWR0aCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2lkdGggbXVzdCBiZSBmaW5pdGUnKTtcbiAgICB9XG5cbiAgICBpZiAoIXByZWNpc2lvbikge1xuICAgICAgcHJlY2lzaW9uID0gc3BlY2lmaWVyID09PSAnZCcgPyAwIDogJ2ZGZUUnLmluZGV4T2Yoc3BlY2lmaWVyKSA+IC0xID8gNiA6IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlY2lzaW9uID0gK3ByZWNpc2lvbjtcbiAgICB9XG5cbiAgICBpZiAoYXJnSW5kZXggJiYgK2FyZ0luZGV4ID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IG51bWJlciBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvJyk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ0luZGV4ICYmICthcmdJbmRleCA+PSBhcmdzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb28gZmV3IGFyZ3VtZW50cycpO1xuICAgIH1cblxuICAgIHZhbHVlID0gYXJnSW5kZXggPyBhcmdzWythcmdJbmRleF0gOiBhcmdzW2krK107XG5cbiAgICBzd2l0Y2ggKHNwZWNpZmllcikge1xuICAgICAgY2FzZSAnJSc6XG4gICAgICAgIHJldHVybiAnJSc7XG4gICAgICBjYXNlICdzJzpcbiAgICAgICAgcmV0dXJuIF9mb3JtYXRTdHJpbmcodmFsdWUgKyAnJywgbGVmdEp1c3RpZnksIG1pbldpZHRoLCBwcmVjaXNpb24sIHBhZENoYXIpO1xuICAgICAgY2FzZSAnYyc6XG4gICAgICAgIHJldHVybiBfZm9ybWF0U3RyaW5nKFN0cmluZy5mcm9tQ2hhckNvZGUoK3ZhbHVlKSwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCBwcmVjaXNpb24sIHBhZENoYXIpO1xuICAgICAgY2FzZSAnYic6XG4gICAgICAgIHJldHVybiBfZm9ybWF0QmFzZVgodmFsdWUsIDIsIGxlZnRKdXN0aWZ5LCBtaW5XaWR0aCwgcHJlY2lzaW9uLCBwYWRDaGFyKTtcbiAgICAgIGNhc2UgJ28nOlxuICAgICAgICByZXR1cm4gX2Zvcm1hdEJhc2VYKHZhbHVlLCA4LCBsZWZ0SnVzdGlmeSwgbWluV2lkdGgsIHByZWNpc2lvbiwgcGFkQ2hhcik7XG4gICAgICBjYXNlICd4JzpcbiAgICAgICAgcmV0dXJuIF9mb3JtYXRCYXNlWCh2YWx1ZSwgMTYsIGxlZnRKdXN0aWZ5LCBtaW5XaWR0aCwgcHJlY2lzaW9uLCBwYWRDaGFyKTtcbiAgICAgIGNhc2UgJ1gnOlxuICAgICAgICByZXR1cm4gX2Zvcm1hdEJhc2VYKHZhbHVlLCAxNiwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCBwcmVjaXNpb24sIHBhZENoYXIpLnRvVXBwZXJDYXNlKCk7XG4gICAgICBjYXNlICd1JzpcbiAgICAgICAgcmV0dXJuIF9mb3JtYXRCYXNlWCh2YWx1ZSwgMTAsIGxlZnRKdXN0aWZ5LCBtaW5XaWR0aCwgcHJlY2lzaW9uLCBwYWRDaGFyKTtcbiAgICAgIGNhc2UgJ2knOlxuICAgICAgY2FzZSAnZCc6XG4gICAgICAgIG51bWJlciA9ICt2YWx1ZSB8fCAwO1xuICAgICAgICAvLyBQbGFpbiBNYXRoLnJvdW5kIGRvZXNuJ3QganVzdCB0cnVuY2F0ZVxuICAgICAgICBudW1iZXIgPSBNYXRoLnJvdW5kKG51bWJlciAtIG51bWJlciAlIDEpO1xuICAgICAgICBwcmVmaXggPSBudW1iZXIgPCAwID8gJy0nIDogcG9zaXRpdmVOdW1iZXJQcmVmaXg7XG4gICAgICAgIHZhbHVlID0gcHJlZml4ICsgX3BhZChTdHJpbmcoTWF0aC5hYnMobnVtYmVyKSksIHByZWNpc2lvbiwgJzAnLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKGxlZnRKdXN0aWZ5ICYmIHBhZENoYXIgPT09ICcwJykge1xuICAgICAgICAgIC8vIGNhbid0IHJpZ2h0LXBhZCAwcyBvbiBpbnRlZ2Vyc1xuICAgICAgICAgIHBhZENoYXIgPSAnICc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGp1c3RpZnkodmFsdWUsIHByZWZpeCwgbGVmdEp1c3RpZnksIG1pbldpZHRoLCBwYWRDaGFyKTtcbiAgICAgIGNhc2UgJ2UnOlxuICAgICAgY2FzZSAnRSc6XG4gICAgICBjYXNlICdmJzogLy8gQHRvZG86IFNob3VsZCBoYW5kbGUgbG9jYWxlcyAoYXMgcGVyIHNldGxvY2FsZSlcbiAgICAgIGNhc2UgJ0YnOlxuICAgICAgY2FzZSAnZyc6XG4gICAgICBjYXNlICdHJzpcbiAgICAgICAgbnVtYmVyID0gK3ZhbHVlO1xuICAgICAgICBwcmVmaXggPSBudW1iZXIgPCAwID8gJy0nIDogcG9zaXRpdmVOdW1iZXJQcmVmaXg7XG4gICAgICAgIG1ldGhvZCA9IFsndG9FeHBvbmVudGlhbCcsICd0b0ZpeGVkJywgJ3RvUHJlY2lzaW9uJ11bJ2VmZycuaW5kZXhPZihzcGVjaWZpZXIudG9Mb3dlckNhc2UoKSldO1xuICAgICAgICB0ZXh0VHJhbnNmb3JtID0gWyd0b1N0cmluZycsICd0b1VwcGVyQ2FzZSddWydlRWZGZ0cnLmluZGV4T2Yoc3BlY2lmaWVyKSAlIDJdO1xuICAgICAgICB2YWx1ZSA9IHByZWZpeCArIE1hdGguYWJzKG51bWJlcilbbWV0aG9kXShwcmVjaXNpb24pO1xuICAgICAgICByZXR1cm4ganVzdGlmeSh2YWx1ZSwgcHJlZml4LCBsZWZ0SnVzdGlmeSwgbWluV2lkdGgsIHBhZENoYXIpW3RleHRUcmFuc2Zvcm1dKCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyB1bmtub3duIHNwZWNpZmllciwgY29uc3VtZSB0aGF0IGNoYXIgYW5kIHJldHVybiBlbXB0eVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9O1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGZvcm1hdC5yZXBsYWNlKHJlZ2V4LCBkb0Zvcm1hdCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwcmludGYuanMubWFwXG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBUd2lnLmpzXG4gKlxuICogQGNvcHlyaWdodCAyMDExLTIwMjAgSm9obiBSb2Vwa2UgYW5kIHRoZSBUd2lnLmpzIENvbnRyaWJ1dG9yc1xuICogQGxpY2Vuc2UgICBBdmFpbGFibGUgdW5kZXIgdGhlIEJTRCAyLUNsYXVzZSBMaWNlbnNlXG4gKiBAbGluayAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS90d2lnanMvdHdpZy5qc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNikoKTtcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8vICMjIHR3aWcuZmFjdG9yeS5qc1xuLy9cbi8vIFRoaXMgZmlsZSBoYW5kbGVzIGNyZWF0aW5nIHRoZSBUd2lnIGxpYnJhcnlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmFjdG9yeSgpIHtcbiAgdmFyIFR3aWcgPSB7XG4gICAgVkVSU0lPTjogJzEuMTQuMCdcbiAgfTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpKFR3aWcpO1xuXG4gIF9fd2VicGFja19yZXF1aXJlX18oOCkoVHdpZyk7XG5cbiAgX193ZWJwYWNrX3JlcXVpcmVfXyg5KShUd2lnKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KShUd2lnKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KShUd2lnKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KShUd2lnKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KShUd2lnKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KShUd2lnKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKShUd2lnKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKShUd2lnKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKShUd2lnKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKShUd2lnKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KShUd2lnKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KShUd2lnKTtcblxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KShUd2lnKTtcblxuICBUd2lnLmV4cG9ydHMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4gIHJldHVybiBUd2lnLmV4cG9ydHM7XG59O1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyW1wiZGVmYXVsdFwiXSkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuLy8gIyMgdHdpZy5jb3JlLmpzXG4vL1xuLy8gVGhpcyBmaWxlIGhhbmRsZXMgdGVtcGxhdGUgbGV2ZWwgdG9rZW5pemluZywgY29tcGlsaW5nIGFuZCBwYXJzaW5nLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVHdpZykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgVHdpZy50cmFjZSA9IGZhbHNlO1xuICBUd2lnLmRlYnVnID0gZmFsc2U7IC8vIERlZmF1bHQgY2FjaGluZyB0byB0cnVlIGZvciB0aGUgaW1wcm92ZWQgcGVyZm9ybWFuY2UgaXQgb2ZmZXJzXG5cbiAgVHdpZy5jYWNoZSA9IHRydWU7XG5cbiAgVHdpZy5ub29wID0gZnVuY3Rpb24gKCkge307XG5cbiAgVHdpZy5tZXJnZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgb25seUNoYW5nZWQpIHtcbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKG9ubHlDaGFuZ2VkICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIC8qKlxuICAgKiBFeGNlcHRpb24gdGhyb3duIGJ5IHR3aWcuanMuXG4gICAqL1xuXG5cbiAgVHdpZy5FcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBmaWxlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLm5hbWUgPSAnVHdpZ0V4Y2VwdGlvbic7XG4gICAgdGhpcy50eXBlID0gJ1R3aWdFeGNlcHRpb24nO1xuICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gIH07XG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIFR3aWcgZXJyb3IuXG4gICAqL1xuXG5cbiAgVHdpZy5FcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG91dHB1dCA9IHRoaXMubmFtZSArICc6ICcgKyB0aGlzLm1lc3NhZ2U7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcbiAgLyoqXG4gICAqIFdyYXBwZXIgZm9yIGxvZ2dpbmcgdG8gdGhlIGNvbnNvbGUuXG4gICAqL1xuXG5cbiAgVHdpZy5sb2cgPSB7XG4gICAgdHJhY2U6IGZ1bmN0aW9uIHRyYWNlKCkge1xuICAgICAgaWYgKFR3aWcudHJhY2UgJiYgY29uc29sZSkge1xuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVidWc6IGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgICAgaWYgKFR3aWcuZGVidWcgJiYgY29uc29sZSkge1xuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZyhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGlmICh0eXBlb2YgY29uc29sZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBUd2lnLmxvZy5lcnJvciA9IGZ1bmN0aW9uICgpIHt9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb25zb2xlLmVycm9yICE9PSAndW5kZWZpbmVkJykge1xuICAgIFR3aWcubG9nLmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jb25zb2xlO1xuXG4gICAgICAoX2NvbnNvbGUgPSBjb25zb2xlKS5lcnJvci5hcHBseShfY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb25zb2xlLmxvZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBUd2lnLmxvZy5lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfY29uc29sZTI7XG5cbiAgICAgIChfY29uc29sZTIgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGUyLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENvbnRhaW5lciBmb3IgbWV0aG9kcyByZWxhdGVkIHRvIGhhbmRsaW5nIGhpZ2ggbGV2ZWwgdGVtcGxhdGUgdG9rZW5zXG4gICAqICAgICAgKGZvciBleGFtcGxlOiB7eyBleHByZXNzaW9uIH19LCB7JSBsb2dpYyAlfSwgeyMgY29tbWVudCAjfSwgcmF3IGRhdGEpXG4gICAqL1xuXG5cbiAgVHdpZy50b2tlbiA9IHt9O1xuICAvKipcbiAgICogVG9rZW4gdHlwZXMuXG4gICAqL1xuXG4gIFR3aWcudG9rZW4udHlwZSA9IHtcbiAgICBvdXRwdXQ6ICdvdXRwdXQnLFxuICAgIGxvZ2ljOiAnbG9naWMnLFxuICAgIGNvbW1lbnQ6ICdjb21tZW50JyxcbiAgICByYXc6ICdyYXcnLFxuICAgIG91dHB1dFdoaXRlc3BhY2VQcmU6ICdvdXRwdXRfd2hpdGVzcGFjZV9wcmUnLFxuICAgIG91dHB1dFdoaXRlc3BhY2VQb3N0OiAnb3V0cHV0X3doaXRlc3BhY2VfcG9zdCcsXG4gICAgb3V0cHV0V2hpdGVzcGFjZUJvdGg6ICdvdXRwdXRfd2hpdGVzcGFjZV9ib3RoJyxcbiAgICBsb2dpY1doaXRlc3BhY2VQcmU6ICdsb2dpY193aGl0ZXNwYWNlX3ByZScsXG4gICAgbG9naWNXaGl0ZXNwYWNlUG9zdDogJ2xvZ2ljX3doaXRlc3BhY2VfcG9zdCcsXG4gICAgbG9naWNXaGl0ZXNwYWNlQm90aDogJ2xvZ2ljX3doaXRlc3BhY2VfYm90aCdcbiAgfTtcbiAgLyoqXG4gICAqIFRva2VuIHN5bnRheCBkZWZpbml0aW9ucy5cbiAgICovXG5cbiAgVHdpZy50b2tlbi5kZWZpbml0aW9ucyA9IFt7XG4gICAgdHlwZTogVHdpZy50b2tlbi50eXBlLnJhdyxcbiAgICBvcGVuOiAneyUgcmF3ICV9JyxcbiAgICBjbG9zZTogJ3slIGVuZHJhdyAlfSdcbiAgfSwge1xuICAgIHR5cGU6IFR3aWcudG9rZW4udHlwZS5yYXcsXG4gICAgb3BlbjogJ3slIHZlcmJhdGltICV9JyxcbiAgICBjbG9zZTogJ3slIGVuZHZlcmJhdGltICV9J1xuICB9LCAvLyAqV2hpdGVzcGFjZSB0eXBlIHRva2VucypcbiAgLy9cbiAgLy8gVGhlc2UgdHlwaWNhbGx5IHRha2UgdGhlIGZvcm0gYHt7LSBleHByZXNzaW9uIC19fWAgb3IgYHt7LSBleHByZXNzaW9uIH19YCBvciBge3sgZXhwcmVzc2lvbiAtfX1gLlxuICB7XG4gICAgdHlwZTogVHdpZy50b2tlbi50eXBlLm91dHB1dFdoaXRlc3BhY2VQcmUsXG4gICAgb3BlbjogJ3t7LScsXG4gICAgY2xvc2U6ICd9fSdcbiAgfSwge1xuICAgIHR5cGU6IFR3aWcudG9rZW4udHlwZS5vdXRwdXRXaGl0ZXNwYWNlUG9zdCxcbiAgICBvcGVuOiAne3snLFxuICAgIGNsb3NlOiAnLX19J1xuICB9LCB7XG4gICAgdHlwZTogVHdpZy50b2tlbi50eXBlLm91dHB1dFdoaXRlc3BhY2VCb3RoLFxuICAgIG9wZW46ICd7ey0nLFxuICAgIGNsb3NlOiAnLX19J1xuICB9LCB7XG4gICAgdHlwZTogVHdpZy50b2tlbi50eXBlLmxvZ2ljV2hpdGVzcGFjZVByZSxcbiAgICBvcGVuOiAneyUtJyxcbiAgICBjbG9zZTogJyV9J1xuICB9LCB7XG4gICAgdHlwZTogVHdpZy50b2tlbi50eXBlLmxvZ2ljV2hpdGVzcGFjZVBvc3QsXG4gICAgb3BlbjogJ3slJyxcbiAgICBjbG9zZTogJy0lfSdcbiAgfSwge1xuICAgIHR5cGU6IFR3aWcudG9rZW4udHlwZS5sb2dpY1doaXRlc3BhY2VCb3RoLFxuICAgIG9wZW46ICd7JS0nLFxuICAgIGNsb3NlOiAnLSV9J1xuICB9LCAvLyAqT3V0cHV0IHR5cGUgdG9rZW5zKlxuICAvL1xuICAvLyBUaGVzZSB0eXBpY2FsbHkgdGFrZSB0aGUgZm9ybSBge3sgZXhwcmVzc2lvbiB9fWAuXG4gIHtcbiAgICB0eXBlOiBUd2lnLnRva2VuLnR5cGUub3V0cHV0LFxuICAgIG9wZW46ICd7eycsXG4gICAgY2xvc2U6ICd9fSdcbiAgfSwgLy8gKkxvZ2ljIHR5cGUgdG9rZW5zKlxuICAvL1xuICAvLyBUaGVzZSB0eXBpY2FsbHkgdGFrZSBhIGZvcm0gbGlrZSBgeyUgaWYgZXhwcmVzc2lvbiAlfWAgb3IgYHslIGVuZGlmICV9YFxuICB7XG4gICAgdHlwZTogVHdpZy50b2tlbi50eXBlLmxvZ2ljLFxuICAgIG9wZW46ICd7JScsXG4gICAgY2xvc2U6ICclfSdcbiAgfSwgLy8gKkNvbW1lbnQgdHlwZSB0b2tlbnMqXG4gIC8vXG4gIC8vIFRoZXNlIHRha2UgdGhlIGZvcm0gYHsjIGFueXRoaW5nICN9YFxuICB7XG4gICAgdHlwZTogVHdpZy50b2tlbi50eXBlLmNvbW1lbnQsXG4gICAgb3BlbjogJ3sjJyxcbiAgICBjbG9zZTogJyN9J1xuICB9XTtcbiAgLyoqXG4gICAqIFdoYXQgY2hhcmFjdGVycyBzdGFydCBcInN0cmluZ3NcIiBpbiB0b2tlbiBkZWZpbml0aW9ucy4gV2UgbmVlZCB0aGlzIHRvIGlnbm9yZSB0b2tlbiBjbG9zZVxuICAgKiBzdHJpbmdzIGluc2lkZSBhbiBleHByZXNzaW9uLlxuICAgKi9cblxuICBUd2lnLnRva2VuLnN0cmluZ3MgPSBbJ1wiJywgJ1xcJyddO1xuXG4gIFR3aWcudG9rZW4uZmluZFN0YXJ0ID0gZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG4gICAgdmFyIG91dHB1dCA9IHtcbiAgICAgIHBvc2l0aW9uOiBudWxsLFxuICAgICAgZGVmOiBudWxsXG4gICAgfTtcbiAgICB2YXIgY2xvc2VQb3NpdGlvbiA9IG51bGw7XG4gICAgdmFyIGxlbiA9IFR3aWcudG9rZW4uZGVmaW5pdGlvbnMubGVuZ3RoO1xuICAgIHZhciBpO1xuICAgIHZhciB0b2tlblRlbXBsYXRlO1xuICAgIHZhciBmaXJzdEtleVBvc2l0aW9uO1xuICAgIHZhciBjbG9zZUtleVBvc2l0aW9uO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0b2tlblRlbXBsYXRlID0gVHdpZy50b2tlbi5kZWZpbml0aW9uc1tpXTtcbiAgICAgIGZpcnN0S2V5UG9zaXRpb24gPSB0ZW1wbGF0ZS5pbmRleE9mKHRva2VuVGVtcGxhdGUub3Blbik7XG4gICAgICBjbG9zZUtleVBvc2l0aW9uID0gdGVtcGxhdGUuaW5kZXhPZih0b2tlblRlbXBsYXRlLmNsb3NlKTtcbiAgICAgIFR3aWcubG9nLnRyYWNlKCdUd2lnLnRva2VuLmZpbmRTdGFydDogJywgJ1NlYXJjaGluZyBmb3IgJywgdG9rZW5UZW1wbGF0ZS5vcGVuLCAnIGZvdW5kIGF0ICcsIGZpcnN0S2V5UG9zaXRpb24pOyAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBtaXNtYXRjaGVkIHRva2Vuc1xuXG4gICAgICBpZiAoZmlyc3RLZXlQb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgIC8vIFRoaXMgdG9rZW4gbWF0Y2hlcyB0aGUgdGVtcGxhdGVcbiAgICAgICAgaWYgKHRva2VuVGVtcGxhdGUub3Blbi5sZW5ndGggIT09IHRva2VuVGVtcGxhdGUuY2xvc2UubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gVGhpcyB0b2tlbiBoYXMgbWlzbWF0Y2hlZCBjbG9zaW5nIGFuZCBvcGVuaW5nIHRhZ3NcbiAgICAgICAgICBpZiAoY2xvc2VLZXlQb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICAgIC8vIFRoaXMgdG9rZW4ncyBjbG9zaW5nIHRhZyBkb2VzIG5vdCBtYXRjaCB0aGUgdGVtcGxhdGVcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBEb2VzIHRoaXMgdG9rZW4gb2NjdXIgYmVmb3JlIGFueSBvdGhlciB0eXBlcz9cblxuXG4gICAgICBpZiAoZmlyc3RLZXlQb3NpdGlvbiA+PSAwICYmIChvdXRwdXQucG9zaXRpb24gPT09IG51bGwgfHwgZmlyc3RLZXlQb3NpdGlvbiA8IG91dHB1dC5wb3NpdGlvbikpIHtcbiAgICAgICAgb3V0cHV0LnBvc2l0aW9uID0gZmlyc3RLZXlQb3NpdGlvbjtcbiAgICAgICAgb3V0cHV0LmRlZiA9IHRva2VuVGVtcGxhdGU7XG4gICAgICAgIGNsb3NlUG9zaXRpb24gPSBjbG9zZUtleVBvc2l0aW9uO1xuICAgICAgfSBlbHNlIGlmIChmaXJzdEtleVBvc2l0aW9uID49IDAgJiYgb3V0cHV0LnBvc2l0aW9uICE9PSBudWxsICYmIGZpcnN0S2V5UG9zaXRpb24gPT09IG91dHB1dC5wb3NpdGlvbikge1xuICAgICAgICAvKiBUaGlzIHRva2VuIGV4YWN0bHkgbWF0Y2hlcyBhbm90aGVyIHRva2VuLFxuICAgICAgICBncmVlZGlseSBtYXRjaCB0byBjaGVjayBpZiB0aGlzIHRva2VuIGhhcyBhIGdyZWF0ZXIgc3BlY2lmaWNpdHkgKi9cbiAgICAgICAgaWYgKHRva2VuVGVtcGxhdGUub3Blbi5sZW5ndGggPiBvdXRwdXQuZGVmLm9wZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gVGhpcyB0b2tlbidzIG9wZW5pbmcgdGFnIGlzIG1vcmUgc3BlY2lmaWMgdGhhbiB0aGUgcHJldmlvdXMgbWF0Y2hcbiAgICAgICAgICBvdXRwdXQucG9zaXRpb24gPSBmaXJzdEtleVBvc2l0aW9uO1xuICAgICAgICAgIG91dHB1dC5kZWYgPSB0b2tlblRlbXBsYXRlO1xuICAgICAgICAgIGNsb3NlUG9zaXRpb24gPSBjbG9zZUtleVBvc2l0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKHRva2VuVGVtcGxhdGUub3Blbi5sZW5ndGggPT09IG91dHB1dC5kZWYub3Blbi5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAodG9rZW5UZW1wbGF0ZS5jbG9zZS5sZW5ndGggPiBvdXRwdXQuZGVmLmNsb3NlLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gVGhpcyB0b2tlbidzIG9wZW5pbmcgdGFnIGlzIGFzIHNwZWNpZmljIGFzIHRoZSBwcmV2aW91cyBtYXRjaCxcbiAgICAgICAgICAgIC8vIGJ1dCB0aGUgY2xvc2luZyB0YWcgaGFzIGdyZWF0ZXIgc3BlY2lmaWNpdHlcbiAgICAgICAgICAgIGlmIChjbG9zZUtleVBvc2l0aW9uID49IDAgJiYgY2xvc2VLZXlQb3NpdGlvbiA8IGNsb3NlUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyB0b2tlbidzIGNsb3NpbmcgdGFnIGV4aXN0cyBpbiB0aGUgdGVtcGxhdGUsXG4gICAgICAgICAgICAgIC8vIGFuZCBpdCBvY2N1cnMgc29vbmVyIHRoYW4gdGhlIHByZXZpb3VzIG1hdGNoXG4gICAgICAgICAgICAgIG91dHB1dC5wb3NpdGlvbiA9IGZpcnN0S2V5UG9zaXRpb247XG4gICAgICAgICAgICAgIG91dHB1dC5kZWYgPSB0b2tlblRlbXBsYXRlO1xuICAgICAgICAgICAgICBjbG9zZVBvc2l0aW9uID0gY2xvc2VLZXlQb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGNsb3NlS2V5UG9zaXRpb24gPj0gMCAmJiBjbG9zZUtleVBvc2l0aW9uIDwgY2xvc2VQb3NpdGlvbikge1xuICAgICAgICAgICAgLy8gVGhpcyB0b2tlbidzIGNsb3NpbmcgdGFnIGlzIG5vdCBtb3JlIHNwZWNpZmljIHRoYW4gdGhlIHByZXZpb3VzIG1hdGNoLFxuICAgICAgICAgICAgLy8gYnV0IGl0IG9jY3VycyBzb29uZXIgdGhhbiB0aGUgcHJldmlvdXMgbWF0Y2hcbiAgICAgICAgICAgIG91dHB1dC5wb3NpdGlvbiA9IGZpcnN0S2V5UG9zaXRpb247XG4gICAgICAgICAgICBvdXRwdXQuZGVmID0gdG9rZW5UZW1wbGF0ZTtcbiAgICAgICAgICAgIGNsb3NlUG9zaXRpb24gPSBjbG9zZUtleVBvc2l0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG5cbiAgVHdpZy50b2tlbi5maW5kRW5kID0gZnVuY3Rpb24gKHRlbXBsYXRlLCB0b2tlbkRlZiwgc3RhcnQpIHtcbiAgICB2YXIgZW5kID0gbnVsbDtcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICB2YXIgb2Zmc2V0ID0gMDsgLy8gU3RyaW5nIHBvc2l0aW9uIHZhcmlhYmxlc1xuXG4gICAgdmFyIHN0clBvcyA9IG51bGw7XG4gICAgdmFyIHN0ckZvdW5kID0gbnVsbDtcbiAgICB2YXIgcG9zID0gbnVsbDtcbiAgICB2YXIgZW5kT2Zmc2V0ID0gbnVsbDtcbiAgICB2YXIgdGhpc1N0clBvcyA9IG51bGw7XG4gICAgdmFyIGVuZFN0clBvcyA9IG51bGw7IC8vIEZvciBsb29wIHZhcmlhYmxlc1xuXG4gICAgdmFyIGk7XG4gICAgdmFyIGw7XG5cbiAgICB3aGlsZSAoIWZvdW5kKSB7XG4gICAgICBzdHJQb3MgPSBudWxsO1xuICAgICAgc3RyRm91bmQgPSBudWxsO1xuICAgICAgcG9zID0gdGVtcGxhdGUuaW5kZXhPZih0b2tlbkRlZi5jbG9zZSwgb2Zmc2V0KTtcblxuICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIGVuZCA9IHBvcztcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhyb3cgYW4gZXhjZXB0aW9uXG4gICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKCdVbmFibGUgdG8gZmluZCBjbG9zaW5nIGJyYWNrZXQgXFwnJyArIHRva2VuRGVmLmNsb3NlICsgJ1xcJyBvcGVuZWQgbmVhciB0ZW1wbGF0ZSBwb3NpdGlvbiAnICsgc3RhcnQpO1xuICAgICAgfSAvLyBJZ25vcmUgcXVvdGVzIHdpdGhpbiBjb21tZW50czsganVzdCBsb29rIGZvciB0aGUgbmV4dCBjb21tZW50IGNsb3NlIHNlcXVlbmNlLFxuICAgICAgLy8gcmVnYXJkbGVzcyBvZiB3aGF0IGNvbWVzIGJlZm9yZSBpdC4gaHR0cHM6Ly9naXRodWIuY29tL2p1c3Rqb2huL3R3aWcuanMvaXNzdWVzLzk1XG5cblxuICAgICAgaWYgKHRva2VuRGVmLnR5cGUgPT09IFR3aWcudG9rZW4udHlwZS5jb21tZW50KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBJZ25vcmUgcXVvdGVzIHdpdGhpbiByYXcgdGFnXG4gICAgICAvLyBGaXhlcyAjMjgzXG5cblxuICAgICAgaWYgKHRva2VuRGVmLnR5cGUgPT09IFR3aWcudG9rZW4udHlwZS5yYXcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGwgPSBUd2lnLnRva2VuLnN0cmluZ3MubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSArPSAxKSB7XG4gICAgICAgIHRoaXNTdHJQb3MgPSB0ZW1wbGF0ZS5pbmRleE9mKFR3aWcudG9rZW4uc3RyaW5nc1tpXSwgb2Zmc2V0KTtcblxuICAgICAgICBpZiAodGhpc1N0clBvcyA+IDAgJiYgdGhpc1N0clBvcyA8IHBvcyAmJiAoc3RyUG9zID09PSBudWxsIHx8IHRoaXNTdHJQb3MgPCBzdHJQb3MpKSB7XG4gICAgICAgICAgc3RyUG9zID0gdGhpc1N0clBvcztcbiAgICAgICAgICBzdHJGb3VuZCA9IFR3aWcudG9rZW4uc3RyaW5nc1tpXTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBXZSBmb3VuZCBhIHN0cmluZyBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgdG9rZW4sIG5vdyBmaW5kIHRoZSBzdHJpbmcncyBlbmQgYW5kIHNldCB0aGUgc2VhcmNoIG9mZnNldCB0byBpdFxuXG5cbiAgICAgIGlmIChzdHJQb3MgIT09IG51bGwpIHtcbiAgICAgICAgZW5kT2Zmc2V0ID0gc3RyUG9zICsgMTtcbiAgICAgICAgZW5kID0gbnVsbDtcbiAgICAgICAgZm91bmQgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgZW5kU3RyUG9zID0gdGVtcGxhdGUuaW5kZXhPZihzdHJGb3VuZCwgZW5kT2Zmc2V0KTtcblxuICAgICAgICAgIGlmIChlbmRTdHJQb3MgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBUd2lnLkVycm9yKCdVbmNsb3NlZCBzdHJpbmcgaW4gdGVtcGxhdGUnKTtcbiAgICAgICAgICB9IC8vIElnbm9yZSBlc2NhcGVkIHF1b3Rlc1xuXG5cbiAgICAgICAgICBpZiAodGVtcGxhdGUuc2xpY2UoZW5kU3RyUG9zIC0gMSwgZW5kU3RyUG9zKSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBlbmRPZmZzZXQgPSBlbmRTdHJQb3MgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmRTdHJQb3MgKyAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuZDtcbiAgfTtcbiAgLyoqXG4gICAqIENvbnZlcnQgYSB0ZW1wbGF0ZSBpbnRvIGhpZ2gtbGV2ZWwgdG9rZW5zLlxuICAgKi9cblxuXG4gIFR3aWcudG9rZW5pemUgPSBmdW5jdGlvbiAodGVtcGxhdGUpIHtcbiAgICB2YXIgdG9rZW5zID0gW107IC8vIEFuIG9mZnNldCBmb3IgcmVwb3J0aW5nIGVycm9ycyBsb2NhdGlvbnMgaW4gdGhlIHRlbXBsYXRlLlxuXG4gICAgdmFyIGVycm9yT2Zmc2V0ID0gMDsgLy8gVGhlIHN0YXJ0IGFuZCB0eXBlIG9mIHRoZSBmaXJzdCB0b2tlbiBmb3VuZCBpbiB0aGUgdGVtcGxhdGUuXG5cbiAgICB2YXIgZm91bmRUb2tlbiA9IG51bGw7IC8vIFRoZSBlbmQgcG9zaXRpb24gb2YgdGhlIG1hdGNoZWQgdG9rZW4uXG5cbiAgICB2YXIgZW5kID0gbnVsbDtcblxuICAgIHdoaWxlICh0ZW1wbGF0ZS5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBGaW5kIHRoZSBmaXJzdCBvY2N1cmFuY2Ugb2YgYW55IHRva2VuIHR5cGUgaW4gdGhlIHRlbXBsYXRlXG4gICAgICBmb3VuZFRva2VuID0gVHdpZy50b2tlbi5maW5kU3RhcnQodGVtcGxhdGUpO1xuICAgICAgVHdpZy5sb2cudHJhY2UoJ1R3aWcudG9rZW5pemU6ICcsICdGb3VuZCB0b2tlbjogJywgZm91bmRUb2tlbik7XG5cbiAgICAgIGlmIChmb3VuZFRva2VuLnBvc2l0aW9uID09PSBudWxsKSB7XG4gICAgICAgIC8vIE5vIG1vcmUgdG9rZW5zIC0+IGFkZCB0aGUgcmVzdCBvZiB0aGUgdGVtcGxhdGUgYXMgYSByYXctdHlwZSB0b2tlblxuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogVHdpZy50b2tlbi50eXBlLnJhdyxcbiAgICAgICAgICB2YWx1ZTogdGVtcGxhdGVcbiAgICAgICAgfSk7XG4gICAgICAgIHRlbXBsYXRlID0gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBZGQgYSByYXcgdHlwZSB0b2tlbiBmb3IgYW55dGhpbmcgYmVmb3JlIHRoZSBzdGFydCBvZiB0aGUgdG9rZW5cbiAgICAgICAgaWYgKGZvdW5kVG9rZW4ucG9zaXRpb24gPiAwKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogVHdpZy50b2tlbi50eXBlLnJhdyxcbiAgICAgICAgICAgIHZhbHVlOiB0ZW1wbGF0ZS5zbGljZSgwLCBNYXRoLm1heCgwLCBmb3VuZFRva2VuLnBvc2l0aW9uKSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuc2xpY2UoZm91bmRUb2tlbi5wb3NpdGlvbiArIGZvdW5kVG9rZW4uZGVmLm9wZW4ubGVuZ3RoKTtcbiAgICAgICAgZXJyb3JPZmZzZXQgKz0gZm91bmRUb2tlbi5wb3NpdGlvbiArIGZvdW5kVG9rZW4uZGVmLm9wZW4ubGVuZ3RoOyAvLyBGaW5kIHRoZSBlbmQgb2YgdGhlIHRva2VuXG5cbiAgICAgICAgZW5kID0gVHdpZy50b2tlbi5maW5kRW5kKHRlbXBsYXRlLCBmb3VuZFRva2VuLmRlZiwgZXJyb3JPZmZzZXQpO1xuICAgICAgICBUd2lnLmxvZy50cmFjZSgnVHdpZy50b2tlbml6ZTogJywgJ1Rva2VuIGVuZHMgYXQgJywgZW5kKTtcbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6IGZvdW5kVG9rZW4uZGVmLnR5cGUsXG4gICAgICAgICAgdmFsdWU6IHRlbXBsYXRlLnNsaWNlKDAsIE1hdGgubWF4KDAsIGVuZCkpLnRyaW0oKVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGVtcGxhdGUuc2xpY2UoZW5kICsgZm91bmRUb2tlbi5kZWYuY2xvc2UubGVuZ3RoLCBlbmQgKyBmb3VuZFRva2VuLmRlZi5jbG9zZS5sZW5ndGggKyAxKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICBzd2l0Y2ggKGZvdW5kVG9rZW4uZGVmLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2xvZ2ljX3doaXRlc3BhY2VfcHJlJzpcbiAgICAgICAgICAgIGNhc2UgJ2xvZ2ljX3doaXRlc3BhY2VfcG9zdCc6XG4gICAgICAgICAgICBjYXNlICdsb2dpY193aGl0ZXNwYWNlX2JvdGgnOlxuICAgICAgICAgICAgY2FzZSAnbG9naWMnOlxuICAgICAgICAgICAgICAvLyBOZXdsaW5lcyBkaXJlY3RseSBhZnRlciBsb2dpYyB0b2tlbnMgYXJlIGlnbm9yZWRcbiAgICAgICAgICAgICAgZW5kICs9IDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnNsaWNlKGVuZCArIGZvdW5kVG9rZW4uZGVmLmNsb3NlLmxlbmd0aCk7IC8vIEluY3JlbWVudCB0aGUgcG9zaXRpb24gaW4gdGhlIHRlbXBsYXRlXG5cbiAgICAgICAgZXJyb3JPZmZzZXQgKz0gZW5kICsgZm91bmRUb2tlbi5kZWYuY2xvc2UubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b2tlbnM7XG4gIH07XG5cbiAgVHdpZy5jb21waWxlID0gZnVuY3Rpb24gKHRva2Vucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRyeSB7XG4gICAgICAvLyBPdXRwdXQgYW5kIGludGVybWVkaWF0ZSBzdGFja3NcbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIHZhciBzdGFjayA9IFtdOyAvLyBUaGUgdG9rZW5zIGJldHdlZW4gb3BlbiBhbmQgY2xvc2UgdGFnc1xuXG4gICAgICB2YXIgaW50ZXJtZWRpYXRlT3V0cHV0ID0gW107XG4gICAgICB2YXIgdG9rZW4gPSBudWxsO1xuICAgICAgdmFyIGxvZ2ljVG9rZW4gPSBudWxsO1xuICAgICAgdmFyIHVuY2xvc2VkVG9rZW4gPSBudWxsOyAvLyBUZW1wb3JhcnkgcHJldmlvdXMgdG9rZW4uXG5cbiAgICAgIHZhciBwcmV2VG9rZW4gPSBudWxsOyAvLyBUZW1wb3JhcnkgcHJldmlvdXMgb3V0cHV0LlxuXG4gICAgICB2YXIgcHJldk91dHB1dCA9IG51bGw7IC8vIFRlbXBvcmFyeSBwcmV2aW91cyBpbnRlcm1lZGlhdGUgb3V0cHV0LlxuXG4gICAgICB2YXIgcHJldkludGVybWVkaWF0ZU91dHB1dCA9IG51bGw7IC8vIFRoZSBwcmV2aW91cyB0b2tlbidzIHRlbXBsYXRlXG5cbiAgICAgIHZhciBwcmV2VGVtcGxhdGUgPSBudWxsOyAvLyBUb2tlbiBsb29rYWhlYWRcblxuICAgICAgdmFyIG5leHRUb2tlbiA9IG51bGw7IC8vIFRoZSBvdXRwdXQgdG9rZW5cblxuICAgICAgdmFyIHRva091dHB1dCA9IG51bGw7IC8vIExvZ2ljIFRva2VuIHZhbHVlc1xuXG4gICAgICB2YXIgdHlwZSA9IG51bGw7XG4gICAgICB2YXIgb3BlbiA9IG51bGw7XG4gICAgICB2YXIgbmV4dCA9IG51bGw7XG5cbiAgICAgIHZhciBjb21waWxlT3V0cHV0ID0gZnVuY3Rpb24gY29tcGlsZU91dHB1dCh0b2tlbikge1xuICAgICAgICBUd2lnLmV4cHJlc3Npb24uY29tcGlsZS5jYWxsKHNlbGYsIHRva2VuKTtcblxuICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgIGludGVybWVkaWF0ZU91dHB1dC5wdXNoKHRva2VuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXQucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBjb21waWxlTG9naWMgPSBmdW5jdGlvbiBjb21waWxlTG9naWModG9rZW4pIHtcbiAgICAgICAgLy8gQ29tcGlsZSB0aGUgbG9naWMgdG9rZW5cbiAgICAgICAgbG9naWNUb2tlbiA9IFR3aWcubG9naWMuY29tcGlsZS5jYWxsKHNlbGYsIHRva2VuKTtcbiAgICAgICAgdHlwZSA9IGxvZ2ljVG9rZW4udHlwZTtcbiAgICAgICAgb3BlbiA9IFR3aWcubG9naWMuaGFuZGxlclt0eXBlXS5vcGVuO1xuICAgICAgICBuZXh0ID0gVHdpZy5sb2dpYy5oYW5kbGVyW3R5cGVdLm5leHQ7XG4gICAgICAgIFR3aWcubG9nLnRyYWNlKCdUd2lnLmNvbXBpbGU6ICcsICdDb21waWxlZCBsb2dpYyB0b2tlbiB0byAnLCBsb2dpY1Rva2VuLCAnIG5leHQgaXM6ICcsIG5leHQsICcgb3BlbiBpcyA6ICcsIG9wZW4pOyAvLyBOb3QgYSBzdGFuZGFsb25lIHRva2VuLCBjaGVjayBsb2dpYyBzdGFjayB0byBzZWUgaWYgdGhpcyBpcyBleHBlY3RlZFxuXG4gICAgICAgIGlmIChvcGVuICE9PSB1bmRlZmluZWQgJiYgIW9wZW4pIHtcbiAgICAgICAgICBwcmV2VG9rZW4gPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICBwcmV2VGVtcGxhdGUgPSBUd2lnLmxvZ2ljLmhhbmRsZXJbcHJldlRva2VuLnR5cGVdO1xuXG4gICAgICAgICAgaWYgKCFwcmV2VGVtcGxhdGUubmV4dC5pbmNsdWRlcyh0eXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHR5cGUgKyAnIG5vdCBleHBlY3RlZCBhZnRlciBhICcgKyBwcmV2VG9rZW4udHlwZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHJldlRva2VuLm91dHB1dCA9IHByZXZUb2tlbi5vdXRwdXQgfHwgW107XG4gICAgICAgICAgcHJldlRva2VuLm91dHB1dCA9IHByZXZUb2tlbi5vdXRwdXQuY29uY2F0KGludGVybWVkaWF0ZU91dHB1dCk7XG4gICAgICAgICAgaW50ZXJtZWRpYXRlT3V0cHV0ID0gW107XG4gICAgICAgICAgdG9rT3V0cHV0ID0ge1xuICAgICAgICAgICAgdHlwZTogVHdpZy50b2tlbi50eXBlLmxvZ2ljLFxuICAgICAgICAgICAgdG9rZW46IHByZXZUb2tlblxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaW50ZXJtZWRpYXRlT3V0cHV0LnB1c2godG9rT3V0cHV0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2godG9rT3V0cHV0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gVGhpcyB0b2tlbiByZXF1aXJlcyBhZGRpdGlvbmFsIHRva2VucyB0byBjb21wbGV0ZSB0aGUgbG9naWMgc3RydWN0dXJlLlxuXG5cbiAgICAgICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCAmJiBuZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBUd2lnLmxvZy50cmFjZSgnVHdpZy5jb21waWxlOiAnLCAnUHVzaGluZyAnLCBsb2dpY1Rva2VuLCAnIHRvIGxvZ2ljIHN0YWNrLicpO1xuXG4gICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIFB1dCBhbnkgY3VycmVudGx5IGhlbGQgb3V0cHV0IGludG8gdGhlIG91dHB1dCBsaXN0IG9mIHRoZSBsb2dpYyBvcGVyYXRvclxuICAgICAgICAgICAgLy8gY3VycmVudGx5IGF0IHRoZSBoZWFkIG9mIHRoZSBzdGFjayBiZWZvcmUgd2UgcHVzaCBhIG5ldyBvbmUgb24uXG4gICAgICAgICAgICBwcmV2VG9rZW4gPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHByZXZUb2tlbi5vdXRwdXQgPSBwcmV2VG9rZW4ub3V0cHV0IHx8IFtdO1xuICAgICAgICAgICAgcHJldlRva2VuLm91dHB1dCA9IHByZXZUb2tlbi5vdXRwdXQuY29uY2F0KGludGVybWVkaWF0ZU91dHB1dCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHByZXZUb2tlbik7XG4gICAgICAgICAgICBpbnRlcm1lZGlhdGVPdXRwdXQgPSBbXTtcbiAgICAgICAgICB9IC8vIFB1c2ggdGhlIG5ldyBsb2dpYyB0b2tlbiBvbnRvIHRoZSBsb2dpYyBzdGFja1xuXG5cbiAgICAgICAgICBzdGFjay5wdXNoKGxvZ2ljVG9rZW4pO1xuICAgICAgICB9IGVsc2UgaWYgKG9wZW4gIT09IHVuZGVmaW5lZCAmJiBvcGVuKSB7XG4gICAgICAgICAgdG9rT3V0cHV0ID0ge1xuICAgICAgICAgICAgdHlwZTogVHdpZy50b2tlbi50eXBlLmxvZ2ljLFxuICAgICAgICAgICAgdG9rZW46IGxvZ2ljVG9rZW5cbiAgICAgICAgICB9OyAvLyBTdGFuZGFsb25lIHRva2VuIChsaWtlIHslIHNldCAuLi4gJX1cblxuICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpbnRlcm1lZGlhdGVPdXRwdXQucHVzaCh0b2tPdXRwdXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaCh0b2tPdXRwdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgd2hpbGUgKHRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG4gICAgICAgIHByZXZPdXRwdXQgPSBvdXRwdXRbb3V0cHV0Lmxlbmd0aCAtIDFdO1xuICAgICAgICBwcmV2SW50ZXJtZWRpYXRlT3V0cHV0ID0gaW50ZXJtZWRpYXRlT3V0cHV0W2ludGVybWVkaWF0ZU91dHB1dC5sZW5ndGggLSAxXTtcbiAgICAgICAgbmV4dFRva2VuID0gdG9rZW5zWzBdO1xuICAgICAgICBUd2lnLmxvZy50cmFjZSgnQ29tcGlsaW5nIHRva2VuICcsIHRva2VuKTtcblxuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFR3aWcudG9rZW4udHlwZS5yYXc6XG4gICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBpbnRlcm1lZGlhdGVPdXRwdXQucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXRwdXQucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBUd2lnLnRva2VuLnR5cGUubG9naWM6XG4gICAgICAgICAgICBjb21waWxlTG9naWMuY2FsbChzZWxmLCB0b2tlbik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBEbyBub3RoaW5nLCBjb21tZW50cyBzaG91bGQgYmUgaWdub3JlZFxuXG4gICAgICAgICAgY2FzZSBUd2lnLnRva2VuLnR5cGUuY29tbWVudDpcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBUd2lnLnRva2VuLnR5cGUub3V0cHV0OlxuICAgICAgICAgICAgY29tcGlsZU91dHB1dC5jYWxsKHNlbGYsIHRva2VuKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIEtpbGwgd2hpdGVzcGFjZSBhaGVhZCBhbmQgYmVoaW5kIHRoaXMgdG9rZW5cblxuICAgICAgICAgIGNhc2UgVHdpZy50b2tlbi50eXBlLmxvZ2ljV2hpdGVzcGFjZVByZTpcbiAgICAgICAgICBjYXNlIFR3aWcudG9rZW4udHlwZS5sb2dpY1doaXRlc3BhY2VQb3N0OlxuICAgICAgICAgIGNhc2UgVHdpZy50b2tlbi50eXBlLmxvZ2ljV2hpdGVzcGFjZUJvdGg6XG4gICAgICAgICAgY2FzZSBUd2lnLnRva2VuLnR5cGUub3V0cHV0V2hpdGVzcGFjZVByZTpcbiAgICAgICAgICBjYXNlIFR3aWcudG9rZW4udHlwZS5vdXRwdXRXaGl0ZXNwYWNlUG9zdDpcbiAgICAgICAgICBjYXNlIFR3aWcudG9rZW4udHlwZS5vdXRwdXRXaGl0ZXNwYWNlQm90aDpcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUd2lnLnRva2VuLnR5cGUub3V0cHV0V2hpdGVzcGFjZVBvc3QgJiYgdG9rZW4udHlwZSAhPT0gVHdpZy50b2tlbi50eXBlLmxvZ2ljV2hpdGVzcGFjZVBvc3QpIHtcbiAgICAgICAgICAgICAgaWYgKHByZXZPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgb3V0cHV0IGlzIHJhdywgcG9wIGl0IG9mZlxuICAgICAgICAgICAgICAgIGlmIChwcmV2T3V0cHV0LnR5cGUgPT09IFR3aWcudG9rZW4udHlwZS5yYXcpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dC5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIHByZXZPdXRwdXQudmFsdWUgPSBwcmV2T3V0cHV0LnZhbHVlLnRyaW1FbmQoKTsgLy8gUmVwdXNoIHRoZSBwcmV2aW91cyBvdXRwdXRcblxuICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gocHJldk91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHByZXZJbnRlcm1lZGlhdGVPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgaW50ZXJtZWRpYXRlIG91dHB1dCBpcyByYXcsIHBvcCBpdCBvZmZcbiAgICAgICAgICAgICAgICBpZiAocHJldkludGVybWVkaWF0ZU91dHB1dC50eXBlID09PSBUd2lnLnRva2VuLnR5cGUucmF3KSB7XG4gICAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGVPdXRwdXQucG9wKCk7XG4gICAgICAgICAgICAgICAgICBwcmV2SW50ZXJtZWRpYXRlT3V0cHV0LnZhbHVlID0gcHJldkludGVybWVkaWF0ZU91dHB1dC52YWx1ZS50cmltRW5kKCk7IC8vIFJlcHVzaCB0aGUgcHJldmlvdXMgaW50ZXJtZWRpYXRlIG91dHB1dFxuXG4gICAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGVPdXRwdXQucHVzaChwcmV2SW50ZXJtZWRpYXRlT3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gQ29tcGlsZSB0aGlzIHRva2VuXG5cblxuICAgICAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgVHdpZy50b2tlbi50eXBlLm91dHB1dFdoaXRlc3BhY2VQcmU6XG4gICAgICAgICAgICAgIGNhc2UgVHdpZy50b2tlbi50eXBlLm91dHB1dFdoaXRlc3BhY2VQb3N0OlxuICAgICAgICAgICAgICBjYXNlIFR3aWcudG9rZW4udHlwZS5vdXRwdXRXaGl0ZXNwYWNlQm90aDpcbiAgICAgICAgICAgICAgICBjb21waWxlT3V0cHV0LmNhbGwoc2VsZiwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgVHdpZy50b2tlbi50eXBlLmxvZ2ljV2hpdGVzcGFjZVByZTpcbiAgICAgICAgICAgICAgY2FzZSBUd2lnLnRva2VuLnR5cGUubG9naWNXaGl0ZXNwYWNlUG9zdDpcbiAgICAgICAgICAgICAgY2FzZSBUd2lnLnRva2VuLnR5cGUubG9naWNXaGl0ZXNwYWNlQm90aDpcbiAgICAgICAgICAgICAgICBjb21waWxlTG9naWMuY2FsbChzZWxmLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFR3aWcudG9rZW4udHlwZS5vdXRwdXRXaGl0ZXNwYWNlUHJlICYmIHRva2VuLnR5cGUgIT09IFR3aWcudG9rZW4udHlwZS5sb2dpY1doaXRlc3BhY2VQcmUpIHtcbiAgICAgICAgICAgICAgaWYgKG5leHRUb2tlbikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBuZXh0IHRva2VuIGlzIHJhdywgc2hpZnQgaXQgb3V0XG4gICAgICAgICAgICAgICAgaWYgKG5leHRUb2tlbi50eXBlID09PSBUd2lnLnRva2VuLnR5cGUucmF3KSB7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgIG5leHRUb2tlbi52YWx1ZSA9IG5leHRUb2tlbi52YWx1ZS50cmltU3RhcnQoKTsgLy8gVW5zaGlmdCB0aGUgbmV4dCB0b2tlblxuXG4gICAgICAgICAgICAgICAgICB0b2tlbnMudW5zaGlmdChuZXh0VG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIFR3aWcubG9nLnRyYWNlKCdUd2lnLmNvbXBpbGU6ICcsICcgT3V0cHV0OiAnLCBvdXRwdXQsICcgTG9naWMgU3RhY2s6ICcsIHN0YWNrLCAnIFBlbmRpbmcgT3V0cHV0OiAnLCBpbnRlcm1lZGlhdGVPdXRwdXQpO1xuICAgICAgfSAvLyBWZXJpZnkgdGhhdCB0aGVyZSBhcmUgbm8gbG9naWMgdG9rZW5zIGxlZnQgaW4gdGhlIHN0YWNrLlxuXG5cbiAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgIHVuY2xvc2VkVG9rZW4gPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBhbiBlbmQgdGFnIGZvciAnICsgdW5jbG9zZWRUb2tlbi50eXBlICsgJywgZXhwZWN0aW5nIG9uZSBvZiAnICsgdW5jbG9zZWRUb2tlbi5uZXh0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKHNlbGYub3B0aW9ucy5yZXRocm93KSB7XG4gICAgICAgIGlmIChlcnJvci50eXBlID09PSAnVHdpZ0V4Y2VwdGlvbicgJiYgIWVycm9yLmZpbGUpIHtcbiAgICAgICAgICBlcnJvci5maWxlID0gc2VsZi5pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVHdpZy5sb2cuZXJyb3IoJ0Vycm9yIGNvbXBpbGluZyB0d2lnIHRlbXBsYXRlICcgKyBzZWxmLmlkICsgJzogJyk7XG5cbiAgICAgICAgaWYgKGVycm9yLnN0YWNrKSB7XG4gICAgICAgICAgVHdpZy5sb2cuZXJyb3IoZXJyb3Iuc3RhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFR3aWcubG9nLmVycm9yKGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUV4Y2VwdGlvbihzdGF0ZSwgZXgpIHtcbiAgICBpZiAoc3RhdGUudGVtcGxhdGUub3B0aW9ucy5yZXRocm93KSB7XG4gICAgICBpZiAodHlwZW9mIGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICBleCA9IG5ldyBUd2lnLkVycm9yKGV4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV4LnR5cGUgPT09ICdUd2lnRXhjZXB0aW9uJyAmJiAhZXguZmlsZSkge1xuICAgICAgICBleC5maWxlID0gc3RhdGUudGVtcGxhdGUuaWQ7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBUd2lnLmxvZy5lcnJvcignRXJyb3IgcGFyc2luZyB0d2lnIHRlbXBsYXRlICcgKyBzdGF0ZS50ZW1wbGF0ZS5pZCArICc6ICcpO1xuXG4gICAgICBpZiAoZXguc3RhY2spIHtcbiAgICAgICAgVHdpZy5sb2cuZXJyb3IoZXguc3RhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVHdpZy5sb2cuZXJyb3IoZXgudG9TdHJpbmcoKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChUd2lnLmRlYnVnKSB7XG4gICAgICAgIHJldHVybiBleC50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogVG9rZW5pemUgYW5kIGNvbXBpbGUgYSBzdHJpbmcgdGVtcGxhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIFRoZSB0ZW1wbGF0ZS5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9IFRoZSBjb21waWxlZCB0b2tlbnMuXG4gICAqL1xuXG5cbiAgVHdpZy5wcmVwYXJlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAvLyBUb2tlbml6ZVxuICAgIFR3aWcubG9nLmRlYnVnKCdUd2lnLnByZXBhcmU6ICcsICdUb2tlbml6aW5nICcsIGRhdGEpO1xuICAgIHZhciByYXdUb2tlbnMgPSBUd2lnLnRva2VuaXplLmNhbGwodGhpcywgZGF0YSk7IC8vIENvbXBpbGVcblxuICAgIFR3aWcubG9nLmRlYnVnKCdUd2lnLnByZXBhcmU6ICcsICdDb21waWxpbmcgJywgcmF3VG9rZW5zKTtcbiAgICB2YXIgdG9rZW5zID0gVHdpZy5jb21waWxlLmNhbGwodGhpcywgcmF3VG9rZW5zKTtcbiAgICBUd2lnLmxvZy5kZWJ1ZygnVHdpZy5wcmVwYXJlOiAnLCAnQ29tcGlsZWQgJywgdG9rZW5zKTtcbiAgICByZXR1cm4gdG9rZW5zO1xuICB9O1xuICAvKipcbiAgICogSm9pbiB0aGUgb3V0cHV0IHRva2VuJ3Mgc3RhY2sgYW5kIGVzY2FwZSBpdCBpZiBuZWVkZWRcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gT3V0cHV0IHRva2VuJ3Mgc3RhY2tcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfFN0cmluZ30gQXV0b2VzY2FwZWQgb3V0cHV0XG4gICAqL1xuXG5cbiAgVHdpZy5vdXRwdXQgPSBmdW5jdGlvbiAob3V0cHV0KSB7XG4gICAgdmFyIGF1dG9lc2NhcGUgPSB0aGlzLm9wdGlvbnMuYXV0b2VzY2FwZTtcblxuICAgIGlmICghYXV0b2VzY2FwZSkge1xuICAgICAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbiAgICB9XG5cbiAgICB2YXIgc3RyYXRlZ3kgPSB0eXBlb2YgYXV0b2VzY2FwZSA9PT0gJ3N0cmluZycgPyBhdXRvZXNjYXBlIDogJ2h0bWwnO1xuICAgIHZhciBlc2NhcGVkT3V0cHV0ID0gb3V0cHV0Lm1hcChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICBpZiAoc3RyICYmIHN0ci50d2lnTWFya3VwICE9PSB0cnVlICYmIHN0ci50d2lnTWFya3VwICE9PSBzdHJhdGVneSAmJiAhKHN0cmF0ZWd5ID09PSAnaHRtbCcgJiYgc3RyLnR3aWdNYXJrdXAgPT09ICdodG1sX2F0dHInKSkge1xuICAgICAgICBzdHIgPSBUd2lnLmZpbHRlcnMuZXNjYXBlKHN0ciwgW3N0cmF0ZWd5XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfSk7XG5cbiAgICBpZiAoZXNjYXBlZE91dHB1dC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICB2YXIgam9pbmVkT3V0cHV0ID0gZXNjYXBlZE91dHB1dC5qb2luKCcnKTtcblxuICAgIGlmIChqb2luZWRPdXRwdXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUd2lnLk1hcmt1cChqb2luZWRPdXRwdXQsIHRydWUpO1xuICB9OyAvLyBOYW1lc3BhY2UgZm9yIHRlbXBsYXRlIHN0b3JhZ2UgYW5kIHJldHJpZXZhbFxuXG5cbiAgVHdpZy5UZW1wbGF0ZXMgPSB7XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJlZCB0ZW1wbGF0ZSBsb2FkZXJzIC0gdXNlIFR3aWcuVGVtcGxhdGVzLnJlZ2lzdGVyTG9hZGVyIHRvIGFkZCBzdXBwb3J0ZWQgbG9hZGVyc1xuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgbG9hZGVyczoge30sXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcmVkIHRlbXBsYXRlIHBhcnNlcnMgLSB1c2UgVHdpZy5UZW1wbGF0ZXMucmVnaXN0ZXJQYXJzZXIgdG8gYWRkIHN1cHBvcnRlZCBwYXJzZXJzXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBwYXJzZXJzOiB7fSxcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCAvIGxvYWRlZCB0ZW1wbGF0ZXNcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHJlZ2lzdHJ5OiB7fVxuICB9O1xuICAvKipcbiAgICogSXMgdGhpcyBpZCB2YWxpZCBmb3IgYSB0d2lnIHRlbXBsYXRlP1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIHRvIGNoZWNrLlxuICAgKlxuICAgKiBAdGhyb3dzIHtUd2lnLkVycm9yfSBJZiB0aGUgSUQgaXMgaW52YWxpZCBvciB1c2VkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBJRCBpcyB2YWxpZC5cbiAgICovXG5cbiAgVHdpZy52YWxpZGF0ZUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgaWYgKGlkID09PSAncHJvdG90eXBlJykge1xuICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoaWQgKyAnIGlzIG5vdCBhIHZhbGlkIHR3aWcgaWRlbnRpZmllcicpO1xuICAgIH0gZWxzZSBpZiAoVHdpZy5jYWNoZSAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChUd2lnLlRlbXBsYXRlcy5yZWdpc3RyeSwgaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcignVGhlcmUgaXMgYWxyZWFkeSBhIHRlbXBsYXRlIHdpdGggdGhlIElEICcgKyBpZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHRlbXBsYXRlIGxvYWRlclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBUd2lnLmV4dGVuZChmdW5jdGlvbiAoVHdpZykge1xuICAgKiAgICBUd2lnLlRlbXBsYXRlcy5yZWdpc3RlckxvYWRlcignY3VzdG9tX2xvYWRlcicsIGZ1bmN0aW9uIChsb2NhdGlvbiwgcGFyYW1zLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgKiAgICAgICAgLy8gLi4uIGxvYWQgdGhlIHRlbXBsYXRlIC4uLlxuICAgKiAgICAgICAgcGFyYW1zLmRhdGEgPSBsb2FkZWRUZW1wbGF0ZURhdGE7XG4gICAqICAgICAgICAvLyBjcmVhdGUgYW5kIHJldHVybiB0aGUgdGVtcGxhdGVcbiAgICogICAgICAgIHZhciB0ZW1wbGF0ZSA9IG5ldyBUd2lnLlRlbXBsYXRlKHBhcmFtcyk7XG4gICAqICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAqICAgICAgICAgICAgY2FsbGJhY2sodGVtcGxhdGUpO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgKiAgICB9KTtcbiAgICogfSk7XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2ROYW1lIFRoZSBtZXRob2QgdGhpcyBsb2FkZXIgaXMgaW50ZW5kZWQgZm9yIChhamF4LCBmcylcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIGxvYWRpbmcgdGhlIHRlbXBsYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fHVuZGVmaW5lZH0gc2NvcGUgT3B0aW9uYWwgc2NvcGUgcGFyYW1ldGVyIHRvIGJpbmQgZnVuYyB0b1xuICAgKlxuICAgKiBAdGhyb3dzIFR3aWcuRXJyb3JcbiAgICpcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG5cblxuICBUd2lnLlRlbXBsYXRlcy5yZWdpc3RlckxvYWRlciA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBmdW5jLCBzY29wZSkge1xuICAgIGlmICh0eXBlb2YgZnVuYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoJ1VuYWJsZSB0byBhZGQgbG9hZGVyIGZvciAnICsgbWV0aG9kTmFtZSArICc6IEludmFsaWQgZnVuY3Rpb24gcmVmZXJlbmNlIGdpdmVuLicpO1xuICAgIH1cblxuICAgIGlmIChzY29wZSkge1xuICAgICAgZnVuYyA9IGZ1bmMuYmluZChzY29wZSk7XG4gICAgfVxuXG4gICAgdGhpcy5sb2FkZXJzW21ldGhvZE5hbWVdID0gZnVuYztcbiAgfTtcbiAgLyoqXG4gICAqIFJlbW92ZSBhIHJlZ2lzdGVyZWQgbG9hZGVyXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2ROYW1lIFRoZSBtZXRob2QgbmFtZSBmb3IgdGhlIGxvYWRlciB5b3Ugd2lzaCB0byByZW1vdmVcbiAgICpcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG5cblxuICBUd2lnLlRlbXBsYXRlcy51blJlZ2lzdGVyTG9hZGVyID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICBpZiAodGhpcy5pc1JlZ2lzdGVyZWRMb2FkZXIobWV0aG9kTmFtZSkpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmxvYWRlcnNbbWV0aG9kTmFtZV07XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogU2VlIGlmIGEgbG9hZGVyIGlzIHJlZ2lzdGVyZWQgYnkgaXRzIG1ldGhvZCBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBsb2FkZXIgeW91IGFyZSBsb29raW5nIGZvclxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXG4gIFR3aWcuVGVtcGxhdGVzLmlzUmVnaXN0ZXJlZExvYWRlciA9IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XG4gICAgcmV0dXJuIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMubG9hZGVycywgbWV0aG9kTmFtZSk7XG4gIH07XG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHRlbXBsYXRlIHBhcnNlclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBUd2lnLmV4dGVuZChmdW5jdGlvbiAoVHdpZykge1xuICAgKiAgICBUd2lnLlRlbXBsYXRlcy5yZWdpc3RlclBhcnNlcignY3VzdG9tX3BhcnNlcicsIGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICogICAgICAgIC8vIHRoaXMgdGVtcGxhdGUgc291cmNlIGNhbiBiZSBhY2Nlc3NlZCBpbiBwYXJhbXMuZGF0YVxuICAgKiAgICAgICAgdmFyIHRlbXBsYXRlID0gcGFyYW1zLmRhdGFcbiAgICpcbiAgICogICAgICAgIC8vIC4uLiBjdXN0b20gcHJvY2VzcyB0aGF0IG1vZGlmaWVzIHRoZSB0ZW1wbGF0ZVxuICAgKlxuICAgKiAgICAgICAgLy8gcmV0dXJuIHRoZSBwYXJzZWQgdGVtcGxhdGVcbiAgICogICAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICogICAgfSk7XG4gICAqIH0pO1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbWV0aG9kIHRoaXMgcGFyc2VyIGlzIGludGVuZGVkIGZvciAodHdpZywgc291cmNlKVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gcGFyc2luZyB0aGUgdGVtcGxhdGVcbiAgICogQHBhcmFtIHtPYmplY3R8dW5kZWZpbmVkfSBzY29wZSBPcHRpb25hbCBzY29wZSBwYXJhbWV0ZXIgdG8gYmluZCBmdW5jIHRvXG4gICAqXG4gICAqIEB0aHJvd3MgVHdpZy5FcnJvclxuICAgKlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cblxuXG4gIFR3aWcuVGVtcGxhdGVzLnJlZ2lzdGVyUGFyc2VyID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGZ1bmMsIHNjb3BlKSB7XG4gICAgaWYgKHR5cGVvZiBmdW5jICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcignVW5hYmxlIHRvIGFkZCBwYXJzZXIgZm9yICcgKyBtZXRob2ROYW1lICsgJzogSW52YWxpZCBmdW5jdGlvbiByZWdlcmVuY2UgZ2l2ZW4uJyk7XG4gICAgfVxuXG4gICAgaWYgKHNjb3BlKSB7XG4gICAgICBmdW5jID0gZnVuYy5iaW5kKHNjb3BlKTtcbiAgICB9XG5cbiAgICB0aGlzLnBhcnNlcnNbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICB9O1xuICAvKipcbiAgICogUmVtb3ZlIGEgcmVnaXN0ZXJlZCBwYXJzZXJcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG1ldGhvZCBuYW1lIGZvciB0aGUgcGFyc2VyIHlvdSB3aXNoIHRvIHJlbW92ZVxuICAgKlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cblxuXG4gIFR3aWcuVGVtcGxhdGVzLnVuUmVnaXN0ZXJQYXJzZXIgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSkge1xuICAgIGlmICh0aGlzLmlzUmVnaXN0ZXJlZFBhcnNlcihtZXRob2ROYW1lKSkge1xuICAgICAgZGVsZXRlIHRoaXMucGFyc2Vyc1ttZXRob2ROYW1lXTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBTZWUgaWYgYSBwYXJzZXIgaXMgcmVnaXN0ZXJlZCBieSBpdHMgbWV0aG9kIG5hbWVcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIHBhcnNlciB5b3UgYXJlIGxvb2tpbmcgZm9yXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgVHdpZy5UZW1wbGF0ZXMuaXNSZWdpc3RlcmVkUGFyc2VyID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICByZXR1cm4gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodGhpcy5wYXJzZXJzLCBtZXRob2ROYW1lKTtcbiAgfTtcbiAgLyoqXG4gICAqIFNhdmUgYSB0ZW1wbGF0ZSBvYmplY3QgdG8gdGhlIHN0b3JlLlxuICAgKlxuICAgKiBAcGFyYW0ge1R3aWcuVGVtcGxhdGV9IHRlbXBsYXRlICAgVGhlIHR3aWcuanMgdGVtcGxhdGUgdG8gc3RvcmUuXG4gICAqL1xuXG5cbiAgVHdpZy5UZW1wbGF0ZXMuc2F2ZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgIGlmICh0ZW1wbGF0ZS5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcignVW5hYmxlIHRvIHNhdmUgdGVtcGxhdGUgd2l0aCBubyBpZCcpO1xuICAgIH1cblxuICAgIFR3aWcuVGVtcGxhdGVzLnJlZ2lzdHJ5W3RlbXBsYXRlLmlkXSA9IHRlbXBsYXRlO1xuICB9O1xuICAvKipcbiAgICogTG9hZCBhIHByZXZpb3VzbHkgc2F2ZWQgdGVtcGxhdGUgZnJvbSB0aGUgc3RvcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAgIFRoZSBJRCBvZiB0aGUgdGVtcGxhdGUgdG8gbG9hZC5cbiAgICpcbiAgICogQHJldHVybiB7VHdpZy5UZW1wbGF0ZX0gQSB0d2lnLmpzIHRlbXBsYXRlIHN0b3JlZCB3aXRoIHRoZSBwcm92aWRlZCBJRC5cbiAgICovXG5cblxuICBUd2lnLlRlbXBsYXRlcy5sb2FkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgaWYgKCFPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChUd2lnLlRlbXBsYXRlcy5yZWdpc3RyeSwgaWQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gVHdpZy5UZW1wbGF0ZXMucmVnaXN0cnlbaWRdO1xuICB9O1xuICAvKipcbiAgICogTG9hZCBhIHRlbXBsYXRlIGZyb20gYSByZW1vdGUgbG9jYXRpb24gdXNpbmcgQUpBWCBhbmQgc2F2ZXMgaW4gd2l0aCB0aGUgZ2l2ZW4gSUQuXG4gICAqXG4gICAqIEF2YWlsYWJsZSBwYXJhbWV0ZXJzOlxuICAgKlxuICAgKiAgICAgIGFzeW5jOiAgICAgICBTaG91bGQgdGhlIEhUVFAgcmVxdWVzdCBiZSBwZXJmb3JtZWQgYXN5bmNocm9ub3VzbHkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIHRydWUuXG4gICAqICAgICAgbWV0aG9kOiAgICAgIFdoYXQgbWV0aG9kIHNob3VsZCBiZSB1c2VkIHRvIGxvYWQgdGhlIHRlbXBsYXRlXG4gICAqICAgICAgICAgICAgICAgICAgICAgIChmcyBvciBhamF4KVxuICAgKiAgICAgIHBhcnNlcjogICAgICBXaGF0IG1ldGhvZCBzaG91bGQgYmUgdXNlZCB0byBwYXJzZSB0aGUgdGVtcGxhdGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgKHR3aWcgb3Igc291cmNlKVxuICAgKiAgICAgIHByZWNvbXBpbGVkOiBIYXMgdGhlIHRlbXBsYXRlIGFscmVhZHkgYmVlbiBjb21waWxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uICBUaGUgcmVtb3RlIFVSTCB0byBsb2FkIGFzIGEgdGVtcGxhdGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgVGhlIHRlbXBsYXRlIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrICBBIGNhbGxiYWNrIHRyaWdnZXJlZCB3aGVuIHRoZSB0ZW1wbGF0ZSBmaW5pc2hlcyBsb2FkaW5nLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBlcnJvckNhbGxiYWNrICBBIGNhbGxiYWNrIHRyaWdnZXJlZCBpZiBhbiBlcnJvciBvY2N1cnMgbG9hZGluZyB0aGUgdGVtcGxhdGUuXG4gICAqXG4gICAqXG4gICAqL1xuXG5cbiAgVHdpZy5UZW1wbGF0ZXMubG9hZFJlbW90ZSA9IGZ1bmN0aW9uIChsb2NhdGlvbiwgcGFyYW1zLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgIC8vIERlZmF1bHQgdG8gdGhlIFVSTCBzbyB0aGUgdGVtcGxhdGUgaXMgY2FjaGVkLlxuICAgIHZhciBpZCA9IHR5cGVvZiBwYXJhbXMuaWQgPT09ICd1bmRlZmluZWQnID8gbG9jYXRpb24gOiBwYXJhbXMuaWQ7XG4gICAgdmFyIGNhY2hlZCA9IFR3aWcuVGVtcGxhdGVzLnJlZ2lzdHJ5W2lkXTsgLy8gQ2hlY2sgZm9yIGV4aXN0aW5nIHRlbXBsYXRlXG5cbiAgICBpZiAoVHdpZy5jYWNoZSAmJiB0eXBlb2YgY2FjaGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gQSB0ZW1wbGF0ZSBpcyBhbHJlYWR5IHNhdmVkIHdpdGggdGhlIGdpdmVuIGlkLlxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayhjYWNoZWQpO1xuICAgICAgfSAvLyBUT0RPOiBpZiBhc3luYywgcmV0dXJuIGRlZmVycmVkIHByb21pc2VcblxuXG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH0gLy8gSWYgdGhlIHBhcnNlciBuYW1lIGhhc24ndCBiZWVuIHNldCwgZGVmYXVsdCBpdCB0byB0d2lnXG5cblxuICAgIHBhcmFtcy5wYXJzZXIgPSBwYXJhbXMucGFyc2VyIHx8ICd0d2lnJztcbiAgICBwYXJhbXMuaWQgPSBpZDsgLy8gRGVmYXVsdCB0byBhc3luY1xuXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMuYXN5bmMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwYXJhbXMuYXN5bmMgPSB0cnVlO1xuICAgIH0gLy8gQXNzdW1lICdmcycgaWYgdGhlIGxvYWRlciBpcyBub3QgZGVmaW5lZFxuXG5cbiAgICB2YXIgbG9hZGVyID0gdGhpcy5sb2FkZXJzW3BhcmFtcy5tZXRob2RdIHx8IHRoaXMubG9hZGVycy5mcztcbiAgICByZXR1cm4gbG9hZGVyLmNhbGwodGhpcywgbG9jYXRpb24sIHBhcmFtcywgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xuICB9OyAvLyBEZXRlcm1pbmUgb2JqZWN0IHR5cGVcblxuXG4gIGZ1bmN0aW9uIGlzKHR5cGUsIG9iaikge1xuICAgIHZhciBjbGFzID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikuc2xpY2UoOCwgLTEpO1xuICAgIHJldHVybiBvYmogIT09IHVuZGVmaW5lZCAmJiBvYmogIT09IG51bGwgJiYgY2xhcyA9PT0gdHlwZTtcbiAgfVxuICAvKipcbiAgICogQSB3cmFwcGVyIGZvciB0ZW1wbGF0ZSBibG9ja3MuXG4gICAqXG4gICAqIEBwYXJhbSAge1R3aWcuVGVtcGxhdGV9IFRoZSB0ZW1wbGF0ZSB0aGF0IHRoZSBibG9jayB3YXMgb3JpZ2luYWxseSBkZWZpbmVkIGluLlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IFRoZSBjb21waWxlZCBibG9jayB0b2tlbi5cbiAgICovXG5cblxuICBUd2lnLkJsb2NrID0gZnVuY3Rpb24gKHRlbXBsYXRlLCB0b2tlbikge1xuICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gIH07XG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIGJsb2NrIHVzaW5nIGEgc3BlY2lmaWMgcGFyc2Ugc3RhdGUgYW5kIGNvbnRleHQuXG4gICAqXG4gICAqIEBwYXJhbSAge1R3aWcuUGFyc2VTdGF0ZX0gcGFyc2VTdGF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGNvbnRleHRcbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG5cblxuICBUd2lnLkJsb2NrLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAocGFyc2VTdGF0ZSwgY29udGV4dCkge1xuICAgIHZhciBvcmlnaW5hbFRlbXBsYXRlID0gcGFyc2VTdGF0ZS50ZW1wbGF0ZTtcbiAgICB2YXIgcHJvbWlzZTtcbiAgICBwYXJzZVN0YXRlLnRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZTtcblxuICAgIGlmICh0aGlzLnRva2VuLmV4cHJlc3Npb24pIHtcbiAgICAgIHByb21pc2UgPSBUd2lnLmV4cHJlc3Npb24ucGFyc2VBc3luYy5jYWxsKHBhcnNlU3RhdGUsIHRoaXMudG9rZW4ub3V0cHV0LCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZSA9IHBhcnNlU3RhdGUucGFyc2VBc3luYyh0aGlzLnRva2VuLm91dHB1dCwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBUd2lnLmV4cHJlc3Npb24ucGFyc2VBc3luYy5jYWxsKHBhcnNlU3RhdGUsIHtcbiAgICAgICAgdHlwZTogVHdpZy5leHByZXNzaW9uLnR5cGUuc3RyaW5nLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0sIGNvbnRleHQpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKG91dHB1dCkge1xuICAgICAgcGFyc2VTdGF0ZS50ZW1wbGF0ZSA9IG9yaWdpbmFsVGVtcGxhdGU7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogSG9sZHMgdGhlIHN0YXRlIG5lZWRlZCB0byBwYXJzZSBhIHRlbXBsYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge1R3aWcuVGVtcGxhdGV9IHRlbXBsYXRlIFRoZSB0ZW1wbGF0ZSB0aGF0IHRoZSB0b2tlbnMgYmVpbmcgcGFyc2VkIGFyZSBhc3NvY2lhdGVkIHdpdGguXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBibG9ja092ZXJyaWRlcyBBbnkgYmxvY2tzIHRoYXQgc2hvdWxkIG92ZXJyaWRlIHRob3NlIGRlZmluZWQgaW4gdGhlIGFzc29jaWF0ZWQgdGVtcGxhdGUuXG4gICAqL1xuXG5cbiAgVHdpZy5QYXJzZVN0YXRlID0gZnVuY3Rpb24gKHRlbXBsYXRlLCBibG9ja092ZXJyaWRlcykge1xuICAgIHRoaXMucmVuZGVyZWRCbG9ja3MgPSB7fTtcbiAgICB0aGlzLm92ZXJyaWRlQmxvY2tzID0gYmxvY2tPdmVycmlkZXMgPT09IHVuZGVmaW5lZCA/IHt9IDogYmxvY2tPdmVycmlkZXM7XG4gICAgdGhpcy5jb250ZXh0ID0ge307XG4gICAgdGhpcy5tYWNyb3MgPSB7fTtcbiAgICB0aGlzLm5lc3RpbmdTdGFjayA9IFtdO1xuICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgfTtcbiAgLyoqXG4gICAqIEdldCBhIGJsb2NrIGJ5IGl0cyBuYW1lLCByZXNvbHZpbmcgaW4gdGhlIGZvbGxvd2luZyBvcmRlcjpcbiAgICogICAgIC0gb3ZlcnJpZGUgYmxvY2tzIHNwZWNpZmllZCB3aGVuIGluaXRpYWxpemVkIChleGNlcHQgd2hlbiBleGNsdWRlZClcbiAgICogICAgIC0gYmxvY2tzIHJlc29sdmVkIGZyb20gdGhlIGFzc29jaWF0ZWQgdGVtcGxhdGVcbiAgICogICAgIC0gYmxvY2tzIHJlc29sdmVkIGZyb20gdGhlIHBhcmVudCB0ZW1wbGF0ZSB3aGVuIGV4dGVuZGluZ1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgYmxvY2sgdG8gcmV0dXJuLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNoZWNrT25seUluaGVyaXRlZEJsb2NrcyBXaGV0aGVyIHRvIHNraXAgY2hlY2tpbmcgdGhlIG92ZXJyaWRlcyBhbmQgYXNzb2NpYXRlZCB0ZW1wbGF0ZSwgd2lsbCBub3Qgc2tpcCBieSBkZWZhdWx0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtUd2lnLkJsb2NrfHVuZGVmaW5lZH1cbiAgICovXG5cblxuICBUd2lnLlBhcnNlU3RhdGUucHJvdG90eXBlLmdldEJsb2NrID0gZnVuY3Rpb24gKG5hbWUsIGNoZWNrT25seUluaGVyaXRlZEJsb2Nrcykge1xuICAgIHZhciBibG9jaztcblxuICAgIGlmIChjaGVja09ubHlJbmhlcml0ZWRCbG9ja3MgIT09IHRydWUpIHtcbiAgICAgIC8vIEJsb2NrcyBzcGVjaWZpZWQgd2hlbiBpbml0aWFsaXplZFxuICAgICAgYmxvY2sgPSB0aGlzLm92ZXJyaWRlQmxvY2tzW25hbWVdO1xuICAgIH1cblxuICAgIGlmIChibG9jayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBCbG9jayBkZWZpbmVkIGJ5IHRoZSBhc3NvY2lhdGVkIHRlbXBsYXRlXG4gICAgICBibG9jayA9IHRoaXMudGVtcGxhdGUuZ2V0QmxvY2sobmFtZSwgY2hlY2tPbmx5SW5oZXJpdGVkQmxvY2tzKTtcbiAgICB9XG5cbiAgICBpZiAoYmxvY2sgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnRlbXBsYXRlLnBhcmVudFRlbXBsYXRlICE9PSBudWxsKSB7XG4gICAgICAvLyBCbG9jayBkZWZpbmVkIGluIHRoZSBwYXJlbnQgdGVtcGxhdGUgd2hlbiBleHRlbmRpbmdcbiAgICAgIGJsb2NrID0gdGhpcy50ZW1wbGF0ZS5wYXJlbnRUZW1wbGF0ZS5nZXRCbG9jayhuYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmxvY2s7XG4gIH07XG4gIC8qKlxuICAgKiBHZXQgYWxsIHRoZSBhdmFpbGFibGUgYmxvY2tzLCByZXNvbHZpbmcgaW4gdGhlIGZvbGxvd2luZyBvcmRlcjpcbiAgICogICAgIC0gb3ZlcnJpZGUgYmxvY2tzIHNwZWNpZmllZCB3aGVuIGluaXRpYWxpemVkXG4gICAqICAgICAtIGJsb2NrcyByZXNvbHZlZCBmcm9tIHRoZSBhc3NvY2lhdGVkIHRlbXBsYXRlXG4gICAqICAgICAtIGJsb2NrcyByZXNvbHZlZCBmcm9tIHRoZSBwYXJlbnQgdGVtcGxhdGUgd2hlbiBleHRlbmRpbmcgKGV4Y2VwdCB3aGVuIGV4Y2x1ZGVkKVxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGluY2x1ZGVQYXJlbnRCbG9ja3MgV2hldGhlciB0byBnZXQgYmxvY2tzIGZyb20gdGhlIHBhcmVudCB0ZW1wbGF0ZSB3aGVuIGV4dGVuZGluZywgd2lsbCBhbHdheXMgZG8gc28gYnkgZGVmYXVsdC5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cblxuXG4gIFR3aWcuUGFyc2VTdGF0ZS5wcm90b3R5cGUuZ2V0QmxvY2tzID0gZnVuY3Rpb24gKGluY2x1ZGVQYXJlbnRCbG9ja3MpIHtcbiAgICB2YXIgYmxvY2tzID0ge307XG5cbiAgICBpZiAoaW5jbHVkZVBhcmVudEJsb2NrcyAhPT0gZmFsc2UgJiYgdGhpcy50ZW1wbGF0ZS5wYXJlbnRUZW1wbGF0ZSAhPT0gbnVsbCAmJiAvLyBQcmV2ZW50IGluZmluaXRlIGxvb3BcbiAgICB0aGlzLnRlbXBsYXRlLnBhcmVudFRlbXBsYXRlICE9PSB0aGlzLnRlbXBsYXRlKSB7XG4gICAgICAvLyBCbG9ja3MgZnJvbSB0aGUgcGFyZW50IHRlbXBsYXRlIHdoZW4gZXh0ZW5kaW5nXG4gICAgICBibG9ja3MgPSB0aGlzLnRlbXBsYXRlLnBhcmVudFRlbXBsYXRlLmdldEJsb2NrcygpO1xuICAgIH1cblxuICAgIGJsb2NrcyA9IF9vYmplY3RTcHJlYWQoe30sIGJsb2Nrcywge30sIHRoaXMudGVtcGxhdGUuZ2V0QmxvY2tzKCksIHt9LCB0aGlzLm92ZXJyaWRlQmxvY2tzKTtcbiAgICByZXR1cm4gYmxvY2tzO1xuICB9O1xuICAvKipcbiAgICogR2V0IHRoZSBjbG9zZXN0IHRva2VuIG9mIGEgc3BlY2lmaWMgdHlwZSB0byB0aGUgY3VycmVudCBuZXN0IGxldmVsLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGUgIFRoZSBsb2dpYyB0b2tlbiB0eXBlXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cblxuICBUd2lnLlBhcnNlU3RhdGUucHJvdG90eXBlLmdldE5lc3RpbmdTdGFja1Rva2VuID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgbWF0Y2hpbmdUb2tlbjtcbiAgICB0aGlzLm5lc3RpbmdTdGFjay5mb3JFYWNoKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgaWYgKG1hdGNoaW5nVG9rZW4gPT09IHVuZGVmaW5lZCAmJiB0b2tlbi50eXBlID09PSB0eXBlKSB7XG4gICAgICAgIG1hdGNoaW5nVG9rZW4gPSB0b2tlbjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWF0Y2hpbmdUb2tlbjtcbiAgfTtcbiAgLyoqXG4gICAqIFBhcnNlIGEgc2V0IG9mIHRva2VucyB1c2luZyB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gdG9rZW5zIFRoZSBjb21waWxlZCB0b2tlbnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHNldCB0aGUgc3RhdGUgdG8gd2hpbGUgcGFyc2luZy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbGxvd0FzeW5jIFdoZXRoZXIgdG8gcGFyc2UgYXN5bmNocm9ub3VzbHkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBibG9ja3MgQmxvY2tzIHRoYXQgc2hvdWxkIG92ZXJyaWRlIGFueSBkZWZpbmVkIHdoaWxlIHBhcnNpbmcuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlbmRlcmVkIHRva2Vucy5cbiAgICpcbiAgICovXG5cblxuICBUd2lnLlBhcnNlU3RhdGUucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHRva2VucywgY29udGV4dCwgYWxsb3dBc3luYykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXM7XG4gICAgdmFyIG91dHB1dCA9IFtdOyAvLyBTdG9yZSBhbnkgZXJyb3IgdGhhdCBtaWdodCBiZSB0aHJvd24gYnkgdGhlIHByb21pc2UgY2hhaW4uXG5cbiAgICB2YXIgZXJyID0gbnVsbDsgLy8gVGhpcyB3aWxsIGJlIHNldCB0byBpc0FzeW5jIGlmIHRlbXBsYXRlIHJlbmRlcnMgc3luY2hyb25vdXNseVxuXG4gICAgdmFyIGlzQXN5bmMgPSB0cnVlO1xuICAgIHZhciBwcm9taXNlID0gbnVsbDsgLy8gVHJhY2sgbG9naWMgY2hhaW5zXG5cbiAgICB2YXIgY2hhaW4gPSB0cnVlO1xuXG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgIHN0YXRlLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICAvKlxuICAgICAqIEV4dHJhY3RlZCBpbnRvIGl0J3Mgb3duIGZ1bmN0aW9uIHN1Y2ggdGhhdCB0aGUgZnVuY3Rpb25cbiAgICAgKiBkb2VzIG5vdCBnZXQgcmVjcmVhdGVkIG92ZXIgYW5kIG92ZXIgYWdhaW4gaW4gdGhlIGBmb3JFYWNoYFxuICAgICAqIGxvb3AgYmVsb3cuIFRoaXMgbWV0aG9kIGNhbiBiZSBjb21waWxlZCBhbmQgb3B0aW1pemVkXG4gICAgICogYSBzaW5nbGUgdGltZSBpbnN0ZWFkIG9mIGJlaW5nIHJlY3JlYXRlZCBvbiBlYWNoIGl0ZXJhdGlvbi5cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gb3V0cHV0UHVzaChvKSB7XG4gICAgICBvdXRwdXQucHVzaChvKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVRva2VuTG9naWMobG9naWMpIHtcbiAgICAgIGlmICh0eXBlb2YgbG9naWMuY2hhaW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNoYWluID0gbG9naWMuY2hhaW47XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbG9naWMuY29udGV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc3RhdGUuY29udGV4dCA9IGxvZ2ljLmNvbnRleHQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbG9naWMub3V0cHV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvdXRwdXQucHVzaChsb2dpYy5vdXRwdXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByb21pc2UgPSBUd2lnLmFzeW5jLmZvckVhY2godG9rZW5zLCBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgIFR3aWcubG9nLmRlYnVnKCdUd2lnLlBhcnNlU3RhdGUucGFyc2U6ICcsICdQYXJzaW5nIHRva2VuOiAnLCB0b2tlbik7XG5cbiAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlIFR3aWcudG9rZW4udHlwZS5yYXc6XG4gICAgICAgICAgb3V0cHV0LnB1c2goVHdpZy5maWx0ZXJzLnJhdyh0b2tlbi52YWx1ZSkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgVHdpZy50b2tlbi50eXBlLmxvZ2ljOlxuICAgICAgICAgIHJldHVybiBUd2lnLmxvZ2ljLnBhcnNlQXN5bmMuY2FsbChzdGF0ZSwgdG9rZW4udG9rZW5cbiAgICAgICAgICAvKiBsb2dpY1Rva2VuICovXG4gICAgICAgICAgLCBzdGF0ZS5jb250ZXh0LCBjaGFpbikudGhlbihwYXJzZVRva2VuTG9naWMpO1xuXG4gICAgICAgIGNhc2UgVHdpZy50b2tlbi50eXBlLmNvbW1lbnQ6XG4gICAgICAgICAgLy8gRG8gbm90aGluZywgY29tbWVudHMgc2hvdWxkIGJlIGlnbm9yZWRcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gRmFsbCB0aHJvdWdoIHdoaXRlc3BhY2UgdG8gb3V0cHV0XG5cbiAgICAgICAgY2FzZSBUd2lnLnRva2VuLnR5cGUub3V0cHV0V2hpdGVzcGFjZVByZTpcbiAgICAgICAgY2FzZSBUd2lnLnRva2VuLnR5cGUub3V0cHV0V2hpdGVzcGFjZVBvc3Q6XG4gICAgICAgIGNhc2UgVHdpZy50b2tlbi50eXBlLm91dHB1dFdoaXRlc3BhY2VCb3RoOlxuICAgICAgICBjYXNlIFR3aWcudG9rZW4udHlwZS5vdXRwdXQ6XG4gICAgICAgICAgVHdpZy5sb2cuZGVidWcoJ1R3aWcuUGFyc2VTdGF0ZS5wYXJzZTogJywgJ091dHB1dCB0b2tlbjogJywgdG9rZW4uc3RhY2spOyAvLyBQYXJzZSB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBpbiB0aGUgZ2l2ZW4gY29udGV4dFxuXG4gICAgICAgICAgcmV0dXJuIFR3aWcuZXhwcmVzc2lvbi5wYXJzZUFzeW5jLmNhbGwoc3RhdGUsIHRva2VuLnN0YWNrLCBzdGF0ZS5jb250ZXh0KS50aGVuKG91dHB1dFB1c2gpO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBvdXRwdXQgPSBUd2lnLm91dHB1dC5jYWxsKHN0YXRlLnRlbXBsYXRlLCBvdXRwdXQpO1xuICAgICAgaXNBc3luYyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKGFsbG93QXN5bmMpIHtcbiAgICAgICAgaGFuZGxlRXhjZXB0aW9uKHN0YXRlLCBlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIGVyciA9IGVycm9yO1xuICAgIH0pOyAvLyBJZiBgYWxsb3dBc3luY2Agd2Ugd2lsbCBhbHdheXMgcmV0dXJuIGEgcHJvbWlzZSBzaW5jZSB3ZSBkbyBub3RcbiAgICAvLyBrbm93IGluIGFkdmFuY2UgaWYgd2UgYXJlIGdvaW5nIHRvIHJ1biBhc3luY2hyb25vdXNseSBvciBub3QuXG5cbiAgICBpZiAoYWxsb3dBc3luYykge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfSAvLyBIYW5kbGUgZXJyb3JzIGhlcmUgaWYgd2UgZmFpbCBzeW5jaHJvbm91c2x5LlxuXG5cbiAgICBpZiAoZXJyICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gaGFuZGxlRXhjZXB0aW9uKHN0YXRlLCBlcnIpO1xuICAgIH0gLy8gSWYgYGFsbG93QXN5bmNgIGlzIG5vdCB0cnVlIHdlIHNob3VsZCBub3QgYWxsb3cgdGhlIHVzZXJcbiAgICAvLyB0byB1c2UgYXN5bmNocm9ub3VzIGZ1bmN0aW9ucyBvciBmaWx0ZXJzLlxuXG5cbiAgICBpZiAoaXNBc3luYykge1xuICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoJ1lvdSBhcmUgdXNpbmcgVHdpZy5qcyBpbiBzeW5jIG1vZGUgaW4gY29tYmluYXRpb24gd2l0aCBhc3luYyBleHRlbnNpb25zLicpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgdHdpZy5qcyB0ZW1wbGF0ZS5cbiAgICpcbiAgICogUGFyYW1ldGVyczoge1xuICAgKiAgICAgIGRhdGE6ICAgVGhlIHRlbXBsYXRlLCBlaXRoZXIgcHJlLWNvbXBpbGVkIHRva2VucyBvciBhIHN0cmluZyB0ZW1wbGF0ZVxuICAgKiAgICAgIGlkOiAgICAgVGhlIG5hbWUgb2YgdGhpcyB0ZW1wbGF0ZVxuICAgKiB9XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgVGhlIHRlbXBsYXRlIHBhcmFtZXRlcnMuXG4gICAqL1xuXG5cbiAgVHdpZy5UZW1wbGF0ZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICB2YXIgZGF0YSA9IHBhcmFtcy5kYXRhLFxuICAgICAgICBpZCA9IHBhcmFtcy5pZCxcbiAgICAgICAgYmFzZSA9IHBhcmFtcy5iYXNlLFxuICAgICAgICBwYXRoID0gcGFyYW1zLnBhdGgsXG4gICAgICAgIHVybCA9IHBhcmFtcy51cmwsXG4gICAgICAgIG5hbWUgPSBwYXJhbXMubmFtZSxcbiAgICAgICAgbWV0aG9kID0gcGFyYW1zLm1ldGhvZCxcbiAgICAgICAgb3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zOyAvLyAjIFdoYXQgaXMgc3RvcmVkIGluIGEgVHdpZy5UZW1wbGF0ZVxuICAgIC8vXG4gICAgLy8gVGhlIFR3aWcgVGVtcGxhdGUgaG9sZCBzZXZlcmFsIGNodWNrcyBvZiBkYXRhLlxuICAgIC8vXG4gICAgLy8gICAgIHtcbiAgICAvLyAgICAgICAgICBpZDogICAgIFRoZSB0b2tlbiBJRCAoaWYgYW55KVxuICAgIC8vICAgICAgICAgIHRva2VuczogVGhlIGxpc3Qgb2YgdG9rZW5zIHRoYXQgbWFrZXMgdXAgdGhpcyB0ZW1wbGF0ZS5cbiAgICAvLyAgICAgICAgICBiYXNlOiAgIFRoZSBiYXNlIHRlbXBsYXRlIChpZiBhbnkpXG4gICAgLy8gICAgICAgICAgICBvcHRpb25zOiAge1xuICAgIC8vICAgICAgICAgICAgICAgIENvbXBpbGVyL3BhcnNlciBvcHRpb25zXG4gICAgLy9cbiAgICAvLyAgICAgICAgICAgICAgICBzdHJpY3RfdmFyaWFibGVzOiB0cnVlL2ZhbHNlXG4gICAgLy8gICAgICAgICAgICAgICAgICAgIFNob3VsZCBtaXNzaW5nIHZhcmlhYmxlL2tleXMgZW1pdCBhbiBlcnJvciBtZXNzYWdlLiBJZiBmYWxzZSwgdGhleSBkZWZhdWx0IHRvIG51bGwuXG4gICAgLy8gICAgICAgICAgICB9XG4gICAgLy8gICAgIH1cbiAgICAvL1xuXG4gICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICB0aGlzLmJsb2NrcyA9IHtcbiAgICAgIGRlZmluZWQ6IHt9LFxuICAgICAgaW1wb3J0ZWQ6IHt9XG4gICAgfTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucGFyZW50VGVtcGxhdGUgPSBudWxsO1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy51cmwgPSB1cmw7XG5cbiAgICBpZiAoaXMoJ1N0cmluZycsIGRhdGEpKSB7XG4gICAgICB0aGlzLnRva2VucyA9IFR3aWcucHJlcGFyZS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRva2VucyA9IGRhdGE7XG4gICAgfVxuXG4gICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIFR3aWcuVGVtcGxhdGVzLnNhdmUodGhpcyk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogR2V0IGEgYmxvY2sgYnkgaXRzIG5hbWUsIHJlc29sdmluZyBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOlxuICAgKiAgICAgLSBibG9ja3MgZGVmaW5lZCBpbiB0aGUgdGVtcGxhdGUgaXRzZWxmXG4gICAqICAgICAtIGJsb2NrcyBpbXBvcnRlZCBmcm9tIGFub3RoZXIgdGVtcGxhdGVcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGJsb2NrIHRvIHJldHVybi5cbiAgICogQHBhcmFtIHtCb29sZWFufSBjaGVja09ubHlJbmhlcml0ZWRCbG9ja3MgV2hldGhlciB0byBza2lwIGNoZWNraW5nIHRoZSBibG9ja3MgZGVmaW5lZCBpbiB0aGUgdGVtcGxhdGUgaXRzZWxmLCB3aWxsIG5vdCBza2lwIGJ5IGRlZmF1bHQuXG4gICAqXG4gICAqIEByZXR1cm4ge1R3aWcuQmxvY2t8dW5kZWZpbmVkfVxuICAgKi9cblxuXG4gIFR3aWcuVGVtcGxhdGUucHJvdG90eXBlLmdldEJsb2NrID0gZnVuY3Rpb24gKG5hbWUsIGNoZWNrT25seUluaGVyaXRlZEJsb2Nrcykge1xuICAgIHZhciBjaGVja0ltcG9ydHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgdmFyIGJsb2NrO1xuXG4gICAgaWYgKGNoZWNrT25seUluaGVyaXRlZEJsb2NrcyAhPT0gdHJ1ZSkge1xuICAgICAgYmxvY2sgPSB0aGlzLmJsb2Nrcy5kZWZpbmVkW25hbWVdO1xuICAgIH1cblxuICAgIGlmIChjaGVja0ltcG9ydHMgJiYgYmxvY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYmxvY2sgPSB0aGlzLmJsb2Nrcy5pbXBvcnRlZFtuYW1lXTtcbiAgICB9XG5cbiAgICBpZiAoYmxvY2sgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnBhcmVudFRlbXBsYXRlICE9PSBudWxsKSB7XG4gICAgICAvKipcbiAgICAgICAqIEJsb2NrIGRlZmluZWQgaW4gdGhlIHBhcmVudCB0ZW1wbGF0ZSB3aGVuIGV4dGVuZGluZy5cbiAgICAgICAqIFRoaXMgcmVjdXJzaW9uIGlzIHVzZWZ1bCB0byBpbmhlcml0IGZyb20gYXNjZW5kYW50cy5cbiAgICAgICAqIEJ1dCB0YWtlIGNhcmUgb2Ygbm90IGNvbnNpZGVyaW5nIGFzY2VuZGFudHMnIHslIHVzZSAlfVxuICAgICAgICovXG4gICAgICBibG9jayA9IHRoaXMucGFyZW50VGVtcGxhdGUuZ2V0QmxvY2sobmFtZSwgY2hlY2tPbmx5SW5oZXJpdGVkQmxvY2tzLCBjaGVja0ltcG9ydHMgPSBmYWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJsb2NrO1xuICB9O1xuICAvKipcbiAgICogR2V0IGFsbCB0aGUgYXZhaWxhYmxlIGJsb2NrcywgcmVzb2x2aW5nIGluIHRoZSBmb2xsb3dpbmcgb3JkZXI6XG4gICAqICAgICAtIGJsb2NrcyBkZWZpbmVkIGluIHRoZSB0ZW1wbGF0ZSBpdHNlbGZcbiAgICogICAgIC0gYmxvY2tzIGltcG9ydGVkIGZyb20gb3RoZXIgdGVtcGxhdGVzXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cblxuICBUd2lnLlRlbXBsYXRlLnByb3RvdHlwZS5nZXRCbG9ja3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJsb2NrcyA9IHt9O1xuICAgIGJsb2NrcyA9IF9vYmplY3RTcHJlYWQoe30sIGJsb2Nrcywge30sIHRoaXMuYmxvY2tzLmltcG9ydGVkLCB7fSwgdGhpcy5ibG9ja3MuZGVmaW5lZCk7XG4gICAgcmV0dXJuIGJsb2NrcztcbiAgfTtcblxuICBUd2lnLlRlbXBsYXRlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoY29udGV4dCwgcGFyYW1zLCBhbGxvd0FzeW5jKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gdGhpcztcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgcmV0dXJuIFR3aWcuYXN5bmMucG90ZW50aWFsbHlBc3luYyh0ZW1wbGF0ZSwgYWxsb3dBc3luYywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0YXRlID0gbmV3IFR3aWcuUGFyc2VTdGF0ZSh0ZW1wbGF0ZSwgcGFyYW1zLmJsb2Nrcyk7XG4gICAgICByZXR1cm4gc3RhdGUucGFyc2VBc3luYyh0ZW1wbGF0ZS50b2tlbnMsIGNvbnRleHQpLnRoZW4oZnVuY3Rpb24gKG91dHB1dCkge1xuICAgICAgICB2YXIgcGFyZW50VGVtcGxhdGU7XG4gICAgICAgIHZhciB1cmw7XG5cbiAgICAgICAgaWYgKHRlbXBsYXRlLnBhcmVudFRlbXBsYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gVGhpcyB0ZW1wbGF0ZSBleHRlbmRzIGFub3RoZXIgdGVtcGxhdGVcbiAgICAgICAgICBpZiAodGVtcGxhdGUub3B0aW9ucy5hbGxvd0lubGluZUluY2x1ZGVzKSB7XG4gICAgICAgICAgICAvLyBUaGUgdGVtcGxhdGUgaXMgcHJvdmlkZWQgaW5saW5lXG4gICAgICAgICAgICBwYXJlbnRUZW1wbGF0ZSA9IFR3aWcuVGVtcGxhdGVzLmxvYWQodGVtcGxhdGUucGFyZW50VGVtcGxhdGUpO1xuXG4gICAgICAgICAgICBpZiAocGFyZW50VGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgcGFyZW50VGVtcGxhdGUub3B0aW9ucyA9IHRlbXBsYXRlLm9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBDaGVjayBmb3IgdGhlIHRlbXBsYXRlIGZpbGUgdmlhIGluY2x1ZGVcblxuXG4gICAgICAgICAgaWYgKCFwYXJlbnRUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdXJsID0gVHdpZy5wYXRoLnBhcnNlUGF0aCh0ZW1wbGF0ZSwgdGVtcGxhdGUucGFyZW50VGVtcGxhdGUpO1xuICAgICAgICAgICAgcGFyZW50VGVtcGxhdGUgPSBUd2lnLlRlbXBsYXRlcy5sb2FkUmVtb3RlKHVybCwge1xuICAgICAgICAgICAgICBtZXRob2Q6IHRlbXBsYXRlLmdldExvYWRlck1ldGhvZCgpLFxuICAgICAgICAgICAgICBiYXNlOiB0ZW1wbGF0ZS5iYXNlLFxuICAgICAgICAgICAgICBhc3luYzogZmFsc2UsXG4gICAgICAgICAgICAgIGlkOiB1cmwsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IHRlbXBsYXRlLm9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRlbXBsYXRlLnBhcmVudFRlbXBsYXRlID0gcGFyZW50VGVtcGxhdGU7XG4gICAgICAgICAgcmV0dXJuIHRlbXBsYXRlLnBhcmVudFRlbXBsYXRlLnJlbmRlckFzeW5jKHN0YXRlLmNvbnRleHQsIHtcbiAgICAgICAgICAgIGJsb2Nrczogc3RhdGUuZ2V0QmxvY2tzKGZhbHNlKSxcbiAgICAgICAgICAgIGlzSW5jbHVkZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy5pc0luY2x1ZGUgPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dC52YWx1ZU9mKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBUd2lnLlRlbXBsYXRlLnByb3RvdHlwZS5pbXBvcnRGaWxlID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgICB2YXIgdXJsID0gbnVsbDtcbiAgICB2YXIgc3ViVGVtcGxhdGU7XG5cbiAgICBpZiAoIXRoaXMudXJsICYmIHRoaXMub3B0aW9ucy5hbGxvd0lubGluZUluY2x1ZGVzKSB7XG4gICAgICBmaWxlID0gdGhpcy5wYXRoID8gVHdpZy5wYXRoLnBhcnNlUGF0aCh0aGlzLCBmaWxlKSA6IGZpbGU7XG4gICAgICBzdWJUZW1wbGF0ZSA9IFR3aWcuVGVtcGxhdGVzLmxvYWQoZmlsZSk7XG5cbiAgICAgIGlmICghc3ViVGVtcGxhdGUpIHtcbiAgICAgICAgc3ViVGVtcGxhdGUgPSBUd2lnLlRlbXBsYXRlcy5sb2FkUmVtb3RlKHVybCwge1xuICAgICAgICAgIGlkOiBmaWxlLFxuICAgICAgICAgIG1ldGhvZDogdGhpcy5nZXRMb2FkZXJNZXRob2QoKSxcbiAgICAgICAgICBhc3luYzogZmFsc2UsXG4gICAgICAgICAgcGF0aDogZmlsZSxcbiAgICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFzdWJUZW1wbGF0ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKCdVbmFibGUgdG8gZmluZCB0aGUgdGVtcGxhdGUgJyArIGZpbGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN1YlRlbXBsYXRlLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICByZXR1cm4gc3ViVGVtcGxhdGU7XG4gICAgfVxuXG4gICAgdXJsID0gVHdpZy5wYXRoLnBhcnNlUGF0aCh0aGlzLCBmaWxlKTsgLy8gTG9hZCBibG9ja3MgZnJvbSBhbiBleHRlcm5hbCBmaWxlXG5cbiAgICBzdWJUZW1wbGF0ZSA9IFR3aWcuVGVtcGxhdGVzLmxvYWRSZW1vdGUodXJsLCB7XG4gICAgICBtZXRob2Q6IHRoaXMuZ2V0TG9hZGVyTWV0aG9kKCksXG4gICAgICBiYXNlOiB0aGlzLmJhc2UsXG4gICAgICBhc3luYzogZmFsc2UsXG4gICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICBpZDogdXJsXG4gICAgfSk7XG4gICAgcmV0dXJuIHN1YlRlbXBsYXRlO1xuICB9O1xuXG4gIFR3aWcuVGVtcGxhdGUucHJvdG90eXBlLmdldExvYWRlck1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5wYXRoKSB7XG4gICAgICByZXR1cm4gJ2ZzJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy51cmwpIHtcbiAgICAgIHJldHVybiAnYWpheCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubWV0aG9kIHx8ICdmcyc7XG4gIH07XG5cbiAgVHdpZy5UZW1wbGF0ZS5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGUgaW50byByYXcgSlNcbiAgICByZXR1cm4gVHdpZy5jb21waWxlci5jb21waWxlKHRoaXMsIG9wdGlvbnMpO1xuICB9O1xuICAvKipcbiAgICogQ3JlYXRlIHNhZmUgb3V0cHV0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBDb250ZW50IHNhZmUgdG8gb3V0cHV0XG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ30gQ29udGVudCB3cmFwcGVkIGludG8gYSBTdHJpbmdcbiAgICovXG5cblxuICBUd2lnLk1hcmt1cCA9IGZ1bmN0aW9uIChjb250ZW50LCBzdHJhdGVneSkge1xuICAgIGlmICh0eXBlb2YgY29udGVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXctd3JhcHBlcnMsIHVuaWNvcm4vbmV3LWZvci1idWlsdGlucyAqL1xuXG5cbiAgICB2YXIgb3V0cHV0ID0gbmV3IFN0cmluZyhjb250ZW50KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbiAgICBvdXRwdXQudHdpZ01hcmt1cCA9IHR5cGVvZiBzdHJhdGVneSA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogc3RyYXRlZ3k7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICByZXR1cm4gVHdpZztcbn07XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vLyAjIyB0d2lnLmNvbXBpbGVyLmpzXG4vL1xuLy8gVGhpcyBmaWxlIGhhbmRsZXMgY29tcGlsaW5nIHRlbXBsYXRlcyBpbnRvIEpTXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUd2lnKSB7XG4gIC8qKlxuICAgKiBOYW1lc3BhY2UgZm9yIGNvbXBpbGF0aW9uLlxuICAgKi9cbiAgVHdpZy5jb21waWxlciA9IHtcbiAgICBtb2R1bGU6IHt9XG4gIH07IC8vIENvbXBpbGUgYSBUd2lnIFRlbXBsYXRlIHRvIG91dHB1dC5cblxuICBUd2lnLmNvbXBpbGVyLmNvbXBpbGUgPSBmdW5jdGlvbiAodGVtcGxhdGUsIG9wdGlvbnMpIHtcbiAgICAvLyBHZXQgdG9rZW5zXG4gICAgdmFyIHRva2VucyA9IEpTT04uc3RyaW5naWZ5KHRlbXBsYXRlLnRva2Vucyk7XG4gICAgdmFyIGlkID0gdGVtcGxhdGUuaWQ7XG4gICAgdmFyIG91dHB1dCA9IG51bGw7XG5cbiAgICBpZiAob3B0aW9ucy5tb2R1bGUpIHtcbiAgICAgIGlmIChUd2lnLmNvbXBpbGVyLm1vZHVsZVtvcHRpb25zLm1vZHVsZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcignVW5hYmxlIHRvIGZpbmQgbW9kdWxlIHR5cGUgJyArIG9wdGlvbnMubW9kdWxlKTtcbiAgICAgIH1cblxuICAgICAgb3V0cHV0ID0gVHdpZy5jb21waWxlci5tb2R1bGVbb3B0aW9ucy5tb2R1bGVdKGlkLCB0b2tlbnMsIG9wdGlvbnMudHdpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dCA9IFR3aWcuY29tcGlsZXIud3JhcChpZCwgdG9rZW5zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIFR3aWcuY29tcGlsZXIubW9kdWxlID0ge1xuICAgIGFtZDogZnVuY3Rpb24gYW1kKGlkLCB0b2tlbnMsIHBhdGhUb1R3aWcpIHtcbiAgICAgIHJldHVybiAnZGVmaW5lKFtcIicgKyBwYXRoVG9Ud2lnICsgJ1wiXSwgZnVuY3Rpb24gKFR3aWcpIHtcXG5cXHR2YXIgdHdpZywgdGVtcGxhdGVzO1xcbnR3aWcgPSBUd2lnLnR3aWc7XFxudGVtcGxhdGVzID0gJyArIFR3aWcuY29tcGlsZXIud3JhcChpZCwgdG9rZW5zKSArICdcXG5cXHRyZXR1cm4gdGVtcGxhdGVzO1xcbn0pOyc7XG4gICAgfSxcbiAgICBub2RlOiBmdW5jdGlvbiBub2RlKGlkLCB0b2tlbnMpIHtcbiAgICAgIHJldHVybiAndmFyIHR3aWcgPSByZXF1aXJlKFwidHdpZ1wiKS50d2lnO1xcbmV4cG9ydHMudGVtcGxhdGUgPSAnICsgVHdpZy5jb21waWxlci53cmFwKGlkLCB0b2tlbnMpO1xuICAgIH0sXG4gICAgY2pzMjogZnVuY3Rpb24gY2pzMihpZCwgdG9rZW5zLCBwYXRoVG9Ud2lnKSB7XG4gICAgICByZXR1cm4gJ21vZHVsZS5kZWNsYXJlKFt7IHR3aWc6IFwiJyArIHBhdGhUb1R3aWcgKyAnXCIgfV0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcXG5cXHR2YXIgdHdpZyA9IHJlcXVpcmUoXCJ0d2lnXCIpLnR3aWc7XFxuXFx0ZXhwb3J0cy50ZW1wbGF0ZSA9ICcgKyBUd2lnLmNvbXBpbGVyLndyYXAoaWQsIHRva2VucykgKyAnXFxufSk7JztcbiAgICB9XG4gIH07XG5cbiAgVHdpZy5jb21waWxlci53cmFwID0gZnVuY3Rpb24gKGlkLCB0b2tlbnMpIHtcbiAgICByZXR1cm4gJ3R3aWcoe2lkOlwiJyArIGlkLnJlcGxhY2UoJ1wiJywgJ1xcXFxcIicpICsgJ1wiLCBkYXRhOicgKyB0b2tlbnMgKyAnLCBwcmVjb21waWxlZDogdHJ1ZX0pO1xcbic7XG4gIH07XG5cbiAgcmV0dXJuIFR3aWc7XG59O1xuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xuXG52YXIgX3RvQ29uc3VtYWJsZUFycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxMCkpO1xuXG4vLyAjIyB0d2lnLmV4cHJlc3Npb24uanNcbi8vXG4vLyBUaGlzIGZpbGUgaGFuZGxlcyB0b2tlbml6aW5nLCBjb21waWxpbmcgYW5kIHBhcnNpbmcgZXhwcmVzc2lvbnMuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUd2lnKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBwYXJzZVBhcmFtcyhzdGF0ZSwgcGFyYW1zLCBjb250ZXh0KSB7XG4gICAgaWYgKHBhcmFtcykge1xuICAgICAgcmV0dXJuIFR3aWcuZXhwcmVzc2lvbi5wYXJzZUFzeW5jLmNhbGwoc3RhdGUsIHBhcmFtcywgY29udGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFR3aWcuUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgfVxuICAvKipcbiAgICogTmFtZXNwYWNlIGZvciBleHByZXNzaW9uIGhhbmRsaW5nLlxuICAgKi9cblxuXG4gIFR3aWcuZXhwcmVzc2lvbiA9IHt9O1xuXG4gIF9fd2VicGFja19yZXF1aXJlX18oMTQpKFR3aWcpO1xuICAvKipcbiAgICogUmVzZXJ2ZWQgd29yZCB0aGF0IGNhbid0IGJlIHVzZWQgYXMgdmFyaWFibGUgbmFtZXMuXG4gICAqL1xuXG5cbiAgVHdpZy5leHByZXNzaW9uLnJlc2VydmVkV29yZHMgPSBbJ3RydWUnLCAnZmFsc2UnLCAnbnVsbCcsICdUUlVFJywgJ0ZBTFNFJywgJ05VTEwnLCAnX2NvbnRleHQnLCAnYW5kJywgJ2ItYW5kJywgJ29yJywgJ2Itb3InLCAnYi14b3InLCAnaW4nLCAnbm90IGluJywgJ2lmJywgJ21hdGNoZXMnLCAnc3RhcnRzJywgJ2VuZHMnLCAnd2l0aCddO1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdG9rZW5zIHVzZWQgaW4gZXhwcmVzc2lvbnMuXG4gICAqL1xuXG4gIFR3aWcuZXhwcmVzc2lvbi50eXBlID0ge1xuICAgIGNvbW1hOiAnVHdpZy5leHByZXNzaW9uLnR5cGUuY29tbWEnLFxuICAgIG9wZXJhdG9yOiB7XG4gICAgICB1bmFyeTogJ1R3aWcuZXhwcmVzc2lvbi50eXBlLm9wZXJhdG9yLnVuYXJ5JyxcbiAgICAgIGJpbmFyeTogJ1R3aWcuZXhwcmVzc2lvbi50eXBlLm9wZXJhdG9yLmJpbmFyeSdcbiAgICB9LFxuICAgIHN0cmluZzogJ1R3aWcuZXhwcmVzc2lvbi50eXBlLnN0cmluZycsXG4gICAgYm9vbDogJ1R3aWcuZXhwcmVzc2lvbi50eXBlLmJvb2wnLFxuICAgIHNsaWNlOiAnVHdpZy5leHByZXNzaW9uLnR5cGUuc2xpY2UnLFxuICAgIGFycmF5OiB7XG4gICAgICBzdGFydDogJ1R3aWcuZXhwcmVzc2lvbi50eXBlLmFycmF5LnN0YXJ0JyxcbiAgICAgIGVuZDogJ1R3aWcuZXhwcmVzc2lvbi50eXBlLmFycmF5LmVuZCdcbiAgICB9LFxuICAgIG9iamVjdDoge1xuICAgICAgc3RhcnQ6ICdUd2lnLmV4cHJlc3Npb24udHlwZS5vYmplY3Quc3RhcnQnLFxuICAgICAgZW5kOiAnVHdpZy5leHByZXNzaW9uLnR5cGUub2JqZWN0LmVuZCdcbiAgICB9LFxuICAgIHBhcmFtZXRlcjoge1xuICAgICAgc3RhcnQ6ICdUd2lnLmV4cHJlc3Npb24udHlwZS5wYXJhbWV0ZXIuc3RhcnQnLFxuICAgICAgZW5kOiAnVHdpZy5leHByZXNzaW9uLnR5cGUucGFyYW1ldGVyLmVuZCdcbiAgICB9LFxuICAgIHN1YmV4cHJlc3Npb246IHtcbiAgICAgIHN0YXJ0OiAnVHdpZy5leHByZXNzaW9uLnR5cGUuc3ViZXhwcmVzc2lvbi5zdGFydCcsXG4gICAgICBlbmQ6ICdUd2lnLmV4cHJlc3Npb24udHlwZS5zdWJleHByZXNzaW9uLmVuZCdcbiAgICB9LFxuICAgIGtleToge1xuICAgICAgcGVyaW9kOiAnVHdpZy5leHByZXNzaW9uLnR5cGUua2V5LnBlcmlvZCcsXG4gICAgICBicmFja2V0czogJ1R3aWcuZXhwcmVzc2lvbi50eXBlLmtleS5icmFja2V0cydcbiAgICB9LFxuICAgIGZpbHRlcjogJ1R3aWcuZXhwcmVzc2lvbi50eXBlLmZpbHRlcicsXG4gICAgX2Z1bmN0aW9uOiAnVHdpZy5leHByZXNzaW9uLnR5cGUuX2Z1bmN0aW9uJyxcbiAgICB2YXJpYWJsZTogJ1R3aWcuZXhwcmVzc2lvbi50eXBlLnZhcmlhYmxlJyxcbiAgICBudW1iZXI6ICdUd2lnLmV4cHJlc3Npb24udHlwZS5udW1iZXInLFxuICAgIF9udWxsOiAnVHdpZy5leHByZXNzaW9uLnR5cGUubnVsbCcsXG4gICAgY29udGV4dDogJ1R3aWcuZXhwcmVzc2lvbi50eXBlLmNvbnRleHQnLFxuICAgIHRlc3Q6ICdUd2lnLmV4cHJlc3Npb24udHlwZS50ZXN0J1xuICB9O1xuICBUd2lnLmV4cHJlc3Npb24uc2V0ID0ge1xuICAgIC8vIFdoYXQgY2FuIGZvbGxvdyBhbiBleHByZXNzaW9uIChpbiBnZW5lcmFsKVxuICAgIG9wZXJhdGlvbnM6IFtUd2lnLmV4cHJlc3Npb24udHlwZS5maWx0ZXIsIFR3aWcuZXhwcmVzc2lvbi50eXBlLm9wZXJhdG9yLnVuYXJ5LCBUd2lnLmV4cHJlc3Npb24udHlwZS5vcGVyYXRvci5iaW5hcnksIFR3aWcuZXhwcmVzc2lvbi50eXBlLmFycmF5LmVuZCwgVHdpZy5leHByZXNzaW9uLnR5cGUub2JqZWN0LmVuZCwgVHdpZy5leHByZXNzaW9uLnR5cGUucGFyYW1ldGVyLmVuZCwgVHdpZy5leHByZXNzaW9uLnR5cGUuc3ViZXhwcmVzc2lvbi5lbmQsIFR3aWcuZXhwcmVzc2lvbi50eXBlLmNvbW1hLCBUd2lnLmV4cHJlc3Npb24udHlwZS50ZXN0XSxcbiAgICBleHByZXNzaW9uczogW1R3aWcuZXhwcmVzc2lvbi50eXBlLl9mdW5jdGlvbiwgVHdpZy5leHByZXNzaW9uLnR5cGUuYm9vbCwgVHdpZy5leHByZXNzaW9uLnR5cGUuc3RyaW5nLCBUd2lnLmV4cHJlc3Npb24udHlwZS52YXJpYWJsZSwgVHdpZy5leHByZXNzaW9uLnR5cGUubnVtYmVyLCBUd2lnLmV4cHJlc3Npb24udHlwZS5fbnVsbCwgVHdpZy5leHByZXNzaW9uLnR5cGUuY29udGV4dCwgVHdpZy5leHByZXNzaW9uLnR5cGUucGFyYW1ldGVyLnN0YXJ0LCBUd2lnLmV4cHJlc3Npb24udHlwZS5hcnJheS5zdGFydCwgVHdpZy5leHByZXNzaW9uLnR5cGUub2JqZWN0LnN0YXJ0LCBUd2lnLmV4cHJlc3Npb24udHlwZS5zdWJleHByZXNzaW9uLnN0YXJ0LCBUd2lnLmV4cHJlc3Npb24udHlwZS5vcGVyYXRvci51bmFyeV1cbiAgfTsgLy8gTW9zdCBleHByZXNzaW9ucyBhbGxvdyBhICcuJyBvciAnWycgYWZ0ZXIgdGhlbSwgc28gd2UgcHJvdmlkZSBhIGNvbnZlbmllbmNlIHNldFxuXG4gIFR3aWcuZXhwcmVzc2lvbi5zZXQub3BlcmF0aW9uc0V4dGVuZGVkID0gVHdpZy5leHByZXNzaW9uLnNldC5vcGVyYXRpb25zLmNvbmNhdChbVHdpZy5leHByZXNzaW9uLnR5cGUua2V5LnBlcmlvZCwgVHdpZy5leHByZXNzaW9uLnR5cGUua2V5LmJyYWNrZXRzLCBUd2lnLmV4cHJlc3Npb24udHlwZS5zbGljZV0pOyAvLyBTb21lIGNvbW1vbmx5IHVzZWQgY29tcGlsZSBhbmQgcGFyc2UgZnVuY3Rpb25zLlxuXG4gIFR3aWcuZXhwcmVzc2lvbi5mbiA9IHtcbiAgICBjb21waWxlOiB7XG4gICAgICBwdXNoOiBmdW5jdGlvbiBwdXNoKHRva2VuLCBzdGFjaywgb3V0cHV0KSB7XG4gICAgICAgIG91dHB1dC5wdXNoKHRva2VuKTtcbiAgICAgIH0sXG4gICAgICBwdXNoQm90aDogZnVuY3Rpb24gcHVzaEJvdGgodG9rZW4sIHN0YWNrLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LnB1c2godG9rZW4pO1xuICAgICAgICBzdGFjay5wdXNoKHRva2VuKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBhcnNlOiB7XG4gICAgICBwdXNoOiBmdW5jdGlvbiBwdXNoKHRva2VuLCBzdGFjaykge1xuICAgICAgICBzdGFjay5wdXNoKHRva2VuKTtcbiAgICAgIH0sXG4gICAgICBwdXNoVmFsdWU6IGZ1bmN0aW9uIHB1c2hWYWx1ZSh0b2tlbiwgc3RhY2spIHtcbiAgICAgICAgc3RhY2sucHVzaCh0b2tlbi52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9OyAvLyBUaGUgcmVndWxhciBleHByZXNzaW9ucyBhbmQgY29tcGlsZS9wYXJzZSBsb2dpYyB1c2VkIHRvIG1hdGNoIHRva2VucyBpbiBleHByZXNzaW9ucy5cbiAgLy9cbiAgLy8gUHJvcGVydGllczpcbiAgLy9cbiAgLy8gICAgICB0eXBlOiAgVGhlIHR5cGUgb2YgZXhwcmVzc2lvbiB0aGlzIG1hdGNoZXNcbiAgLy9cbiAgLy8gICAgICByZWdleDogT25lIG9yIG1vcmUgcmVndWxhciBleHByZXNzaW9ucyB0aGF0IG1hdGNoZSB0aGUgZm9ybWF0IG9mIHRoZSB0b2tlbi5cbiAgLy9cbiAgLy8gICAgICBuZXh0OiAgVmFsaWQgdG9rZW5zIHRoYXQgY2FuIG9jY3VyIG5leHQgaW4gdGhlIGV4cHJlc3Npb24uXG4gIC8vXG4gIC8vIEZ1bmN0aW9uczpcbiAgLy9cbiAgLy8gICAgICBjb21waWxlOiBBIGZ1bmN0aW9uIHRoYXQgY29tcGlsZXMgdGhlIHJhdyByZWd1bGFyIGV4cHJlc3Npb24gbWF0Y2ggaW50byBhIHRva2VuLlxuICAvL1xuICAvLyAgICAgIHBhcnNlOiAgIEEgZnVuY3Rpb24gdGhhdCBwYXJzZXMgdGhlIGNvbXBpbGVkIHRva2VuIGludG8gb3V0cHV0LlxuICAvL1xuXG4gIFR3aWcuZXhwcmVzc2lvbi5kZWZpbml0aW9ucyA9IFt7XG4gICAgdHlwZTogVHdpZy5leHByZXNzaW9uLnR5cGUudGVzdCxcbiAgICByZWdleDogL15pc1xccysobm90KT9cXHMqKFthLXpBLVpfXVxcdyooXFxzP2FzKT8pLyxcbiAgICBuZXh0OiBUd2lnLmV4cHJlc3Npb24uc2V0Lm9wZXJhdGlvbnMuY29uY2F0KFtUd2lnLmV4cHJlc3Npb24udHlwZS5wYXJhbWV0ZXIuc3RhcnRdKSxcbiAgICBjb21waWxlOiBmdW5jdGlvbiBjb21waWxlKHRva2VuLCBzdGFjaywgb3V0cHV0KSB7XG4gICAgICB0b2tlbi5maWx0ZXIgPSB0b2tlbi5tYXRjaFsyXTtcbiAgICAgIHRva2VuLm1vZGlmaWVyID0gdG9rZW4ubWF0Y2hbMV07XG4gICAgICBkZWxldGUgdG9rZW4ubWF0Y2g7XG4gICAgICBkZWxldGUgdG9rZW4udmFsdWU7XG4gICAgICBvdXRwdXQucHVzaCh0b2tlbik7XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UodG9rZW4sIHN0YWNrLCBjb250ZXh0KSB7XG4gICAgICB2YXIgdmFsdWUgPSBzdGFjay5wb3AoKTtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXM7XG4gICAgICByZXR1cm4gcGFyc2VQYXJhbXMoc3RhdGUsIHRva2VuLnBhcmFtcywgY29udGV4dCkudGhlbihmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBUd2lnLnRlc3QodG9rZW4uZmlsdGVyLCB2YWx1ZSwgcGFyYW1zKTtcblxuICAgICAgICBpZiAodG9rZW4ubW9kaWZpZXIgPT09ICdub3QnKSB7XG4gICAgICAgICAgc3RhY2sucHVzaCghcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFjay5wdXNoKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIHR5cGU6IFR3aWcuZXhwcmVzc2lvbi50eXBlLmNvbW1hLFxuICAgIC8vIE1hdGNoIGEgY29tbWFcbiAgICByZWdleDogL14sLyxcbiAgICBuZXh0OiBUd2lnLmV4cHJlc3Npb24uc2V0LmV4cHJlc3Npb25zLmNvbmNhdChbVHdpZy5leHByZXNzaW9uLnR5cGUuYXJyYXkuZW5kLCBUd2lnLmV4cHJlc3Npb24udHlwZS5vYmplY3QuZW5kXSksXG4gICAgY29tcGlsZTogZnVuY3Rpb24gY29tcGlsZSh0b2tlbiwgc3RhY2ssIG91dHB1dCkge1xuICAgICAgdmFyIGkgPSBzdGFjay5sZW5ndGggLSAxO1xuICAgICAgdmFyIHN0YWNrVG9rZW47XG4gICAgICBkZWxldGUgdG9rZW4ubWF0Y2g7XG4gICAgICBkZWxldGUgdG9rZW4udmFsdWU7IC8vIFBvcCB0b2tlbnMgb2ZmIHRoZSBzdGFjayB1bnRpbCB0aGUgc3RhcnQgb2YgdGhlIG9iamVjdFxuXG4gICAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgc3RhY2tUb2tlbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgIGlmIChzdGFja1Rva2VuLnR5cGUgPT09IFR3aWcuZXhwcmVzc2lvbi50eXBlLm9iamVjdC5zdGFydCB8fCBzdGFja1Rva2VuLnR5cGUgPT09IFR3aWcuZXhwcmVzc2lvbi50eXBlLnBhcmFtZXRlci5zdGFydCB8fCBzdGFja1Rva2VuLnR5cGUgPT09IFR3aWcuZXhwcmVzc2lvbi50eXBlLmFycmF5LnN0YXJ0KSB7XG4gICAgICAgICAgc3RhY2sucHVzaChzdGFja1Rva2VuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dC5wdXNoKHN0YWNrVG9rZW4pO1xuICAgICAgfVxuXG4gICAgICBvdXRwdXQucHVzaCh0b2tlbik7XG4gICAgfVxuICB9LCB7XG4gICAgLyoqXG4gICAgICogTWF0Y2ggYSBudW1iZXIgKGludGVnZXIgb3IgZGVjaW1hbClcbiAgICAgKi9cbiAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5udW1iZXIsXG4gICAgLy8gTWF0Y2ggYSBudW1iZXJcbiAgICByZWdleDogL14tP1xcZCsoXFwuXFxkKyk/LyxcbiAgICBuZXh0OiBUd2lnLmV4cHJlc3Npb24uc2V0Lm9wZXJhdGlvbnMsXG4gICAgY29tcGlsZTogZnVuY3Rpb24gY29tcGlsZSh0b2tlbiwgc3RhY2ssIG91dHB1dCkge1xuICAgICAgdG9rZW4udmFsdWUgPSBOdW1iZXIodG9rZW4udmFsdWUpO1xuICAgICAgb3V0cHV0LnB1c2godG9rZW4pO1xuICAgIH0sXG4gICAgcGFyc2U6IFR3aWcuZXhwcmVzc2lvbi5mbi5wYXJzZS5wdXNoVmFsdWVcbiAgfSwge1xuICAgIHR5cGU6IFR3aWcuZXhwcmVzc2lvbi50eXBlLm9wZXJhdG9yLmJpbmFyeSxcbiAgICAvLyBNYXRjaCBhbnkgb2YgPz8sID86LCArLCAqLCAvLCAtLCAlLCB+LCA8LCA8PSwgPiwgPj0sICE9LCA9PSwgKiosID8sIDosIGFuZCwgYi1hbmQsIG9yLCBiLW9yLCBiLXhvciwgaW4sIG5vdCBpblxuICAgIC8vIGFuZCwgb3IsIGluLCBub3QgaW4sIG1hdGNoZXMsIHN0YXJ0cyB3aXRoLCBlbmRzIHdpdGggY2FuIGJlIGZvbGxvd2VkIGJ5IGEgc3BhY2Ugb3IgcGFyZW50aGVzaXNcbiAgICByZWdleDogLyheXFw/XFw/fF5cXD86fF4oYi1hbmQpfF4oYi1vcil8XihiLXhvcil8XlsrXFwtfiU/XXxeWzpdKD8hXFxkXFxdKXxeWyE9XT09P3xeWyE8Pl09P3xeXFwqXFwqP3xeXFwvXFwvP3xeKGFuZClbKHxcXHMrXXxeKG9yKVsofFxccytdfF4oaW4pWyh8XFxzK118Xihub3QgaW4pWyh8XFxzK118XihtYXRjaGVzKXxeKHN0YXJ0cyB3aXRoKXxeKGVuZHMgd2l0aCl8XlxcLlxcLikvLFxuICAgIG5leHQ6IFR3aWcuZXhwcmVzc2lvbi5zZXQuZXhwcmVzc2lvbnMsXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obWF0Y2gsIHRva2Vucykge1xuICAgICAgc3dpdGNoIChtYXRjaFswXSkge1xuICAgICAgICBjYXNlICdhbmQoJzpcbiAgICAgICAgY2FzZSAnb3IoJzpcbiAgICAgICAgY2FzZSAnaW4oJzpcbiAgICAgICAgY2FzZSAnbm90IGluKCc6XG4gICAgICAgICAgLy8gU3RyaXAgb2ZmIHRoZSAoIGlmIGl0IGV4aXN0c1xuICAgICAgICAgIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0udmFsdWUgPSBtYXRjaFsyXTtcbiAgICAgICAgICByZXR1cm4gbWF0Y2hbMF07XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21waWxlOiBmdW5jdGlvbiBjb21waWxlKHRva2VuLCBzdGFjaywgb3V0cHV0KSB7XG4gICAgICBkZWxldGUgdG9rZW4ubWF0Y2g7XG4gICAgICB0b2tlbi52YWx1ZSA9IHRva2VuLnZhbHVlLnRyaW0oKTtcbiAgICAgIHZhciB2YWx1ZSA9IHRva2VuLnZhbHVlO1xuICAgICAgdmFyIG9wZXJhdG9yID0gVHdpZy5leHByZXNzaW9uLm9wZXJhdG9yLmxvb2t1cCh2YWx1ZSwgdG9rZW4pO1xuICAgICAgVHdpZy5sb2cudHJhY2UoJ1R3aWcuZXhwcmVzc2lvbi5jb21waWxlOiAnLCAnT3BlcmF0b3I6ICcsIG9wZXJhdG9yLCAnIGZyb20gJywgdmFsdWUpO1xuXG4gICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCAmJiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0udHlwZSA9PT0gVHdpZy5leHByZXNzaW9uLnR5cGUub3BlcmF0b3IudW5hcnkgfHwgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0udHlwZSA9PT0gVHdpZy5leHByZXNzaW9uLnR5cGUub3BlcmF0b3IuYmluYXJ5KSAmJiAob3BlcmF0b3IuYXNzb2NpYXRpdml0eSA9PT0gVHdpZy5leHByZXNzaW9uLm9wZXJhdG9yLmxlZnRUb1JpZ2h0ICYmIG9wZXJhdG9yLnByZWNpZGVuY2UgPj0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0ucHJlY2lkZW5jZSB8fCBvcGVyYXRvci5hc3NvY2lhdGl2aXR5ID09PSBUd2lnLmV4cHJlc3Npb24ub3BlcmF0b3IucmlnaHRUb0xlZnQgJiYgb3BlcmF0b3IucHJlY2lkZW5jZSA+IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLnByZWNpZGVuY2UpKSB7XG4gICAgICAgIHZhciB0ZW1wID0gc3RhY2sucG9wKCk7XG4gICAgICAgIG91dHB1dC5wdXNoKHRlbXApO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgPT09ICc6Jykge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgdGVybmFyeSBvciBvYmplY3Qga2V5IGJlaW5nIHNldFxuICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gJiYgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0udmFsdWUgPT09ICc/Jykgey8vIENvbnRpbnVlIGFzIG5vcm1hbCBmb3IgYSB0ZXJuYXJ5XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBub3QgYSB0ZXJuYXJ5IHNvIHdlIHB1c2ggdGhlIHRva2VuIHRvIHRoZSBvdXRwdXQgd2hlcmUgaXQgY2FuIGJlIGhhbmRsZWRcbiAgICAgICAgICAvLyAgIHdoZW4gdGhlIGFzc29jYXRlZCBvYmplY3QgaXMgY2xvc2VkLlxuICAgICAgICAgIHZhciBrZXlUb2tlbiA9IG91dHB1dC5wb3AoKTtcblxuICAgICAgICAgIGlmIChrZXlUb2tlbi50eXBlID09PSBUd2lnLmV4cHJlc3Npb24udHlwZS5zdHJpbmcgfHwga2V5VG9rZW4udHlwZSA9PT0gVHdpZy5leHByZXNzaW9uLnR5cGUudmFyaWFibGUpIHtcbiAgICAgICAgICAgIHRva2VuLmtleSA9IGtleVRva2VuLnZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoa2V5VG9rZW4udHlwZSA9PT0gVHdpZy5leHByZXNzaW9uLnR5cGUubnVtYmVyKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IGludGVnZXIga2V5cyBpbnRvIHN0cmluZyBrZXlzXG4gICAgICAgICAgICB0b2tlbi5rZXkgPSBrZXlUb2tlbi52YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoa2V5VG9rZW4uZXhwcmVzc2lvbiAmJiAoa2V5VG9rZW4udHlwZSA9PT0gVHdpZy5leHByZXNzaW9uLnR5cGUucGFyYW1ldGVyLmVuZCB8fCBrZXlUb2tlbi50eXBlID09PSBUd2lnLmV4cHJlc3Npb24udHlwZS5zdWJleHByZXNzaW9uLmVuZCkpIHtcbiAgICAgICAgICAgIHRva2VuLnBhcmFtcyA9IGtleVRva2VuLnBhcmFtcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoJ1VuZXhwZWN0ZWQgdmFsdWUgYmVmb3JlIFxcJzpcXCcgb2YgJyArIGtleVRva2VuLnR5cGUgKyAnID0gJyArIGtleVRva2VuLnZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvdXRwdXQucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YWNrLnB1c2gob3BlcmF0b3IpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHRva2VuLCBzdGFjaywgY29udGV4dCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpcztcblxuICAgICAgaWYgKHRva2VuLmtleSkge1xuICAgICAgICAvLyBIYW5kbGUgdGVybmFyeSAnOicgb3BlcmF0b3JcbiAgICAgICAgc3RhY2sucHVzaCh0b2tlbik7XG4gICAgICB9IGVsc2UgaWYgKHRva2VuLnBhcmFtcykge1xuICAgICAgICAvLyBIYW5kbGUgXCJ7KGV4cHJlc3Npb24pOnZhbHVlfVwiXG4gICAgICAgIHJldHVybiBUd2lnLmV4cHJlc3Npb24ucGFyc2VBc3luYy5jYWxsKHN0YXRlLCB0b2tlbi5wYXJhbXMsIGNvbnRleHQpLnRoZW4oZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHRva2VuLmtleSA9IGtleTtcbiAgICAgICAgICBzdGFjay5wdXNoKHRva2VuKTsgLy8gSWYgd2UncmUgaW4gYSBsb29wLCB3ZSBtaWdodCBuZWVkIHRva2VuLnBhcmFtcyBsYXRlciwgZXNwZWNpYWxseSBpbiB0aGlzIGZvcm0gb2YgXCIoZXhwcmVzc2lvbik6dmFsdWVcIlxuXG4gICAgICAgICAgaWYgKCFjb250ZXh0Lmxvb3ApIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0b2tlbi5wYXJhbXM7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFR3aWcuZXhwcmVzc2lvbi5vcGVyYXRvci5wYXJzZSh0b2tlbi52YWx1ZSwgc3RhY2spO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIHR5cGU6IFR3aWcuZXhwcmVzc2lvbi50eXBlLm9wZXJhdG9yLnVuYXJ5LFxuICAgIC8vIE1hdGNoIGFueSBvZiBub3RcbiAgICByZWdleDogLyhebm90XFxzKykvLFxuICAgIG5leHQ6IFR3aWcuZXhwcmVzc2lvbi5zZXQuZXhwcmVzc2lvbnMsXG4gICAgY29tcGlsZTogZnVuY3Rpb24gY29tcGlsZSh0b2tlbiwgc3RhY2ssIG91dHB1dCkge1xuICAgICAgZGVsZXRlIHRva2VuLm1hdGNoO1xuICAgICAgdG9rZW4udmFsdWUgPSB0b2tlbi52YWx1ZS50cmltKCk7XG4gICAgICB2YXIgdmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgIHZhciBvcGVyYXRvciA9IFR3aWcuZXhwcmVzc2lvbi5vcGVyYXRvci5sb29rdXAodmFsdWUsIHRva2VuKTtcbiAgICAgIFR3aWcubG9nLnRyYWNlKCdUd2lnLmV4cHJlc3Npb24uY29tcGlsZTogJywgJ09wZXJhdG9yOiAnLCBvcGVyYXRvciwgJyBmcm9tICcsIHZhbHVlKTtcblxuICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDAgJiYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLnR5cGUgPT09IFR3aWcuZXhwcmVzc2lvbi50eXBlLm9wZXJhdG9yLnVuYXJ5IHx8IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLnR5cGUgPT09IFR3aWcuZXhwcmVzc2lvbi50eXBlLm9wZXJhdG9yLmJpbmFyeSkgJiYgKG9wZXJhdG9yLmFzc29jaWF0aXZpdHkgPT09IFR3aWcuZXhwcmVzc2lvbi5vcGVyYXRvci5sZWZ0VG9SaWdodCAmJiBvcGVyYXRvci5wcmVjaWRlbmNlID49IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLnByZWNpZGVuY2UgfHwgb3BlcmF0b3IuYXNzb2NpYXRpdml0eSA9PT0gVHdpZy5leHByZXNzaW9uLm9wZXJhdG9yLnJpZ2h0VG9MZWZ0ICYmIG9wZXJhdG9yLnByZWNpZGVuY2UgPiBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5wcmVjaWRlbmNlKSkge1xuICAgICAgICB2YXIgdGVtcCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBvdXRwdXQucHVzaCh0ZW1wKTtcbiAgICAgIH1cblxuICAgICAgc3RhY2sucHVzaChvcGVyYXRvcik7XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UodG9rZW4sIHN0YWNrKSB7XG4gICAgICBUd2lnLmV4cHJlc3Npb24ub3BlcmF0b3IucGFyc2UodG9rZW4udmFsdWUsIHN0YWNrKTtcbiAgICB9XG4gIH0sIHtcbiAgICAvKipcbiAgICAgKiBNYXRjaCBhIHN0cmluZy4gVGhpcyBpcyBhbnl0aGluZyBiZXR3ZWVuIGEgcGFpciBvZiBzaW5nbGUgb3IgZG91YmxlIHF1b3Rlcy5cbiAgICAgKi9cbiAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5zdHJpbmcsXG4gICAgLy8gU2VlOiBodHRwOi8vYmxvZy5zdGV2ZW5sZXZpdGhhbi5jb20vYXJjaGl2ZXMvbWF0Y2gtcXVvdGVkLXN0cmluZ1xuICAgIHJlZ2V4OiAvXihbXCInXSkoPzooPz0oXFxcXD8pKVxcMltcXHNcXFNdKSo/XFwxLyxcbiAgICBuZXh0OiBUd2lnLmV4cHJlc3Npb24uc2V0Lm9wZXJhdGlvbnNFeHRlbmRlZCxcbiAgICBjb21waWxlOiBmdW5jdGlvbiBjb21waWxlKHRva2VuLCBzdGFjaywgb3V0cHV0KSB7XG4gICAgICB2YXIgdmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgIGRlbGV0ZSB0b2tlbi5tYXRjaDsgLy8gUmVtb3ZlIHRoZSBxdW90ZXMgZnJvbSB0aGUgc3RyaW5nXG5cbiAgICAgIGlmICh2YWx1ZS5zbGljZSgwLCAxKSA9PT0gJ1wiJykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJ1xcXFxcIicsICdcIicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCdcXFxcXFwnJywgJ1xcJycpO1xuICAgICAgfVxuXG4gICAgICB0b2tlbi52YWx1ZSA9IHZhbHVlLnNsaWNlKDEsIC0xKS5yZXBsYWNlKC9cXFxcbi9nLCAnXFxuJykucmVwbGFjZSgvXFxcXHIvZywgJ1xccicpO1xuICAgICAgVHdpZy5sb2cudHJhY2UoJ1R3aWcuZXhwcmVzc2lvbi5jb21waWxlOiAnLCAnU3RyaW5nIHZhbHVlOiAnLCB0b2tlbi52YWx1ZSk7XG4gICAgICBvdXRwdXQucHVzaCh0b2tlbik7XG4gICAgfSxcbiAgICBwYXJzZTogVHdpZy5leHByZXNzaW9uLmZuLnBhcnNlLnB1c2hWYWx1ZVxuICB9LCB7XG4gICAgLyoqXG4gICAgICogTWF0Y2ggYSBzdWJleHByZXNzaW9uIHNldCBzdGFydC5cbiAgICAgKi9cbiAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5zdWJleHByZXNzaW9uLnN0YXJ0LFxuICAgIHJlZ2V4OiAvXlxcKC8sXG4gICAgbmV4dDogVHdpZy5leHByZXNzaW9uLnNldC5leHByZXNzaW9ucy5jb25jYXQoW1R3aWcuZXhwcmVzc2lvbi50eXBlLnN1YmV4cHJlc3Npb24uZW5kXSksXG4gICAgY29tcGlsZTogZnVuY3Rpb24gY29tcGlsZSh0b2tlbiwgc3RhY2ssIG91dHB1dCkge1xuICAgICAgdG9rZW4udmFsdWUgPSAnKCc7XG4gICAgICBvdXRwdXQucHVzaCh0b2tlbik7XG4gICAgICBzdGFjay5wdXNoKHRva2VuKTtcbiAgICB9LFxuICAgIHBhcnNlOiBUd2lnLmV4cHJlc3Npb24uZm4ucGFyc2UucHVzaFxuICB9LCB7XG4gICAgLyoqXG4gICAgICogTWF0Y2ggYSBzdWJleHByZXNzaW9uIHNldCBlbmQuXG4gICAgICovXG4gICAgdHlwZTogVHdpZy5leHByZXNzaW9uLnR5cGUuc3ViZXhwcmVzc2lvbi5lbmQsXG4gICAgcmVnZXg6IC9eXFwpLyxcbiAgICBuZXh0OiBUd2lnLmV4cHJlc3Npb24uc2V0Lm9wZXJhdGlvbnNFeHRlbmRlZCxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUobWF0Y2gsIHRva2Vucykge1xuICAgICAgLy8gSXRlcmF0ZSBiYWNrIHRocm91Z2ggcHJldmlvdXMgdG9rZW5zIHRvIGVuc3VyZSB3ZSBmb2xsb3cgYSBzdWJleHByZXNzaW9uIHN0YXJ0XG4gICAgICB2YXIgaSA9IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGZvdW5kU3ViZXhwcmVzc2lvblN0YXJ0ID0gZmFsc2U7XG4gICAgICB2YXIgbmV4dFN1YmV4cHJlc3Npb25TdGFydEludmFsaWQgPSBmYWxzZTtcbiAgICAgIHZhciB1bmNsb3NlZFBhcmFtZXRlckNvdW50ID0gMDtcblxuICAgICAgd2hpbGUgKCFmb3VuZFN1YmV4cHJlc3Npb25TdGFydCAmJiBpID49IDApIHtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICBmb3VuZFN1YmV4cHJlc3Npb25TdGFydCA9IHRva2VuLnR5cGUgPT09IFR3aWcuZXhwcmVzc2lvbi50eXBlLnN1YmV4cHJlc3Npb24uc3RhcnQ7IC8vIElmIHdlIGhhdmUgcHJldmlvdXNseSBmb3VuZCBhIHN1YmV4cHJlc3Npb24gZW5kLCB0aGVuIHRoaXMgc3ViZXhwcmVzc2lvbiBzdGFydCBpcyB0aGUgc3RhcnQgb2ZcbiAgICAgICAgLy8gdGhhdCBzdWJleHByZXNzaW9uLCBub3QgdGhlIHN1YmV4cHJlc3Npb24gd2UgYXJlIHNlYXJjaGluZyBmb3JcblxuICAgICAgICBpZiAoZm91bmRTdWJleHByZXNzaW9uU3RhcnQgJiYgbmV4dFN1YmV4cHJlc3Npb25TdGFydEludmFsaWQpIHtcbiAgICAgICAgICBuZXh0U3ViZXhwcmVzc2lvblN0YXJ0SW52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgIGZvdW5kU3ViZXhwcmVzc2lvblN0YXJ0ID0gZmFsc2U7XG4gICAgICAgIH0gLy8gQ291bnQgcGFyYW1ldGVyIHRva2VucyB0byBlbnN1cmUgd2UgZG9udCByZXR1cm4gdHJ1dGh5IGZvciBhIHBhcmFtZXRlciBvcGVuZXJcblxuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSBUd2lnLmV4cHJlc3Npb24udHlwZS5wYXJhbWV0ZXIuc3RhcnQpIHtcbiAgICAgICAgICB1bmNsb3NlZFBhcmFtZXRlckNvdW50Kys7XG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW4udHlwZSA9PT0gVHdpZy5leHByZXNzaW9uLnR5cGUucGFyYW1ldGVyLmVuZCkge1xuICAgICAgICAgIHVuY2xvc2VkUGFyYW1ldGVyQ291bnQtLTtcbiAgICAgICAgfSBlbHNlIGlmICh0b2tlbi50eXBlID09PSBUd2lnLmV4cHJlc3Npb24udHlwZS5zdWJleHByZXNzaW9uLmVuZCkge1xuICAgICAgICAgIG5leHRTdWJleHByZXNzaW9uU3RhcnRJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGktLTtcbiAgICAgIH0gLy8gSWYgd2UgZm91bmQgdW5jbG9zZWQgcGFyYW1ldGVycywgcmV0dXJuIGZhbHNlXG4gICAgICAvLyBJZiB3ZSBkaWRudCBmaW5kIHN1YmV4cHJlc3Npb24gc3RhcnQsIHJldHVybiBmYWxzZVxuICAgICAgLy8gT3RoZXJ3aXNlIHJldHVybiB0cnVlXG5cblxuICAgICAgcmV0dXJuIGZvdW5kU3ViZXhwcmVzc2lvblN0YXJ0ICYmIHVuY2xvc2VkUGFyYW1ldGVyQ291bnQgPT09IDA7XG4gICAgfSxcbiAgICBjb21waWxlOiBmdW5jdGlvbiBjb21waWxlKHRva2VuLCBzdGFjaywgb3V0cHV0KSB7XG4gICAgICAvLyBUaGlzIGlzIGJhc2ljYWxseSBhIGNvcHkgb2YgcGFyYW1ldGVyIGVuZCBjb21waWxhdGlvblxuICAgICAgdmFyIHN0YWNrVG9rZW47XG4gICAgICB2YXIgZW5kVG9rZW4gPSB0b2tlbjtcbiAgICAgIHN0YWNrVG9rZW4gPSBzdGFjay5wb3AoKTtcblxuICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDAgJiYgc3RhY2tUb2tlbi50eXBlICE9PSBUd2lnLmV4cHJlc3Npb24udHlwZS5zdWJleHByZXNzaW9uLnN0YXJ0KSB7XG4gICAgICAgIG91dHB1dC5wdXNoKHN0YWNrVG9rZW4pO1xuICAgICAgICBzdGFja1Rva2VuID0gc3RhY2sucG9wKCk7XG4gICAgICB9IC8vIE1vdmUgY29udGVudHMgb2YgcGFyZW5zIGludG8gcHJlY2VkaW5nIGZpbHRlclxuXG5cbiAgICAgIHZhciBwYXJhbVN0YWNrID0gW107XG5cbiAgICAgIHdoaWxlICh0b2tlbi50eXBlICE9PSBUd2lnLmV4cHJlc3Npb24udHlwZS5zdWJleHByZXNzaW9uLnN0YXJ0KSB7XG4gICAgICAgIC8vIEFkZCB0b2tlbiB0byBhcmd1bWVudHMgc3RhY2tcbiAgICAgICAgcGFyYW1TdGFjay51bnNoaWZ0KHRva2VuKTtcbiAgICAgICAgdG9rZW4gPSBvdXRwdXQucG9wKCk7XG4gICAgICB9XG5cbiAgICAgIHBhcmFtU3RhY2sudW5zaGlmdCh0b2tlbik7IC8vIElmIHRoZSB0b2tlbiBhdCB0aGUgdG9wIG9mIHRoZSAqc3RhY2sqIGlzIGEgZnVuY3Rpb24gdG9rZW4sIHBvcCBpdCBvbnRvIHRoZSBvdXRwdXQgcXVldWUuXG4gICAgICAvLyBHZXQgdGhlIHRva2VuIHByZWNlZGluZyB0aGUgcGFyYW1ldGVyc1xuXG4gICAgICBzdGFja1Rva2VuID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmIChzdGFja1Rva2VuID09PSB1bmRlZmluZWQgfHwgc3RhY2tUb2tlbi50eXBlICE9PSBUd2lnLmV4cHJlc3Npb24udHlwZS5fZnVuY3Rpb24gJiYgc3RhY2tUb2tlbi50eXBlICE9PSBUd2lnLmV4cHJlc3Npb24udHlwZS5maWx0ZXIgJiYgc3RhY2tUb2tlbi50eXBlICE9PSBUd2lnLmV4cHJlc3Npb24udHlwZS50ZXN0ICYmIHN0YWNrVG9rZW4udHlwZSAhPT0gVHdpZy5leHByZXNzaW9uLnR5cGUua2V5LmJyYWNrZXRzKSB7XG4gICAgICAgIGVuZFRva2VuLmV4cHJlc3Npb24gPSB0cnVlOyAvLyBSZW1vdmUgc3RhcnQgYW5kIGVuZCB0b2tlbiBmcm9tIHN0YWNrXG5cbiAgICAgICAgcGFyYW1TdGFjay5wb3AoKTtcbiAgICAgICAgcGFyYW1TdGFjay5zaGlmdCgpO1xuICAgICAgICBlbmRUb2tlbi5wYXJhbXMgPSBwYXJhbVN0YWNrO1xuICAgICAgICBvdXRwdXQucHVzaChlbmRUb2tlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBiZSBoaXRcbiAgICAgICAgZW5kVG9rZW4uZXhwcmVzc2lvbiA9IGZhbHNlO1xuICAgICAgICBzdGFja1Rva2VuLnBhcmFtcyA9IHBhcmFtU3RhY2s7XG4gICAgICB9XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UodG9rZW4sIHN0YWNrLCBjb250ZXh0KSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzO1xuXG4gICAgICBpZiAodG9rZW4uZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gVHdpZy5leHByZXNzaW9uLnBhcnNlQXN5bmMuY2FsbChzdGF0ZSwgdG9rZW4ucGFyYW1zLCBjb250ZXh0KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoJ1VuZXhwZWN0ZWQgc3ViZXhwcmVzc2lvbiBlbmQgd2hlbiB0b2tlbiBpcyBub3QgbWFya2VkIGFzIGFuIGV4cHJlc3Npb24nKTtcbiAgICB9XG4gIH0sIHtcbiAgICAvKipcbiAgICAgKiBNYXRjaCBhIHBhcmFtZXRlciBzZXQgc3RhcnQuXG4gICAgICovXG4gICAgdHlwZTogVHdpZy5leHByZXNzaW9uLnR5cGUucGFyYW1ldGVyLnN0YXJ0LFxuICAgIHJlZ2V4OiAvXlxcKC8sXG4gICAgbmV4dDogVHdpZy5leHByZXNzaW9uLnNldC5leHByZXNzaW9ucy5jb25jYXQoW1R3aWcuZXhwcmVzc2lvbi50eXBlLnBhcmFtZXRlci5lbmRdKSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUobWF0Y2gsIHRva2Vucykge1xuICAgICAgdmFyIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07IC8vIFdlIGNhbid0IHVzZSB0aGUgcmVnZXggdG8gdGVzdCBpZiB3ZSBmb2xsb3cgYSBzcGFjZSBiZWNhdXNlIGV4cHJlc3Npb24gaXMgdHJpbW1lZFxuXG4gICAgICByZXR1cm4gbGFzdFRva2VuICYmICFUd2lnLmV4cHJlc3Npb24ucmVzZXJ2ZWRXb3Jkcy5pbmNsdWRlcyhsYXN0VG9rZW4udmFsdWUudHJpbSgpKTtcbiAgICB9LFxuICAgIGNvbXBpbGU6IFR3aWcuZXhwcmVzc2lvbi5mbi5jb21waWxlLnB1c2hCb3RoLFxuICAgIHBhcnNlOiBUd2lnLmV4cHJlc3Npb24uZm4ucGFyc2UucHVzaFxuICB9LCB7XG4gICAgLyoqXG4gICAgICogTWF0Y2ggYSBwYXJhbWV0ZXIgc2V0IGVuZC5cbiAgICAgKi9cbiAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5wYXJhbWV0ZXIuZW5kLFxuICAgIHJlZ2V4OiAvXlxcKS8sXG4gICAgbmV4dDogVHdpZy5leHByZXNzaW9uLnNldC5vcGVyYXRpb25zRXh0ZW5kZWQsXG4gICAgY29tcGlsZTogZnVuY3Rpb24gY29tcGlsZSh0b2tlbiwgc3RhY2ssIG91dHB1dCkge1xuICAgICAgdmFyIHN0YWNrVG9rZW47XG4gICAgICB2YXIgZW5kVG9rZW4gPSB0b2tlbjtcbiAgICAgIHN0YWNrVG9rZW4gPSBzdGFjay5wb3AoKTtcblxuICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDAgJiYgc3RhY2tUb2tlbi50eXBlICE9PSBUd2lnLmV4cHJlc3Npb24udHlwZS5wYXJhbWV0ZXIuc3RhcnQpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goc3RhY2tUb2tlbik7XG4gICAgICAgIHN0YWNrVG9rZW4gPSBzdGFjay5wb3AoKTtcbiAgICAgIH0gLy8gTW92ZSBjb250ZW50cyBvZiBwYXJlbnMgaW50byBwcmVjZWRpbmcgZmlsdGVyXG5cblxuICAgICAgdmFyIHBhcmFtU3RhY2sgPSBbXTtcblxuICAgICAgd2hpbGUgKHRva2VuLnR5cGUgIT09IFR3aWcuZXhwcmVzc2lvbi50eXBlLnBhcmFtZXRlci5zdGFydCkge1xuICAgICAgICAvLyBBZGQgdG9rZW4gdG8gYXJndW1lbnRzIHN0YWNrXG4gICAgICAgIHBhcmFtU3RhY2sudW5zaGlmdCh0b2tlbik7XG4gICAgICAgIHRva2VuID0gb3V0cHV0LnBvcCgpO1xuICAgICAgfVxuXG4gICAgICBwYXJhbVN0YWNrLnVuc2hpZnQodG9rZW4pOyAvLyBHZXQgdGhlIHRva2VuIHByZWNlZGluZyB0aGUgcGFyYW1ldGVyc1xuXG4gICAgICB0b2tlbiA9IG91dHB1dFtvdXRwdXQubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmICh0b2tlbiA9PT0gdW5kZWZpbmVkIHx8IHRva2VuLnR5cGUgIT09IFR3aWcuZXhwcmVzc2lvbi50eXBlLl9mdW5jdGlvbiAmJiB0b2tlbi50eXBlICE9PSBUd2lnLmV4cHJlc3Npb24udHlwZS5maWx0ZXIgJiYgdG9rZW4udHlwZSAhPT0gVHdpZy5leHByZXNzaW9uLnR5cGUudGVzdCAmJiB0b2tlbi50eXBlICE9PSBUd2lnLmV4cHJlc3Npb24udHlwZS5rZXkuYnJhY2tldHMpIHtcbiAgICAgICAgZW5kVG9rZW4uZXhwcmVzc2lvbiA9IHRydWU7IC8vIFJlbW92ZSBzdGFydCBhbmQgZW5kIHRva2VuIGZyb20gc3RhY2tcblxuICAgICAgICBwYXJhbVN0YWNrLnBvcCgpO1xuICAgICAgICBwYXJhbVN0YWNrLnNoaWZ0KCk7XG4gICAgICAgIGVuZFRva2VuLnBhcmFtcyA9IHBhcmFtU3RhY2s7XG4gICAgICAgIG91dHB1dC5wdXNoKGVuZFRva2VuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZFRva2VuLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgICAgICAgdG9rZW4ucGFyYW1zID0gcGFyYW1TdGFjaztcbiAgICAgIH1cbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSh0b2tlbiwgc3RhY2ssIGNvbnRleHQpIHtcbiAgICAgIHZhciBuZXdBcnJheSA9IFtdO1xuICAgICAgdmFyIGFycmF5RW5kZWQgPSBmYWxzZTtcbiAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzO1xuXG4gICAgICBpZiAodG9rZW4uZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gVHdpZy5leHByZXNzaW9uLnBhcnNlQXN5bmMuY2FsbChzdGF0ZSwgdG9rZW4ucGFyYW1zLCBjb250ZXh0KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFsdWUgPSBzdGFjay5wb3AoKTsgLy8gUHVzaCB2YWx1ZXMgaW50byB0aGUgYXJyYXkgdW50aWwgdGhlIHN0YXJ0IG9mIHRoZSBhcnJheVxuXG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS50eXBlICYmIHZhbHVlLnR5cGUgPT09IFR3aWcuZXhwcmVzc2lvbi50eXBlLnBhcmFtZXRlci5zdGFydCkge1xuICAgICAgICAgIGFycmF5RW5kZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3QXJyYXkudW5zaGlmdCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghYXJyYXlFbmRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcignRXhwZWN0ZWQgZW5kIG9mIHBhcmFtZXRlciBzZXQuJyk7XG4gICAgICB9XG5cbiAgICAgIHN0YWNrLnB1c2gobmV3QXJyYXkpO1xuICAgIH1cbiAgfSwge1xuICAgIHR5cGU6IFR3aWcuZXhwcmVzc2lvbi50eXBlLnNsaWNlLFxuICAgIHJlZ2V4OiAvXlxcWyhcXGQqOlxcZCopXFxdLyxcbiAgICBuZXh0OiBUd2lnLmV4cHJlc3Npb24uc2V0Lm9wZXJhdGlvbnNFeHRlbmRlZCxcbiAgICBjb21waWxlOiBmdW5jdGlvbiBjb21waWxlKHRva2VuLCBzdGFjaywgb3V0cHV0KSB7XG4gICAgICB2YXIgc2xpY2VSYW5nZSA9IHRva2VuLm1hdGNoWzFdLnNwbGl0KCc6Jyk7IC8vIFNsaWNlU3RhcnQgY2FuIGJlIHVuZGVmaW5lZCB3aGVuIHdlIHBhc3MgcGFyYW1ldGVycyB0byB0aGUgc2xpY2UgZmlsdGVyIGxhdGVyXG5cbiAgICAgIHZhciBzbGljZVN0YXJ0ID0gc2xpY2VSYW5nZVswXSA/IHBhcnNlSW50KHNsaWNlUmFuZ2VbMF0sIDEwKSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBzbGljZUVuZCA9IHNsaWNlUmFuZ2VbMV0gPyBwYXJzZUludChzbGljZVJhbmdlWzFdLCAxMCkgOiB1bmRlZmluZWQ7XG4gICAgICB0b2tlbi52YWx1ZSA9ICdzbGljZSc7XG4gICAgICB0b2tlbi5wYXJhbXMgPSBbc2xpY2VTdGFydCwgc2xpY2VFbmRdOyAvLyBTbGljZUVuZCBjYW4ndCBiZSB1bmRlZmluZWQgYXMgdGhlIHNsaWNlIGZpbHRlciBkb2Vzbid0IGNoZWNrIGZvciB0aGlzLCBidXQgaXQgZG9lcyBjaGVjayB0aGUgbGVuZ3RoXG4gICAgICAvLyBvZiB0aGUgcGFyYW1zIGFycmF5LCBzbyBqdXN0IHNob3J0ZW4gaXQuXG5cbiAgICAgIGlmICghc2xpY2VFbmQpIHtcbiAgICAgICAgdG9rZW4ucGFyYW1zID0gW3NsaWNlU3RhcnRdO1xuICAgICAgfVxuXG4gICAgICBvdXRwdXQucHVzaCh0b2tlbik7XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UodG9rZW4sIHN0YWNrKSB7XG4gICAgICB2YXIgaW5wdXQgPSBzdGFjay5wb3AoKTtcbiAgICAgIHZhciBwYXJhbXMgPSB0b2tlbi5wYXJhbXM7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzO1xuICAgICAgc3RhY2sucHVzaChUd2lnLmZpbHRlci5jYWxsKHN0YXRlLCB0b2tlbi52YWx1ZSwgaW5wdXQsIHBhcmFtcykpO1xuICAgIH1cbiAgfSwge1xuICAgIC8qKlxuICAgICAqIE1hdGNoIGFuIGFycmF5IHN0YXJ0LlxuICAgICAqL1xuICAgIHR5cGU6IFR3aWcuZXhwcmVzc2lvbi50eXBlLmFycmF5LnN0YXJ0LFxuICAgIHJlZ2V4OiAvXlxcWy8sXG4gICAgbmV4dDogVHdpZy5leHByZXNzaW9uLnNldC5leHByZXNzaW9ucy5jb25jYXQoW1R3aWcuZXhwcmVzc2lvbi50eXBlLmFycmF5LmVuZF0pLFxuICAgIGNvbXBpbGU6IFR3aWcuZXhwcmVzc2lvbi5mbi5jb21waWxlLnB1c2hCb3RoLFxuICAgIHBhcnNlOiBUd2lnLmV4cHJlc3Npb24uZm4ucGFyc2UucHVzaFxuICB9LCB7XG4gICAgLyoqXG4gICAgICogTWF0Y2ggYW4gYXJyYXkgZW5kLlxuICAgICAqL1xuICAgIHR5cGU6IFR3aWcuZXhwcmVzc2lvbi50eXBlLmFycmF5LmVuZCxcbiAgICByZWdleDogL15cXF0vLFxuICAgIG5leHQ6IFR3aWcuZXhwcmVzc2lvbi5zZXQub3BlcmF0aW9uc0V4dGVuZGVkLFxuICAgIGNvbXBpbGU6IGZ1bmN0aW9uIGNvbXBpbGUodG9rZW4sIHN0YWNrLCBvdXRwdXQpIHtcbiAgICAgIHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgIHZhciBzdGFja1Rva2VuOyAvLyBQb3AgdG9rZW5zIG9mZiB0aGUgc3RhY2sgdW50aWwgdGhlIHN0YXJ0IG9mIHRoZSBvYmplY3RcblxuICAgICAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHN0YWNrVG9rZW4gPSBzdGFjay5wb3AoKTtcblxuICAgICAgICBpZiAoc3RhY2tUb2tlbi50eXBlID09PSBUd2lnLmV4cHJlc3Npb24udHlwZS5hcnJheS5zdGFydCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0LnB1c2goc3RhY2tUb2tlbik7XG4gICAgICB9XG5cbiAgICAgIG91dHB1dC5wdXNoKHRva2VuKTtcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSh0b2tlbiwgc3RhY2spIHtcbiAgICAgIHZhciBuZXdBcnJheSA9IFtdO1xuICAgICAgdmFyIGFycmF5RW5kZWQgPSBmYWxzZTtcbiAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG5cbiAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhbHVlID0gc3RhY2sucG9wKCk7IC8vIFB1c2ggdmFsdWVzIGludG8gdGhlIGFycmF5IHVudGlsIHRoZSBzdGFydCBvZiB0aGUgYXJyYXlcblxuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUudHlwZSAmJiB2YWx1ZS50eXBlID09PSBUd2lnLmV4cHJlc3Npb24udHlwZS5hcnJheS5zdGFydCkge1xuICAgICAgICAgIGFycmF5RW5kZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3QXJyYXkudW5zaGlmdCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghYXJyYXlFbmRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcignRXhwZWN0ZWQgZW5kIG9mIGFycmF5LicpO1xuICAgICAgfVxuXG4gICAgICBzdGFjay5wdXNoKG5ld0FycmF5KTtcbiAgICB9XG4gIH0sIC8vIFRva2VuIHRoYXQgcmVwcmVzZW50cyB0aGUgc3RhcnQgb2YgYSBoYXNoIG1hcCAnfSdcbiAgLy9cbiAgLy8gSGFzaCBtYXBzIHRha2UgdGhlIGZvcm06XG4gIC8vICAgIHsgXCJrZXlcIjogJ3ZhbHVlJywgXCJhbm90aGVyX2tleVwiOiBpdGVtIH1cbiAgLy9cbiAgLy8gS2V5cyBtdXN0IGJlIHF1b3RlZCAoZWl0aGVyIHNpbmdsZSBvciBkb3VibGUpIGFuZCB2YWx1ZXMgY2FuIGJlIGFueSBleHByZXNzaW9uLlxuICB7XG4gICAgdHlwZTogVHdpZy5leHByZXNzaW9uLnR5cGUub2JqZWN0LnN0YXJ0LFxuICAgIHJlZ2V4OiAvXlxcey8sXG4gICAgbmV4dDogVHdpZy5leHByZXNzaW9uLnNldC5leHByZXNzaW9ucy5jb25jYXQoW1R3aWcuZXhwcmVzc2lvbi50eXBlLm9iamVjdC5lbmRdKSxcbiAgICBjb21waWxlOiBUd2lnLmV4cHJlc3Npb24uZm4uY29tcGlsZS5wdXNoQm90aCxcbiAgICBwYXJzZTogVHdpZy5leHByZXNzaW9uLmZuLnBhcnNlLnB1c2hcbiAgfSwgLy8gVG9rZW4gdGhhdCByZXByZXNlbnRzIHRoZSBlbmQgb2YgYSBIYXNoIE1hcCAnfSdcbiAgLy9cbiAgLy8gVGhpcyBpcyB3aGVyZSB0aGUgbG9naWMgZm9yIGJ1aWxkaW5nIHRoZSBpbnRlcm5hbFxuICAvLyByZXByZXNlbnRhdGlvbiBvZiBhIGhhc2ggbWFwIGlzIGRlZmluZWQuXG4gIHtcbiAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5vYmplY3QuZW5kLFxuICAgIHJlZ2V4OiAvXlxcfS8sXG4gICAgbmV4dDogVHdpZy5leHByZXNzaW9uLnNldC5vcGVyYXRpb25zRXh0ZW5kZWQsXG4gICAgY29tcGlsZTogZnVuY3Rpb24gY29tcGlsZSh0b2tlbiwgc3RhY2ssIG91dHB1dCkge1xuICAgICAgdmFyIGkgPSBzdGFjay5sZW5ndGggLSAxO1xuICAgICAgdmFyIHN0YWNrVG9rZW47IC8vIFBvcCB0b2tlbnMgb2ZmIHRoZSBzdGFjayB1bnRpbCB0aGUgc3RhcnQgb2YgdGhlIG9iamVjdFxuXG4gICAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgc3RhY2tUb2tlbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgIGlmIChzdGFja1Rva2VuICYmIHN0YWNrVG9rZW4udHlwZSA9PT0gVHdpZy5leHByZXNzaW9uLnR5cGUub2JqZWN0LnN0YXJ0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXQucHVzaChzdGFja1Rva2VuKTtcbiAgICAgIH1cblxuICAgICAgb3V0cHV0LnB1c2godG9rZW4pO1xuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGVuZFRva2VuLCBzdGFjaykge1xuICAgICAgdmFyIG5ld09iamVjdCA9IHt9O1xuICAgICAgdmFyIG9iamVjdEVuZGVkID0gZmFsc2U7XG4gICAgICB2YXIgdG9rZW4gPSBudWxsO1xuICAgICAgdmFyIGhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICB2YXIgdmFsdWUgPSBudWxsO1xuXG4gICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICB0b2tlbiA9IHN0YWNrLnBvcCgpOyAvLyBQdXNoIHZhbHVlcyBpbnRvIHRoZSBhcnJheSB1bnRpbCB0aGUgc3RhcnQgb2YgdGhlIG9iamVjdFxuXG4gICAgICAgIGlmICh0b2tlbiAmJiB0b2tlbi50eXBlICYmIHRva2VuLnR5cGUgPT09IFR3aWcuZXhwcmVzc2lvbi50eXBlLm9iamVjdC5zdGFydCkge1xuICAgICAgICAgIG9iamVjdEVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b2tlbiAmJiB0b2tlbi50eXBlICYmICh0b2tlbi50eXBlID09PSBUd2lnLmV4cHJlc3Npb24udHlwZS5vcGVyYXRvci5iaW5hcnkgfHwgdG9rZW4udHlwZSA9PT0gVHdpZy5leHByZXNzaW9uLnR5cGUub3BlcmF0b3IudW5hcnkpICYmIHRva2VuLmtleSkge1xuICAgICAgICAgIGlmICghaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKCdNaXNzaW5nIHZhbHVlIGZvciBrZXkgXFwnJyArIHRva2VuLmtleSArICdcXCcgaW4gb2JqZWN0IGRlZmluaXRpb24uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV3T2JqZWN0W3Rva2VuLmtleV0gPSB2YWx1ZTsgLy8gUHJlc2VydmUgdGhlIG9yZGVyIHRoYXQgZWxlbWVudHMgYXJlIGFkZGVkIHRvIHRoZSBtYXBcbiAgICAgICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBzaW5jZSBKYXZhU2NyaXB0IG9iamVjdHMgZG9uJ3RcbiAgICAgICAgICAvLyBndWFyYW50ZWUgdGhlIG9yZGVyIG9mIGtleXNcblxuICAgICAgICAgIGlmIChuZXdPYmplY3QuX2tleXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3T2JqZWN0Ll9rZXlzID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV3T2JqZWN0Ll9rZXlzLnVuc2hpZnQodG9rZW4ua2V5KTsgLy8gUmVzZXQgdmFsdWUgY2hlY2tcblxuXG4gICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgIGhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlID0gdG9rZW47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFvYmplY3RFbmRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcignVW5leHBlY3RlZCBlbmQgb2Ygb2JqZWN0LicpO1xuICAgICAgfVxuXG4gICAgICBzdGFjay5wdXNoKG5ld09iamVjdCk7XG4gICAgfVxuICB9LCAvLyBUb2tlbiByZXByZXNlbnRpbmcgYSBmaWx0ZXJcbiAgLy9cbiAgLy8gRmlsdGVycyBjYW4gZm9sbG93IGFueSBleHByZXNzaW9uIGFuZCB0YWtlIHRoZSBmb3JtOlxuICAvLyAgICBleHByZXNzaW9ufGZpbHRlcihvcHRpb25hbCwgYXJncylcbiAgLy9cbiAgLy8gRmlsdGVyIHBhcnNpbmcgaXMgZG9uZSBpbiB0aGUgVHdpZy5maWx0ZXJzIG5hbWVzcGFjZS5cbiAge1xuICAgIHR5cGU6IFR3aWcuZXhwcmVzc2lvbi50eXBlLmZpbHRlcixcbiAgICAvLyBNYXRjaCBhIHwgdGhlbiBhIGxldHRlciBvciBfLCB0aGVuIGFueSBudW1iZXIgb2YgbGV0dGVycywgbnVtYmVycywgXyBvciAtXG4gICAgcmVnZXg6IC9eXFx8XFxzPyhbYS16QS1aX11bYS16QS1aMC05Xy1dKikvLFxuICAgIG5leHQ6IFR3aWcuZXhwcmVzc2lvbi5zZXQub3BlcmF0aW9uc0V4dGVuZGVkLmNvbmNhdChbVHdpZy5leHByZXNzaW9uLnR5cGUucGFyYW1ldGVyLnN0YXJ0XSksXG4gICAgY29tcGlsZTogZnVuY3Rpb24gY29tcGlsZSh0b2tlbiwgc3RhY2ssIG91dHB1dCkge1xuICAgICAgdG9rZW4udmFsdWUgPSB0b2tlbi5tYXRjaFsxXTtcbiAgICAgIG91dHB1dC5wdXNoKHRva2VuKTtcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSh0b2tlbiwgc3RhY2ssIGNvbnRleHQpIHtcbiAgICAgIHZhciBpbnB1dCA9IHN0YWNrLnBvcCgpO1xuICAgICAgdmFyIHN0YXRlID0gdGhpcztcbiAgICAgIHJldHVybiBwYXJzZVBhcmFtcyhzdGF0ZSwgdG9rZW4ucGFyYW1zLCBjb250ZXh0KS50aGVuKGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIFR3aWcuZmlsdGVyLmNhbGwoc3RhdGUsIHRva2VuLnZhbHVlLCBpbnB1dCwgcGFyYW1zKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAgdHlwZTogVHdpZy5leHByZXNzaW9uLnR5cGUuX2Z1bmN0aW9uLFxuICAgIC8vIE1hdGNoIGFueSBsZXR0ZXIgb3IgXywgdGhlbiBhbnkgbnVtYmVyIG9mIGxldHRlcnMsIG51bWJlcnMsIF8gb3IgLSBmb2xsb3dlZCBieSAoXG4gICAgcmVnZXg6IC9eKFthLXpBLVpfXVxcdyopXFxzKlxcKC8sXG4gICAgbmV4dDogVHdpZy5leHByZXNzaW9uLnR5cGUucGFyYW1ldGVyLnN0YXJ0LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShtYXRjaCkge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoaXMgZnVuY3Rpb24gaXMgbm90IGEgcmVzZXJ2ZWQgd29yZFxuICAgICAgcmV0dXJuIG1hdGNoWzFdICYmICFUd2lnLmV4cHJlc3Npb24ucmVzZXJ2ZWRXb3Jkcy5pbmNsdWRlcyhtYXRjaFsxXSk7XG4gICAgfSxcbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybSgpIHtcbiAgICAgIHJldHVybiAnKCc7XG4gICAgfSxcbiAgICBjb21waWxlOiBmdW5jdGlvbiBjb21waWxlKHRva2VuLCBzdGFjaywgb3V0cHV0KSB7XG4gICAgICB2YXIgZm4gPSB0b2tlbi5tYXRjaFsxXTtcbiAgICAgIHRva2VuLmZuID0gZm47IC8vIENsZWFudXAgdG9rZW5cblxuICAgICAgZGVsZXRlIHRva2VuLm1hdGNoO1xuICAgICAgZGVsZXRlIHRva2VuLnZhbHVlO1xuICAgICAgb3V0cHV0LnB1c2godG9rZW4pO1xuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHRva2VuLCBzdGFjaywgY29udGV4dCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpcztcbiAgICAgIHZhciBmbiA9IHRva2VuLmZuO1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgcmV0dXJuIHBhcnNlUGFyYW1zKHN0YXRlLCB0b2tlbi5wYXJhbXMsIGNvbnRleHQpLnRoZW4oZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBpZiAoVHdpZy5mdW5jdGlvbnNbZm5dKSB7XG4gICAgICAgICAgLy8gR2V0IHRoZSBmdW5jdGlvbiBmcm9tIHRoZSBidWlsdC1pbiBmdW5jdGlvbnNcbiAgICAgICAgICB2YWx1ZSA9IFR3aWcuZnVuY3Rpb25zW2ZuXS5hcHBseShzdGF0ZSwgcGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29udGV4dFtmbl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBHZXQgdGhlIGZ1bmN0aW9uIGZyb20gdGhlIHVzZXIvY29udGV4dCBkZWZpbmVkIGZ1bmN0aW9uc1xuICAgICAgICAgIHZhbHVlID0gY29udGV4dFtmbl0uYXBwbHkoY29udGV4dCwgKDAsIF90b0NvbnN1bWFibGVBcnJheTJbXCJkZWZhdWx0XCJdKShwYXJhbXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcihmbiArICcgZnVuY3Rpb24gZG9lcyBub3QgZXhpc3QgYW5kIGlzIG5vdCBkZWZpbmVkIGluIHRoZSBjb250ZXh0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgc3RhY2sucHVzaChyZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCAvLyBUb2tlbiByZXByZXNlbnRpbmcgYSB2YXJpYWJsZS5cbiAgLy9cbiAgLy8gVmFyaWFibGVzIGNhbiBjb250YWluIGxldHRlcnMsIG51bWJlcnMsIHVuZGVyc2NvcmVzIGFuZFxuICAvLyBkYXNoZXMsIGJ1dCBtdXN0IHN0YXJ0IHdpdGggYSBsZXR0ZXIgb3IgdW5kZXJzY29yZS5cbiAgLy9cbiAgLy8gVmFyaWFibGVzIGFyZSByZXRyaWV2ZWQgZnJvbSB0aGUgcmVuZGVyIGNvbnRleHQgYW5kIHRha2VcbiAgLy8gdGhlIHZhbHVlIG9mICd1bmRlZmluZWQnIGlmIHRoZSBnaXZlbiB2YXJpYWJsZSBkb2Vzbid0XG4gIC8vIGV4aXN0IGluIHRoZSBjb250ZXh0LlxuICB7XG4gICAgdHlwZTogVHdpZy5leHByZXNzaW9uLnR5cGUudmFyaWFibGUsXG4gICAgLy8gTWF0Y2ggYW55IGxldHRlciBvciBfLCB0aGVuIGFueSBudW1iZXIgb2YgbGV0dGVycywgbnVtYmVycywgXyBvciAtXG4gICAgcmVnZXg6IC9eW2EtekEtWl9dXFx3Ki8sXG4gICAgbmV4dDogVHdpZy5leHByZXNzaW9uLnNldC5vcGVyYXRpb25zRXh0ZW5kZWQuY29uY2F0KFtUd2lnLmV4cHJlc3Npb24udHlwZS5wYXJhbWV0ZXIuc3RhcnRdKSxcbiAgICBjb21waWxlOiBUd2lnLmV4cHJlc3Npb24uZm4uY29tcGlsZS5wdXNoLFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShtYXRjaCkge1xuICAgICAgcmV0dXJuICFUd2lnLmV4cHJlc3Npb24ucmVzZXJ2ZWRXb3Jkcy5pbmNsdWRlcyhtYXRjaFswXSk7XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UodG9rZW4sIHN0YWNrLCBjb250ZXh0KSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzOyAvLyBHZXQgdGhlIHZhcmlhYmxlIGZyb20gdGhlIGNvbnRleHRcblxuICAgICAgcmV0dXJuIFR3aWcuZXhwcmVzc2lvbi5yZXNvbHZlQXN5bmMuY2FsbChzdGF0ZSwgY29udGV4dFt0b2tlbi52YWx1ZV0sIGNvbnRleHQpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChzdGF0ZS50ZW1wbGF0ZS5vcHRpb25zLnN0cmljdFZhcmlhYmxlcyAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoJ1ZhcmlhYmxlIFwiJyArIHRva2VuLnZhbHVlICsgJ1wiIGRvZXMgbm90IGV4aXN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5rZXkucGVyaW9kLFxuICAgIHJlZ2V4OiAvXlxcLihcXHcrKS8sXG4gICAgbmV4dDogVHdpZy5leHByZXNzaW9uLnNldC5vcGVyYXRpb25zRXh0ZW5kZWQuY29uY2F0KFtUd2lnLmV4cHJlc3Npb24udHlwZS5wYXJhbWV0ZXIuc3RhcnRdKSxcbiAgICBjb21waWxlOiBmdW5jdGlvbiBjb21waWxlKHRva2VuLCBzdGFjaywgb3V0cHV0KSB7XG4gICAgICB0b2tlbi5rZXkgPSB0b2tlbi5tYXRjaFsxXTtcbiAgICAgIGRlbGV0ZSB0b2tlbi5tYXRjaDtcbiAgICAgIGRlbGV0ZSB0b2tlbi52YWx1ZTtcbiAgICAgIG91dHB1dC5wdXNoKHRva2VuKTtcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSh0b2tlbiwgc3RhY2ssIGNvbnRleHQsIG5leHRUb2tlbikge1xuICAgICAgdmFyIHN0YXRlID0gdGhpcztcbiAgICAgIHZhciBrZXkgPSB0b2tlbi5rZXk7XG4gICAgICB2YXIgb2JqZWN0ID0gc3RhY2sucG9wKCk7XG4gICAgICB2YXIgdmFsdWU7XG5cbiAgICAgIGlmIChvYmplY3QgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgc3RhdGUudGVtcGxhdGUub3B0aW9ucy5zdHJpY3RWYXJpYWJsZXMpIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcignS2V5IFwiJyArIGtleSArICdcIiBmb3Igb2JqZWN0IHdpdGgga2V5cyBcIicgKyBPYmplY3Qua2V5cyhvYmplY3QpLmpvaW4oJywgJykgKyAnXCIgZG9lcyBub3QgZXhpc3QuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoJ0tleSBcIicgKyBrZXkgKyAnXCIgZG9lcyBub3QgZXhpc3QgYXMgdGhlIG9iamVjdCBpcyBlbXB0eS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VQYXJhbXMoc3RhdGUsIHRva2VuLnBhcmFtcywgY29udGV4dCkudGhlbihmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIGlmIChvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uIGNhcGl0YWxpemUodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgwLCAxKS50b1VwcGVyQ2FzZSgpICsgdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgfTsgLy8gR2V0IHRoZSB2YXJpYWJsZSBmcm9tIHRoZSBjb250ZXh0XG5cblxuICAgICAgICAgIGlmICgoMCwgX3R5cGVvZjJbXCJkZWZhdWx0XCJdKShvYmplY3QpID09PSAnb2JqZWN0JyAmJiBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgIH0gZWxzZSBpZiAob2JqZWN0WydnZXQnICsgY2FwaXRhbGl6ZShrZXkpXSkge1xuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3RbJ2dldCcgKyBjYXBpdGFsaXplKGtleSldO1xuICAgICAgICAgIH0gZWxzZSBpZiAob2JqZWN0WydpcycgKyBjYXBpdGFsaXplKGtleSldKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFsnaXMnICsgY2FwaXRhbGl6ZShrZXkpXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFdoZW4gcmVzb2x2aW5nIGFuIGV4cHJlc3Npb24gd2UgbmVlZCB0byBwYXNzIG5leHRUb2tlbiBpbiBjYXNlIHRoZSBleHByZXNzaW9uIGlzIGEgZnVuY3Rpb25cblxuXG4gICAgICAgIHJldHVybiBUd2lnLmV4cHJlc3Npb24ucmVzb2x2ZUFzeW5jLmNhbGwoc3RhdGUsIHZhbHVlLCBjb250ZXh0LCBwYXJhbXMsIG5leHRUb2tlbiwgb2JqZWN0KTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBzdGFjay5wdXNoKHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5rZXkuYnJhY2tldHMsXG4gICAgcmVnZXg6IC9eXFxbKFteXFxdOl0qKVxcXS8sXG4gICAgbmV4dDogVHdpZy5leHByZXNzaW9uLnNldC5vcGVyYXRpb25zRXh0ZW5kZWQuY29uY2F0KFtUd2lnLmV4cHJlc3Npb24udHlwZS5wYXJhbWV0ZXIuc3RhcnRdKSxcbiAgICBjb21waWxlOiBmdW5jdGlvbiBjb21waWxlKHRva2VuLCBzdGFjaywgb3V0cHV0KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB0b2tlbi5tYXRjaFsxXTtcbiAgICAgIGRlbGV0ZSB0b2tlbi52YWx1ZTtcbiAgICAgIGRlbGV0ZSB0b2tlbi5tYXRjaDsgLy8gVGhlIGV4cHJlc3Npb24gc3RhY2sgZm9yIHRoZSBrZXlcblxuICAgICAgdG9rZW4uc3RhY2sgPSBUd2lnLmV4cHJlc3Npb24uY29tcGlsZSh7XG4gICAgICAgIHZhbHVlOiBtYXRjaFxuICAgICAgfSkuc3RhY2s7XG4gICAgICBvdXRwdXQucHVzaCh0b2tlbik7XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UodG9rZW4sIHN0YWNrLCBjb250ZXh0LCBuZXh0VG9rZW4pIHtcbiAgICAgIC8vIEV2YWx1YXRlIGtleVxuICAgICAgdmFyIHN0YXRlID0gdGhpcztcbiAgICAgIHZhciBwYXJhbXMgPSBudWxsO1xuICAgICAgdmFyIG9iamVjdDtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHJldHVybiBwYXJzZVBhcmFtcyhzdGF0ZSwgdG9rZW4ucGFyYW1zLCBjb250ZXh0KS50aGVuKGZ1bmN0aW9uIChwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtZXRlcnM7XG4gICAgICAgIHJldHVybiBUd2lnLmV4cHJlc3Npb24ucGFyc2VBc3luYy5jYWxsKHN0YXRlLCB0b2tlbi5zdGFjaywgY29udGV4dCk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgb2JqZWN0ID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICAgaWYgKG9iamVjdCAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBzdGF0ZS50ZW1wbGF0ZS5vcHRpb25zLnN0cmljdFZhcmlhYmxlcykge1xuICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKCdLZXkgXCInICsga2V5ICsgJ1wiIGZvciBhcnJheSB3aXRoIGtleXMgXCInICsga2V5cy5qb2luKCcsICcpICsgJ1wiIGRvZXMgbm90IGV4aXN0LicpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcignS2V5IFwiJyArIGtleSArICdcIiBkb2VzIG5vdCBleGlzdCBhcyB0aGUgYXJyYXkgaXMgZW1wdHkuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IC8vIEdldCB0aGUgdmFyaWFibGUgZnJvbSB0aGUgY29udGV4dFxuXG5cbiAgICAgICAgaWYgKCgwLCBfdHlwZW9mMltcImRlZmF1bHRcIl0pKG9iamVjdCkgPT09ICdvYmplY3QnICYmIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgfSAvLyBXaGVuIHJlc29sdmluZyBhbiBleHByZXNzaW9uIHdlIG5lZWQgdG8gcGFzcyBuZXh0VG9rZW4gaW4gY2FzZSB0aGUgZXhwcmVzc2lvbiBpcyBhIGZ1bmN0aW9uXG5cblxuICAgICAgICByZXR1cm4gVHdpZy5leHByZXNzaW9uLnJlc29sdmVBc3luYy5jYWxsKHN0YXRlLCB2YWx1ZSwgb2JqZWN0LCBwYXJhbXMsIG5leHRUb2tlbik7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgc3RhY2sucHVzaChyZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAgLyoqXG4gICAgICogTWF0Y2ggYSBudWxsIHZhbHVlLlxuICAgICAqL1xuICAgIHR5cGU6IFR3aWcuZXhwcmVzc2lvbi50eXBlLl9udWxsLFxuICAgIC8vIE1hdGNoIGEgbnVtYmVyXG4gICAgcmVnZXg6IC9eKG51bGx8TlVMTHxub25lfE5PTkUpLyxcbiAgICBuZXh0OiBUd2lnLmV4cHJlc3Npb24uc2V0Lm9wZXJhdGlvbnMsXG4gICAgY29tcGlsZTogZnVuY3Rpb24gY29tcGlsZSh0b2tlbiwgc3RhY2ssIG91dHB1dCkge1xuICAgICAgZGVsZXRlIHRva2VuLm1hdGNoO1xuICAgICAgdG9rZW4udmFsdWUgPSBudWxsO1xuICAgICAgb3V0cHV0LnB1c2godG9rZW4pO1xuICAgIH0sXG4gICAgcGFyc2U6IFR3aWcuZXhwcmVzc2lvbi5mbi5wYXJzZS5wdXNoVmFsdWVcbiAgfSwge1xuICAgIC8qKlxuICAgICAqIE1hdGNoIHRoZSBjb250ZXh0XG4gICAgICovXG4gICAgdHlwZTogVHdpZy5leHByZXNzaW9uLnR5cGUuY29udGV4dCxcbiAgICByZWdleDogL15fY29udGV4dC8sXG4gICAgbmV4dDogVHdpZy5leHByZXNzaW9uLnNldC5vcGVyYXRpb25zRXh0ZW5kZWQuY29uY2F0KFtUd2lnLmV4cHJlc3Npb24udHlwZS5wYXJhbWV0ZXIuc3RhcnRdKSxcbiAgICBjb21waWxlOiBUd2lnLmV4cHJlc3Npb24uZm4uY29tcGlsZS5wdXNoLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSh0b2tlbiwgc3RhY2ssIGNvbnRleHQpIHtcbiAgICAgIHN0YWNrLnB1c2goY29udGV4dCk7XG4gICAgfVxuICB9LCB7XG4gICAgLyoqXG4gICAgICogTWF0Y2ggYSBib29sZWFuXG4gICAgICovXG4gICAgdHlwZTogVHdpZy5leHByZXNzaW9uLnR5cGUuYm9vbCxcbiAgICByZWdleDogL14odHJ1ZXxUUlVFfGZhbHNlfEZBTFNFKS8sXG4gICAgbmV4dDogVHdpZy5leHByZXNzaW9uLnNldC5vcGVyYXRpb25zLFxuICAgIGNvbXBpbGU6IGZ1bmN0aW9uIGNvbXBpbGUodG9rZW4sIHN0YWNrLCBvdXRwdXQpIHtcbiAgICAgIHRva2VuLnZhbHVlID0gdG9rZW4ubWF0Y2hbMF0udG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xuICAgICAgZGVsZXRlIHRva2VuLm1hdGNoO1xuICAgICAgb3V0cHV0LnB1c2godG9rZW4pO1xuICAgIH0sXG4gICAgcGFyc2U6IFR3aWcuZXhwcmVzc2lvbi5mbi5wYXJzZS5wdXNoVmFsdWVcbiAgfV07XG4gIC8qKlxuICAgKiBSZXNvbHZlIGEgY29udGV4dCB2YWx1ZS5cbiAgICpcbiAgICogSWYgdGhlIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGl0IGlzIGV4ZWN1dGVkIHdpdGggYSBjb250ZXh0IHBhcmFtZXRlci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgY29udGV4dCBvYmplY3Qga2V5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBUaGUgcmVuZGVyIGNvbnRleHQuXG4gICAqL1xuXG4gIFR3aWcuZXhwcmVzc2lvbi5yZXNvbHZlQXN5bmMgPSBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQsIHBhcmFtcywgbmV4dFRva2VuLCBvYmplY3QpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIFR3aWcuUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZSA9IFR3aWcuUHJvbWlzZS5yZXNvbHZlKHBhcmFtcyk7XG4gICAgLypcbiAgICBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpdCB3aWxsIGhhdmUgYmVlbiBpbXBvc3NpYmxlIGR1cmluZyB0aGUgY29tcGlsZSBzdGFnZSB0byBkZXRlcm1pbmUgdGhhdCBhIGZvbGxvd2luZ1xuICAgIHNldCBvZiBwYXJlbnRoZXNlcyB3ZXJlIHBhcmFtZXRlcnMgZm9yIHRoaXMgZnVuY3Rpb24uXG4gICAgIFRob3NlIHBhcmVudGhlc2VzIHdpbGwgaGF2ZSB0aGVyZWZvcmUgYmVlbiBtYXJrZWQgYXMgYW4gZXhwcmVzc2lvbiwgd2l0aCB0aGVpciBvd24gcGFyYW1ldGVycywgd2hpY2ggcmVhbGx5XG4gICAgYmVsb25nIHRvIHRoaXMgZnVuY3Rpb24uXG4gICAgIFRob3NlIHBhcmFtZXRlcnMgd2lsbCBhbHNvIG5lZWQgcGFyc2luZyBpbiBjYXNlIHRoZXkgYXJlIGFjdHVhbGx5IGFuIGV4cHJlc3Npb24gdG8gcGFzcyBhcyBwYXJhbWV0ZXJzLlxuICAgICAgICAqL1xuXG4gICAgaWYgKG5leHRUb2tlbiAmJiBuZXh0VG9rZW4udHlwZSA9PT0gVHdpZy5leHByZXNzaW9uLnR5cGUucGFyYW1ldGVyLmVuZCkge1xuICAgICAgLy8gV2hlbiBwYXJzaW5nIHRoZXNlIHBhcmFtZXRlcnMsIHdlIG5lZWQgdG8gZ2V0IHRoZW0gYWxsIGJhY2ssIG5vdCBqdXN0IHRoZSBsYXN0IGl0ZW0gb24gdGhlIHN0YWNrLlxuICAgICAgdmFyIHRva2Vuc0FyZVBhcmFtZXRlcnMgPSB0cnVlO1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXh0VG9rZW4ucGFyYW1zICYmIFR3aWcuZXhwcmVzc2lvbi5wYXJzZUFzeW5jLmNhbGwoc3RhdGUsIG5leHRUb2tlbi5wYXJhbXMsIGNvbnRleHQsIHRva2Vuc0FyZVBhcmFtZXRlcnMpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAocCkge1xuICAgICAgICAvLyBDbGVhbiB1cCB0aGUgcGFyZW50aGVzZXMgdG9rZW5zIG9uIHRoZSBuZXh0IGxvb3BcbiAgICAgICAgbmV4dFRva2VuLmNsZWFudXAgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KG9iamVjdCB8fCBjb250ZXh0LCBwYXJhbXMgfHwgW10pO1xuICAgIH0pO1xuICB9O1xuXG4gIFR3aWcuZXhwcmVzc2lvbi5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0LCBwYXJhbXMsIG5leHRUb2tlbiwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIFR3aWcuYXN5bmMucG90ZW50aWFsbHlBc3luYyh0aGlzLCBmYWxzZSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFR3aWcuZXhwcmVzc2lvbi5yZXNvbHZlQXN5bmMuY2FsbCh0aGlzLCB2YWx1ZSwgY29udGV4dCwgcGFyYW1zLCBuZXh0VG9rZW4sIG9iamVjdCk7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBSZWdpc3RyeSBmb3IgbG9naWMgaGFuZGxlcnMuXG4gICAqL1xuXG5cbiAgVHdpZy5leHByZXNzaW9uLmhhbmRsZXIgPSB7fTtcbiAgLyoqXG4gICAqIERlZmluZSBhIG5ldyBleHByZXNzaW9uIHR5cGUsIGF2YWlsYWJsZSBhdCBUd2lnLmxvZ2ljLnR5cGUue3R5cGV9XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBuZXcgdHlwZS5cbiAgICovXG5cbiAgVHdpZy5leHByZXNzaW9uLmV4dGVuZFR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIFR3aWcuZXhwcmVzc2lvbi50eXBlW3R5cGVdID0gJ1R3aWcuZXhwcmVzc2lvbi50eXBlLicgKyB0eXBlO1xuICB9O1xuICAvKipcbiAgICogRXh0ZW5kIHRoZSBleHByZXNzaW9uIHBhcnNpbmcgZnVuY3Rpb25hbGl0eSB3aXRoIGEgbmV3IGRlZmluaXRpb24uXG4gICAqXG4gICAqIFRva2VuIGRlZmluaXRpb25zIGZvbGxvdyB0aGlzIGZvcm1hdDpcbiAgICogIHtcbiAgICogICAgICB0eXBlOiAgICAgT25lIG9mIFR3aWcuZXhwcmVzc2lvbi50eXBlLlt0eXBlXSwgZWl0aGVyIHByZS1kZWZpbmVkIG9yIGFkZGVkIHVzaW5nXG4gICAqICAgICAgICAgICAgICAgICAgICBUd2lnLmV4cHJlc3Npb24uZXh0ZW5kVHlwZVxuICAgKlxuICAgKiAgICAgIG5leHQ6ICAgICBBcnJheSBvZiB0eXBlcyBmcm9tIFR3aWcuZXhwcmVzc2lvbi50eXBlIHRoYXQgY2FuIGZvbGxvdyB0aGlzIHRva2VuLFxuICAgKlxuICAgKiAgICAgIHJlZ2V4OiAgICBBIHJlZ2V4IG9yIGFycmF5IG9mIHJlZ2V4J3MgdGhhdCBzaG91bGQgbWF0Y2ggdGhlIHRva2VuLlxuICAgKlxuICAgKiAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uKHRva2VuLCBzdGFjaywgb3V0cHV0KSBjYWxsZWQgd2hlbiB0aGlzIHRva2VuIGlzIGJlaW5nIGNvbXBpbGVkLlxuICAgKiAgICAgICAgICAgICAgICAgICBTaG91bGQgcmV0dXJuIGFuIG9iamVjdCB3aXRoIHN0YWNrIGFuZCBvdXRwdXQgc2V0LlxuICAgKlxuICAgKiAgICAgIHBhcnNlOiAgIGZ1bmN0aW9uKHRva2VuLCBzdGFjaywgY29udGV4dCkgY2FsbGVkIHdoZW4gdGhpcyB0b2tlbiBpcyBiZWluZyBwYXJzZWQuXG4gICAqICAgICAgICAgICAgICAgICAgIFNob3VsZCByZXR1cm4gYW4gb2JqZWN0IHdpdGggc3RhY2sgYW5kIGNvbnRleHQgc2V0LlxuICAgKiAgfVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVmaW5pdGlvbiBBIHRva2VuIGRlZmluaXRpb24uXG4gICAqL1xuXG5cbiAgVHdpZy5leHByZXNzaW9uLmV4dGVuZCA9IGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gICAgaWYgKCFkZWZpbml0aW9uLnR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKCdVbmFibGUgdG8gZXh0ZW5kIGxvZ2ljIGRlZmluaXRpb24uIE5vIHR5cGUgcHJvdmlkZWQgZm9yICcgKyBkZWZpbml0aW9uKTtcbiAgICB9XG5cbiAgICBUd2lnLmV4cHJlc3Npb24uaGFuZGxlcltkZWZpbml0aW9uLnR5cGVdID0gZGVmaW5pdGlvbjtcbiAgfTsgLy8gRXh0ZW5kIHdpdGggYnVpbHQtaW4gZXhwcmVzc2lvbnNcblxuXG4gIHdoaWxlIChUd2lnLmV4cHJlc3Npb24uZGVmaW5pdGlvbnMubGVuZ3RoID4gMCkge1xuICAgIFR3aWcuZXhwcmVzc2lvbi5leHRlbmQoVHdpZy5leHByZXNzaW9uLmRlZmluaXRpb25zLnNoaWZ0KCkpO1xuICB9XG4gIC8qKlxuICAgKiBCcmVhayBhbiBleHByZXNzaW9uIGludG8gdG9rZW5zIGRlZmluZWQgaW4gVHdpZy5leHByZXNzaW9uLmRlZmluaXRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBUaGUgc3RyaW5nIHRvIHRva2VuaXplLlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgdG9rZW5zLlxuICAgKi9cblxuXG4gIFR3aWcuZXhwcmVzc2lvbi50b2tlbml6ZSA9IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG4gICAgdmFyIHRva2VucyA9IFtdOyAvLyBLZWVwIGFuIG9mZnNldCBvZiB0aGUgbG9jYXRpb24gaW4gdGhlIGV4cHJlc3Npb24gZm9yIGVycm9yIG1lc3NhZ2VzLlxuXG4gICAgdmFyIGV4cE9mZnNldCA9IDA7IC8vIFRoZSB2YWxpZCBuZXh0IHRva2VucyBvZiB0aGUgcHJldmlvdXMgdG9rZW5cblxuICAgIHZhciBuZXh0ID0gbnVsbDsgLy8gTWF0Y2ggaW5mb3JtYXRpb25cblxuICAgIHZhciB0eXBlO1xuICAgIHZhciByZWdleDtcbiAgICB2YXIgcmVnZXhJOyAvLyBUaGUgcG9zc2libGUgbmV4dCB0b2tlbiBmb3IgdGhlIG1hdGNoXG5cbiAgICB2YXIgdG9rZW5OZXh0OyAvLyBIYXMgYSBtYXRjaCBiZWVuIGZvdW5kIGZyb20gdGhlIGRlZmluaXRpb25zXG5cbiAgICB2YXIgbWF0Y2hGb3VuZDtcbiAgICB2YXIgaW52YWxpZE1hdGNoZXMgPSBbXTtcblxuICAgIHZhciBtYXRjaEZ1bmN0aW9uID0gZnVuY3Rpb24gbWF0Y2hGdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICAvLyBEb24ndCBwYXNzIGFyZ3VtZW50cyB0byBgQXJyYXkuc2xpY2VgLCB0aGF0IGlzIGEgcGVyZm9ybWFuY2Uga2lsbGVyXG4gICAgICB2YXIgbWF0Y2hJID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgICB2YXIgbWF0Y2ggPSBuZXcgQXJyYXkobWF0Y2hJKTtcblxuICAgICAgd2hpbGUgKG1hdGNoSS0tID4gMCkge1xuICAgICAgICBtYXRjaFttYXRjaEldID0gYXJnc1ttYXRjaEldO1xuICAgICAgfVxuXG4gICAgICBUd2lnLmxvZy50cmFjZSgnVHdpZy5leHByZXNzaW9uLnRva2VuaXplJywgJ01hdGNoZWQgYSAnLCB0eXBlLCAnIHJlZ3VsYXIgZXhwcmVzc2lvbiBvZiAnLCBtYXRjaCk7XG5cbiAgICAgIGlmIChuZXh0ICYmICFuZXh0LmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgICAgIGludmFsaWRNYXRjaGVzLnB1c2godHlwZSArICcgY2Fubm90IGZvbGxvdyBhICcgKyB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnR5cGUgKyAnIGF0IHRlbXBsYXRlOicgKyBleHBPZmZzZXQgKyAnIG5lYXIgXFwnJyArIG1hdGNoWzBdLnNsaWNlKDAsIDIwKSArICcuLi5cXCcnKTsgLy8gTm90IGEgbWF0Y2gsIGRvbid0IGNoYW5nZSB0aGUgZXhwcmVzc2lvblxuXG4gICAgICAgIHJldHVybiBtYXRjaFswXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhbmRsZXIgPSBUd2lnLmV4cHJlc3Npb24uaGFuZGxlclt0eXBlXTsgLy8gVmFsaWRhdGUgdGhlIHRva2VuIGlmIGEgdmFsaWRhdGlvbiBmdW5jdGlvbiBpcyBwcm92aWRlZFxuXG4gICAgICBpZiAoaGFuZGxlci52YWxpZGF0ZSAmJiAhaGFuZGxlci52YWxpZGF0ZShtYXRjaCwgdG9rZW5zKSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hbMF07XG4gICAgICB9XG5cbiAgICAgIGludmFsaWRNYXRjaGVzID0gW107XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHZhbHVlOiBtYXRjaFswXSxcbiAgICAgICAgbWF0Y2g6IG1hdGNoXG4gICAgICB9KTtcbiAgICAgIG1hdGNoRm91bmQgPSB0cnVlO1xuICAgICAgbmV4dCA9IHRva2VuTmV4dDtcbiAgICAgIGV4cE9mZnNldCArPSBtYXRjaFswXS5sZW5ndGg7IC8vIERvZXMgdGhlIHRva2VuIG5lZWQgdG8gcmV0dXJuIG91dHB1dCBiYWNrIHRvIHRoZSBleHByZXNzaW9uIHN0cmluZ1xuICAgICAgLy8gZS5nLiBhIGZ1bmN0aW9uIG1hdGNoIG9mIGN5Y2xlKCBtaWdodCByZXR1cm4gdGhlICcoJyBiYWNrIHRvIHRoZSBleHByZXNzaW9uXG4gICAgICAvLyBUaGlzIGFsbG93cyBsb29rLWFoZWFkIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiB0b2tlbiB0eXBlcyAoZS5nLiBmdW5jdGlvbnMgYW5kIHZhcmlhYmxlIG5hbWVzKVxuXG4gICAgICBpZiAoaGFuZGxlci50cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIudHJhbnNmb3JtKG1hdGNoLCB0b2tlbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJyc7XG4gICAgfTtcblxuICAgIFR3aWcubG9nLmRlYnVnKCdUd2lnLmV4cHJlc3Npb24udG9rZW5pemUnLCAnVG9rZW5pemluZyBleHByZXNzaW9uICcsIGV4cHJlc3Npb24pO1xuXG4gICAgd2hpbGUgKGV4cHJlc3Npb24ubGVuZ3RoID4gMCkge1xuICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24udHJpbSgpO1xuXG4gICAgICBmb3IgKHR5cGUgaW4gVHdpZy5leHByZXNzaW9uLmhhbmRsZXIpIHtcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKFR3aWcuZXhwcmVzc2lvbi5oYW5kbGVyLCB0eXBlKSkge1xuICAgICAgICAgIHRva2VuTmV4dCA9IFR3aWcuZXhwcmVzc2lvbi5oYW5kbGVyW3R5cGVdLm5leHQ7XG4gICAgICAgICAgcmVnZXggPSBUd2lnLmV4cHJlc3Npb24uaGFuZGxlclt0eXBlXS5yZWdleDtcbiAgICAgICAgICBUd2lnLmxvZy50cmFjZSgnQ2hlY2tpbmcgdHlwZSAnLCB0eXBlLCAnIG9uICcsIGV4cHJlc3Npb24pO1xuICAgICAgICAgIG1hdGNoRm91bmQgPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlZ2V4KSkge1xuICAgICAgICAgICAgcmVnZXhJID0gcmVnZXgubGVuZ3RoO1xuXG4gICAgICAgICAgICB3aGlsZSAocmVnZXhJLS0gPiAwKSB7XG4gICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLnJlcGxhY2UocmVnZXhbcmVnZXhJXSwgbWF0Y2hGdW5jdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLnJlcGxhY2UocmVnZXgsIG1hdGNoRnVuY3Rpb24pO1xuICAgICAgICAgIH0gLy8gQW4gZXhwcmVzc2lvbiB0b2tlbiBoYXMgYmVlbiBtYXRjaGVkLiBCcmVhayB0aGUgZm9yIGxvb3AgYW5kIHN0YXJ0IHRyeWluZyB0b1xuICAgICAgICAgIC8vICBtYXRjaCB0aGUgbmV4dCB0ZW1wbGF0ZSAoaWYgZXhwcmVzc2lvbiBpc24ndCBlbXB0eS4pXG5cblxuICAgICAgICAgIGlmIChtYXRjaEZvdW5kKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFtYXRjaEZvdW5kKSB7XG4gICAgICAgIGlmIChpbnZhbGlkTWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoaW52YWxpZE1hdGNoZXMuam9pbignIE9SICcpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcignVW5hYmxlIHRvIHBhcnNlIFxcJycgKyBleHByZXNzaW9uICsgJ1xcJyBhdCB0ZW1wbGF0ZSBwb3NpdGlvbicgKyBleHBPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgVHdpZy5sb2cudHJhY2UoJ1R3aWcuZXhwcmVzc2lvbi50b2tlbml6ZScsICdUb2tlbml6ZWQgdG8gJywgdG9rZW5zKTtcbiAgICByZXR1cm4gdG9rZW5zO1xuICB9O1xuICAvKipcbiAgICogQ29tcGlsZSBhbiBleHByZXNzaW9uIHRva2VuLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmF3VG9rZW4gVGhlIHVuY29tcGlsZWQgdG9rZW4uXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbXBpbGVkIHRva2VuLlxuICAgKi9cblxuXG4gIFR3aWcuZXhwcmVzc2lvbi5jb21waWxlID0gZnVuY3Rpb24gKHJhd1Rva2VuKSB7XG4gICAgdmFyIGV4cHJlc3Npb24gPSByYXdUb2tlbi52YWx1ZTsgLy8gVG9rZW5pemUgZXhwcmVzc2lvblxuXG4gICAgdmFyIHRva2VucyA9IFR3aWcuZXhwcmVzc2lvbi50b2tlbml6ZShleHByZXNzaW9uKTtcbiAgICB2YXIgdG9rZW4gPSBudWxsO1xuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIgdG9rZW5UZW1wbGF0ZSA9IG51bGw7XG4gICAgVHdpZy5sb2cudHJhY2UoJ1R3aWcuZXhwcmVzc2lvbi5jb21waWxlOiAnLCAnQ29tcGlsaW5nICcsIGV4cHJlc3Npb24pOyAvLyBQdXNoIHRva2VucyBpbnRvIFJQTiBzdGFjayB1c2luZyB0aGUgU2h1bnRpbmcteWFyZCBhbGdvcml0aG1cbiAgICAvLyBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TaHVudGluZ195YXJkX2FsZ29yaXRobVxuXG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICB0b2tlbiA9IHRva2Vucy5zaGlmdCgpO1xuICAgICAgdG9rZW5UZW1wbGF0ZSA9IFR3aWcuZXhwcmVzc2lvbi5oYW5kbGVyW3Rva2VuLnR5cGVdO1xuICAgICAgVHdpZy5sb2cudHJhY2UoJ1R3aWcuZXhwcmVzc2lvbi5jb21waWxlOiAnLCAnQ29tcGlsaW5nICcsIHRva2VuKTsgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGVcblxuICAgICAgdG9rZW5UZW1wbGF0ZS5jb21waWxlKHRva2VuLCBzdGFjaywgb3V0cHV0KTtcbiAgICAgIFR3aWcubG9nLnRyYWNlKCdUd2lnLmV4cHJlc3Npb24uY29tcGlsZTogJywgJ1N0YWNrIGlzJywgc3RhY2spO1xuICAgICAgVHdpZy5sb2cudHJhY2UoJ1R3aWcuZXhwcmVzc2lvbi5jb21waWxlOiAnLCAnT3V0cHV0IGlzJywgb3V0cHV0KTtcbiAgICB9XG5cbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgb3V0cHV0LnB1c2goc3RhY2sucG9wKCkpO1xuICAgIH1cblxuICAgIFR3aWcubG9nLnRyYWNlKCdUd2lnLmV4cHJlc3Npb24uY29tcGlsZTogJywgJ0ZpbmFsIG91dHB1dCBpcycsIG91dHB1dCk7XG4gICAgcmF3VG9rZW4uc3RhY2sgPSBvdXRwdXQ7XG4gICAgZGVsZXRlIHJhd1Rva2VuLnZhbHVlO1xuICAgIHJldHVybiByYXdUb2tlbjtcbiAgfTtcbiAgLyoqXG4gICAqIFBhcnNlIGFuIFJQTiBleHByZXNzaW9uIHN0YWNrIHdpdGhpbiBhIGNvbnRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHRva2VucyBBbiBhcnJheSBvZiBjb21waWxlZCBleHByZXNzaW9uIHRva2Vucy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgVGhlIHJlbmRlciBjb250ZXh0IHRvIHBhcnNlIHRoZSB0b2tlbnMgd2l0aC5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0IG9mIHBhcnNpbmcgYWxsIHRoZSB0b2tlbnMuIFRoZSByZXN1bHRcbiAgICogICAgICAgICAgICAgICAgICBjYW4gYmUgYW55dGhpbmcsIFN0cmluZywgQXJyYXksIE9iamVjdCwgZXRjLi4uIGJhc2VkIG9uXG4gICAqICAgICAgICAgICAgICAgICAgdGhlIGdpdmVuIGV4cHJlc3Npb24uXG4gICAqL1xuXG5cbiAgVHdpZy5leHByZXNzaW9uLnBhcnNlID0gZnVuY3Rpb24gKHRva2VucywgY29udGV4dCwgdG9rZW5zQXJlUGFyYW1ldGVycywgYWxsb3dBc3luYykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXM7IC8vIElmIHRoZSB0b2tlbiBpc24ndCBhbiBhcnJheSwgbWFrZSBpdCBvbmUuXG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodG9rZW5zKSkge1xuICAgICAgdG9rZW5zID0gW3Rva2Vuc107XG4gICAgfSAvLyBUaGUgb3V0cHV0IHN0YWNrXG5cblxuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBsb29wVG9rZW5GaXh1cHMgPSBbXTtcbiAgICB2YXIgYmluYXJ5T3BlcmF0b3IgPSBUd2lnLmV4cHJlc3Npb24udHlwZS5vcGVyYXRvci5iaW5hcnk7XG4gICAgcmV0dXJuIFR3aWcuYXN5bmMucG90ZW50aWFsbHlBc3luYyhzdGF0ZSwgYWxsb3dBc3luYywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFR3aWcuYXN5bmMuZm9yRWFjaCh0b2tlbnMsIGZ1bmN0aW9uICh0b2tlbiwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHRva2VuVGVtcGxhdGUgPSBudWxsO1xuICAgICAgICB2YXIgbmV4dFRva2VuID0gbnVsbDtcbiAgICAgICAgdmFyIHJlc3VsdDsgLy8gSWYgdGhlIHRva2VuIGlzIG1hcmtlZCBmb3IgY2xlYW51cCwgd2UgZG9uJ3QgbmVlZCB0byBwYXJzZSBpdFxuXG4gICAgICAgIGlmICh0b2tlbi5jbGVhbnVwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIERldGVybWluZSB0aGUgdG9rZW4gdGhhdCBmb2xsb3dzIHRoaXMgb25lIHNvIHRoYXQgd2UgY2FuIHBhc3MgaXQgdG8gdGhlIHBhcnNlclxuXG5cbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiBpbmRleCArIDEpIHtcbiAgICAgICAgICBuZXh0VG9rZW4gPSB0b2tlbnNbaW5kZXggKyAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRva2VuVGVtcGxhdGUgPSBUd2lnLmV4cHJlc3Npb24uaGFuZGxlclt0b2tlbi50eXBlXTtcblxuICAgICAgICBpZiAodG9rZW5UZW1wbGF0ZS5wYXJzZSkge1xuICAgICAgICAgIHJlc3VsdCA9IHRva2VuVGVtcGxhdGUucGFyc2UuY2FsbChzdGF0ZSwgdG9rZW4sIHN0YWNrLCBjb250ZXh0LCBuZXh0VG9rZW4pO1xuICAgICAgICB9IC8vIFN0b3JlIGFueSBiaW5hcnkgdG9rZW5zIGZvciBsYXRlciBpZiB3ZSBhcmUgaW4gYSBsb29wLlxuXG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IGJpbmFyeU9wZXJhdG9yICYmIGNvbnRleHQubG9vcCkge1xuICAgICAgICAgIGxvb3BUb2tlbkZpeHVwcy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQ2hlY2sgZXZlcnkgZml4dXAgYW5kIHJlbW92ZSBcImtleVwiIGFzIGxvbmcgYXMgdGhleSBzdGlsbCBoYXZlIFwicGFyYW1zXCIuIFRoaXMgY292ZXJzIHRoZSB1c2UgY2FzZSB3aGVyZVxuICAgICAgICAvLyBhIFwiOlwiIG9wZXJhdG9yIGlzIHVzZWQgaW4gYSBsb29wIHdpdGggYSBcIihleHByZXNzaW9uKTpcIiBzdGF0ZW1lbnQuIFdlIG5lZWQgdG8gYmUgYWJsZSB0byBldmFsdWF0ZSB0aGUgZXhwcmVzc2lvblxuICAgICAgICB2YXIgbGVuID0gbG9vcFRva2VuRml4dXBzLmxlbmd0aDtcbiAgICAgICAgdmFyIGxvb3BUb2tlbkZpeHVwID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAobGVuLS0gPiAwKSB7XG4gICAgICAgICAgbG9vcFRva2VuRml4dXAgPSBsb29wVG9rZW5GaXh1cHNbbGVuXTtcblxuICAgICAgICAgIGlmIChsb29wVG9rZW5GaXh1cC5wYXJhbXMgJiYgbG9vcFRva2VuRml4dXAua2V5KSB7XG4gICAgICAgICAgICBkZWxldGUgbG9vcFRva2VuRml4dXAua2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBJZiBwYXJzZSBoYXMgYmVlbiBjYWxsZWQgd2l0aCBhIHNldCBvZiB0b2tlbnMgdGhhdCBhcmUgcGFyYW1ldGVycywgd2UgbmVlZCB0byByZXR1cm4gdGhlIHdob2xlIHN0YWNrLFxuICAgICAgICAvLyB3cmFwcGVkIGluIGFuIEFycmF5LlxuXG5cbiAgICAgICAgaWYgKHRva2Vuc0FyZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICB2YXIgcGFyYW1zID0gc3RhY2suc3BsaWNlKDApO1xuICAgICAgICAgIHN0YWNrLnB1c2gocGFyYW1zKTtcbiAgICAgICAgfSAvLyBQb3AgdGhlIGZpbmFsIHZhbHVlIG9mZiB0aGUgc3RhY2tcblxuXG4gICAgICAgIHJldHVybiBzdGFjay5wb3AoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBUd2lnO1xufTtcblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXJyYXlXaXRob3V0SG9sZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXG52YXIgbm9uSXRlcmFibGVTcHJlYWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90b0NvbnN1bWFibGVBcnJheTtcblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyMltpXSA9IGFycltpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhvdXRIb2xlcztcblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXIpID09PSBcIltvYmplY3QgQXJndW1lbnRzXVwiKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5O1xuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVNwcmVhZDtcblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vLyAjIyB0d2lnLmV4cHJlc3Npb24ub3BlcmF0b3IuanNcbi8vXG4vLyBUaGlzIGZpbGUgaGFuZGxlcyBvcGVyYXRvciBsb29rdXBzIGFuZCBwYXJzaW5nLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVHdpZykge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBPcGVyYXRvciBhc3NvY2lhdGl2aXR5IGNvbnN0YW50cy5cbiAgICovXG5cbiAgVHdpZy5leHByZXNzaW9uLm9wZXJhdG9yID0ge1xuICAgIGxlZnRUb1JpZ2h0OiAnbGVmdFRvUmlnaHQnLFxuICAgIHJpZ2h0VG9MZWZ0OiAncmlnaHRUb0xlZnQnXG4gIH07XG5cbiAgdmFyIGNvbnRhaW5tZW50ID0gZnVuY3Rpb24gY29udGFpbm1lbnQoYSwgYikge1xuICAgIGlmIChiID09PSB1bmRlZmluZWQgfHwgYiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGIuaW5kZXhPZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBTdHJpbmdcbiAgICAgIHJldHVybiAoYSA9PT0gYiB8fCBhICE9PSAnJykgJiYgYi5pbmNsdWRlcyhhKTtcbiAgICB9XG5cbiAgICB2YXIgZWw7XG5cbiAgICBmb3IgKGVsIGluIGIpIHtcbiAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChiLCBlbCkgJiYgYltlbF0gPT09IGEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICAvKipcbiAgICogR2V0IHRoZSBwcmVjaWRlbmNlIGFuZCBhc3NvY2lhdGl2aXR5IG9mIGFuIG9wZXJhdG9yLiBUaGVzZSBmb2xsb3cgdGhlIG9yZGVyIHRoYXQgQy9DKysgdXNlLlxuICAgKiBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9PcGVyYXRvcnNfaW5fQ19hbmRfQysrIGZvciB0aGUgdGFibGUgb2YgdmFsdWVzLlxuICAgKi9cblxuXG4gIFR3aWcuZXhwcmVzc2lvbi5vcGVyYXRvci5sb29rdXAgPSBmdW5jdGlvbiAob3BlcmF0b3IsIHRva2VuKSB7XG4gICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgY2FzZSAnLi4nOlxuICAgICAgICB0b2tlbi5wcmVjaWRlbmNlID0gMjA7XG4gICAgICAgIHRva2VuLmFzc29jaWF0aXZpdHkgPSBUd2lnLmV4cHJlc3Npb24ub3BlcmF0b3IubGVmdFRvUmlnaHQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICcsJzpcbiAgICAgICAgdG9rZW4ucHJlY2lkZW5jZSA9IDE4O1xuICAgICAgICB0b2tlbi5hc3NvY2lhdGl2aXR5ID0gVHdpZy5leHByZXNzaW9uLm9wZXJhdG9yLmxlZnRUb1JpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIFRlcm5hcnlcblxuICAgICAgY2FzZSAnPzonOlxuICAgICAgY2FzZSAnPyc6XG4gICAgICBjYXNlICc6JzpcbiAgICAgICAgdG9rZW4ucHJlY2lkZW5jZSA9IDE2O1xuICAgICAgICB0b2tlbi5hc3NvY2lhdGl2aXR5ID0gVHdpZy5leHByZXNzaW9uLm9wZXJhdG9yLnJpZ2h0VG9MZWZ0O1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIE51bGwtY29hbGVzY2luZyBvcGVyYXRvclxuXG4gICAgICBjYXNlICc/Pyc6XG4gICAgICAgIHRva2VuLnByZWNpZGVuY2UgPSAxNTtcbiAgICAgICAgdG9rZW4uYXNzb2NpYXRpdml0eSA9IFR3aWcuZXhwcmVzc2lvbi5vcGVyYXRvci5yaWdodFRvTGVmdDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29yJzpcbiAgICAgICAgdG9rZW4ucHJlY2lkZW5jZSA9IDE0O1xuICAgICAgICB0b2tlbi5hc3NvY2lhdGl2aXR5ID0gVHdpZy5leHByZXNzaW9uLm9wZXJhdG9yLmxlZnRUb1JpZ2h0O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYW5kJzpcbiAgICAgICAgdG9rZW4ucHJlY2lkZW5jZSA9IDEzO1xuICAgICAgICB0b2tlbi5hc3NvY2lhdGl2aXR5ID0gVHdpZy5leHByZXNzaW9uLm9wZXJhdG9yLmxlZnRUb1JpZ2h0O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYi1vcic6XG4gICAgICAgIHRva2VuLnByZWNpZGVuY2UgPSAxMjtcbiAgICAgICAgdG9rZW4uYXNzb2NpYXRpdml0eSA9IFR3aWcuZXhwcmVzc2lvbi5vcGVyYXRvci5sZWZ0VG9SaWdodDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2IteG9yJzpcbiAgICAgICAgdG9rZW4ucHJlY2lkZW5jZSA9IDExO1xuICAgICAgICB0b2tlbi5hc3NvY2lhdGl2aXR5ID0gVHdpZy5leHByZXNzaW9uLm9wZXJhdG9yLmxlZnRUb1JpZ2h0O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYi1hbmQnOlxuICAgICAgICB0b2tlbi5wcmVjaWRlbmNlID0gMTA7XG4gICAgICAgIHRva2VuLmFzc29jaWF0aXZpdHkgPSBUd2lnLmV4cHJlc3Npb24ub3BlcmF0b3IubGVmdFRvUmlnaHQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICc9PSc6XG4gICAgICBjYXNlICchPSc6XG4gICAgICAgIHRva2VuLnByZWNpZGVuY2UgPSA5O1xuICAgICAgICB0b2tlbi5hc3NvY2lhdGl2aXR5ID0gVHdpZy5leHByZXNzaW9uLm9wZXJhdG9yLmxlZnRUb1JpZ2h0O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnPCc6XG4gICAgICBjYXNlICc8PSc6XG4gICAgICBjYXNlICc+JzpcbiAgICAgIGNhc2UgJz49JzpcbiAgICAgIGNhc2UgJ25vdCBpbic6XG4gICAgICBjYXNlICdpbic6XG4gICAgICAgIHRva2VuLnByZWNpZGVuY2UgPSA4O1xuICAgICAgICB0b2tlbi5hc3NvY2lhdGl2aXR5ID0gVHdpZy5leHByZXNzaW9uLm9wZXJhdG9yLmxlZnRUb1JpZ2h0O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnfic6IC8vIFN0cmluZyBjb25jYXRpbmF0aW9uXG5cbiAgICAgIGNhc2UgJysnOlxuICAgICAgY2FzZSAnLSc6XG4gICAgICAgIHRva2VuLnByZWNpZGVuY2UgPSA2O1xuICAgICAgICB0b2tlbi5hc3NvY2lhdGl2aXR5ID0gVHdpZy5leHByZXNzaW9uLm9wZXJhdG9yLmxlZnRUb1JpZ2h0O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnLy8nOlxuICAgICAgY2FzZSAnKionOlxuICAgICAgY2FzZSAnKic6XG4gICAgICBjYXNlICcvJzpcbiAgICAgIGNhc2UgJyUnOlxuICAgICAgICB0b2tlbi5wcmVjaWRlbmNlID0gNTtcbiAgICAgICAgdG9rZW4uYXNzb2NpYXRpdml0eSA9IFR3aWcuZXhwcmVzc2lvbi5vcGVyYXRvci5sZWZ0VG9SaWdodDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ25vdCc6XG4gICAgICAgIHRva2VuLnByZWNpZGVuY2UgPSAzO1xuICAgICAgICB0b2tlbi5hc3NvY2lhdGl2aXR5ID0gVHdpZy5leHByZXNzaW9uLm9wZXJhdG9yLnJpZ2h0VG9MZWZ0O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbWF0Y2hlcyc6XG4gICAgICAgIHRva2VuLnByZWNpZGVuY2UgPSA4O1xuICAgICAgICB0b2tlbi5hc3NvY2lhdGl2aXR5ID0gVHdpZy5leHByZXNzaW9uLm9wZXJhdG9yLmxlZnRUb1JpZ2h0O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc3RhcnRzIHdpdGgnOlxuICAgICAgICB0b2tlbi5wcmVjaWRlbmNlID0gODtcbiAgICAgICAgdG9rZW4uYXNzb2NpYXRpdml0eSA9IFR3aWcuZXhwcmVzc2lvbi5vcGVyYXRvci5sZWZ0VG9SaWdodDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2VuZHMgd2l0aCc6XG4gICAgICAgIHRva2VuLnByZWNpZGVuY2UgPSA4O1xuICAgICAgICB0b2tlbi5hc3NvY2lhdGl2aXR5ID0gVHdpZy5leHByZXNzaW9uLm9wZXJhdG9yLmxlZnRUb1JpZ2h0O1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoJ0ZhaWxlZCB0byBsb29rdXAgb3BlcmF0b3I6ICcgKyBvcGVyYXRvciArICcgaXMgYW4gdW5rbm93biBvcGVyYXRvci4nKTtcbiAgICB9XG5cbiAgICB0b2tlbi5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgIHJldHVybiB0b2tlbjtcbiAgfTtcbiAgLyoqXG4gICAqIEhhbmRsZSBvcGVyYXRpb25zIG9uIHRoZSBSUE4gc3RhY2suXG4gICAqXG4gICAqIFJldHVybnMgdGhlIHVwZGF0ZWQgc3RhY2suXG4gICAqL1xuXG5cbiAgVHdpZy5leHByZXNzaW9uLm9wZXJhdG9yLnBhcnNlID0gZnVuY3Rpb24gKG9wZXJhdG9yLCBzdGFjaykge1xuICAgIFR3aWcubG9nLnRyYWNlKCdUd2lnLmV4cHJlc3Npb24ub3BlcmF0b3IucGFyc2U6ICcsICdIYW5kbGluZyAnLCBvcGVyYXRvcik7XG4gICAgdmFyIGE7XG4gICAgdmFyIGI7XG4gICAgdmFyIGM7XG5cbiAgICBpZiAob3BlcmF0b3IgPT09ICc/Jykge1xuICAgICAgYyA9IHN0YWNrLnBvcCgpO1xuICAgIH1cblxuICAgIGIgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChvcGVyYXRvciAhPT0gJ25vdCcpIHtcbiAgICAgIGEgPSBzdGFjay5wb3AoKTtcbiAgICB9XG5cbiAgICBpZiAob3BlcmF0b3IgIT09ICdpbicgJiYgb3BlcmF0b3IgIT09ICdub3QgaW4nICYmIG9wZXJhdG9yICE9PSAnPz8nKSB7XG4gICAgICBpZiAoYSAmJiBBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIGEgPSBhLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGIgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICBiID0gYi5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wZXJhdG9yID09PSAnbWF0Y2hlcycpIHtcbiAgICAgIGlmIChiICYmIHR5cGVvZiBiID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgcmVQYXJ0cyA9IGIubWF0Y2goL15cXC8oLiopXFwvKFtnaW1zXT8pJC8pO1xuICAgICAgICB2YXIgcmVCb2R5ID0gcmVQYXJ0c1sxXTtcbiAgICAgICAgdmFyIHJlRmxhZ3MgPSByZVBhcnRzWzJdO1xuICAgICAgICBiID0gbmV3IFJlZ0V4cChyZUJvZHksIHJlRmxhZ3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgIGNhc2UgJzonOlxuICAgICAgICAvLyBJZ25vcmVcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJz8/JzpcbiAgICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGEgPSBiO1xuICAgICAgICAgIGIgPSBjO1xuICAgICAgICAgIGMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYSAhPT0gdW5kZWZpbmVkICYmIGEgIT09IG51bGwpIHtcbiAgICAgICAgICBzdGFjay5wdXNoKGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YWNrLnB1c2goYik7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnPzonOlxuICAgICAgICBpZiAoVHdpZy5saWIuYm9vbHZhbChhKSkge1xuICAgICAgICAgIHN0YWNrLnB1c2goYSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhY2sucHVzaChiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICc/JzpcbiAgICAgICAgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIEFuIGV4dGVuZGVkIHRlcm5hcnkuXG4gICAgICAgICAgYSA9IGI7XG4gICAgICAgICAgYiA9IGM7XG4gICAgICAgICAgYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChUd2lnLmxpYi5ib29sdmFsKGEpKSB7XG4gICAgICAgICAgc3RhY2sucHVzaChiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFjay5wdXNoKGMpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJysnOlxuICAgICAgICBiID0gcGFyc2VGbG9hdChiKTtcbiAgICAgICAgYSA9IHBhcnNlRmxvYXQoYSk7XG4gICAgICAgIHN0YWNrLnB1c2goYSArIGIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnLSc6XG4gICAgICAgIGIgPSBwYXJzZUZsb2F0KGIpO1xuICAgICAgICBhID0gcGFyc2VGbG9hdChhKTtcbiAgICAgICAgc3RhY2sucHVzaChhIC0gYik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICcqJzpcbiAgICAgICAgYiA9IHBhcnNlRmxvYXQoYik7XG4gICAgICAgIGEgPSBwYXJzZUZsb2F0KGEpO1xuICAgICAgICBzdGFjay5wdXNoKGEgKiBiKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJy8nOlxuICAgICAgICBiID0gcGFyc2VGbG9hdChiKTtcbiAgICAgICAgYSA9IHBhcnNlRmxvYXQoYSk7XG4gICAgICAgIHN0YWNrLnB1c2goYSAvIGIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnLy8nOlxuICAgICAgICBiID0gcGFyc2VGbG9hdChiKTtcbiAgICAgICAgYSA9IHBhcnNlRmxvYXQoYSk7XG4gICAgICAgIHN0YWNrLnB1c2goTWF0aC5mbG9vcihhIC8gYikpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnJSc6XG4gICAgICAgIGIgPSBwYXJzZUZsb2F0KGIpO1xuICAgICAgICBhID0gcGFyc2VGbG9hdChhKTtcbiAgICAgICAgc3RhY2sucHVzaChhICUgYik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd+JzpcbiAgICAgICAgc3RhY2sucHVzaCgodHlwZW9mIGEgIT09ICd1bmRlZmluZWQnICYmIGEgIT09IG51bGwgPyBhLnRvU3RyaW5nKCkgOiAnJykgKyAodHlwZW9mIGIgIT09ICd1bmRlZmluZWQnICYmIGIgIT09IG51bGwgPyBiLnRvU3RyaW5nKCkgOiAnJykpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbm90JzpcbiAgICAgIGNhc2UgJyEnOlxuICAgICAgICBzdGFjay5wdXNoKCFUd2lnLmxpYi5ib29sdmFsKGIpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJzwnOlxuICAgICAgICBzdGFjay5wdXNoKGEgPCBiKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgc3RhY2sucHVzaChhIDw9IGIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnPic6XG4gICAgICAgIHN0YWNrLnB1c2goYSA+IGIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnPj0nOlxuICAgICAgICBzdGFjay5wdXNoKGEgPj0gYik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICc9PT0nOlxuICAgICAgICBzdGFjay5wdXNoKGEgPT09IGIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnPT0nOlxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxICovXG4gICAgICAgIHN0YWNrLnB1c2goYSA9PSBiKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgIHN0YWNrLnB1c2goYSAhPT0gYik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICchPSc6XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXEgKi9cbiAgICAgICAgc3RhY2sucHVzaChhICE9IGIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnb3InOlxuICAgICAgICBzdGFjay5wdXNoKFR3aWcubGliLmJvb2x2YWwoYSkgfHwgVHdpZy5saWIuYm9vbHZhbChiKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdiLW9yJzpcbiAgICAgICAgc3RhY2sucHVzaChhIHwgYik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdiLXhvcic6XG4gICAgICAgIHN0YWNrLnB1c2goYSBeIGIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYW5kJzpcbiAgICAgICAgc3RhY2sucHVzaChUd2lnLmxpYi5ib29sdmFsKGEpICYmIFR3aWcubGliLmJvb2x2YWwoYikpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYi1hbmQnOlxuICAgICAgICBzdGFjay5wdXNoKGEgJiBiKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJyoqJzpcbiAgICAgICAgc3RhY2sucHVzaChNYXRoLnBvdyhhLCBiKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdub3QgaW4nOlxuICAgICAgICBzdGFjay5wdXNoKCFjb250YWlubWVudChhLCBiKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdpbic6XG4gICAgICAgIHN0YWNrLnB1c2goY29udGFpbm1lbnQoYSwgYikpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbWF0Y2hlcyc6XG4gICAgICAgIHN0YWNrLnB1c2goYi50ZXN0KGEpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3N0YXJ0cyB3aXRoJzpcbiAgICAgICAgc3RhY2sucHVzaCh0eXBlb2YgYSA9PT0gJ3N0cmluZycgJiYgYS5pbmRleE9mKGIpID09PSAwKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2VuZHMgd2l0aCc6XG4gICAgICAgIHN0YWNrLnB1c2godHlwZW9mIGEgPT09ICdzdHJpbmcnICYmIGEuaW5jbHVkZXMoYiwgYS5sZW5ndGggLSBiLmxlbmd0aCkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnLi4nOlxuICAgICAgICBzdGFjay5wdXNoKFR3aWcuZnVuY3Rpb25zLnJhbmdlKGEsIGIpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKCdGYWlsZWQgdG8gcGFyc2Ugb3BlcmF0b3I6ICcgKyBvcGVyYXRvciArICcgaXMgYW4gdW5rbm93biBvcGVyYXRvci4nKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFR3aWc7XG59O1xuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcblxuLy8gIyMgdHdpZy5maWx0ZXJzLmpzXG4vL1xuLy8gVGhpcyBmaWxlIGhhbmRsZXMgcGFyc2luZyBmaWx0ZXJzLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVHdpZykge1xuICAvLyBEZXRlcm1pbmUgb2JqZWN0IHR5cGVcbiAgZnVuY3Rpb24gaXModHlwZSwgb2JqKSB7XG4gICAgdmFyIGNsYXMgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKS5zbGljZSg4LCAtMSk7XG4gICAgcmV0dXJuIG9iaiAhPT0gdW5kZWZpbmVkICYmIG9iaiAhPT0gbnVsbCAmJiBjbGFzID09PSB0eXBlO1xuICB9XG5cbiAgVHdpZy5maWx0ZXJzID0ge1xuICAgIC8vIFN0cmluZyBGaWx0ZXJzXG4gICAgdXBwZXI6IGZ1bmN0aW9uIHVwcGVyKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZS50b1VwcGVyQ2FzZSgpO1xuICAgIH0sXG4gICAgbG93ZXI6IGZ1bmN0aW9uIGxvd2VyKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH0sXG4gICAgY2FwaXRhbGl6ZTogZnVuY3Rpb24gY2FwaXRhbGl6ZSh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMCwgMSkudG9VcHBlckNhc2UoKSArIHZhbHVlLnRvTG93ZXJDYXNlKCkuc2xpY2UoMSk7XG4gICAgfSxcbiAgICB0aXRsZTogZnVuY3Rpb24gdGl0bGUodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvKF58XFxzKShbYS16XSkvZywgZnVuY3Rpb24gKG0sIHAxLCBwMikge1xuICAgICAgICByZXR1cm4gcDEgKyBwMi50b1VwcGVyQ2FzZSgpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBsZW5ndGg6IGZ1bmN0aW9uIGxlbmd0aCh2YWx1ZSkge1xuICAgICAgaWYgKFR3aWcubGliLmlzKCdBcnJheScsIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChUd2lnLmxpYi5pcygnT2JqZWN0JywgdmFsdWUpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5fa2V5cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWUuX2tleXMubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIC8vIEFycmF5L09iamVjdCBGaWx0ZXJzXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSh2YWx1ZSkge1xuICAgICAgaWYgKGlzKCdBcnJheScsIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUucmV2ZXJzZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXMoJ1N0cmluZycsIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzKCdPYmplY3QnLCB2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGtleXMgPSB2YWx1ZS5fa2V5cyB8fCBPYmplY3Qua2V5cyh2YWx1ZSkucmV2ZXJzZSgpO1xuICAgICAgICB2YWx1ZS5fa2V5cyA9IGtleXM7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNvcnQ6IGZ1bmN0aW9uIHNvcnQodmFsdWUpIHtcbiAgICAgIGlmIChpcygnQXJyYXknLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnNvcnQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzKCdPYmplY3QnLCB2YWx1ZSkpIHtcbiAgICAgICAgLy8gU29ydGluZyBvYmplY3RzIGlzbid0IG9idmlvdXMgc2luY2UgdGhlIG9yZGVyIG9mXG4gICAgICAgIC8vIHJldHVybmVkIGtleXMgaXNuJ3QgZ3VhcmFudGVlZCBpbiBKYXZhU2NyaXB0LlxuICAgICAgICAvLyBCZWNhdXNlIG9mIHRoaXMgd2UgdXNlIGEgXCJoaWRkZW5cIiBrZXkgY2FsbGVkIF9rZXlzIHRvXG4gICAgICAgIC8vIHN0b3JlIHRoZSBrZXlzIGluIHRoZSBvcmRlciB3ZSB3YW50IHRvIHJldHVybiB0aGVtLlxuICAgICAgICBkZWxldGUgdmFsdWUuX2tleXM7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgICAgICB2YXIgc29ydGVkS2V5cyA9IGtleXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHZhciBhMTtcbiAgICAgICAgICB2YXIgYjE7IC8vIElmIGEgYW5kIGIgYXJlIGNvbXBhcmFibGUsIHdlJ3JlIGZpbmUgOi0pXG5cbiAgICAgICAgICBpZiAodmFsdWVbYV0gPiB2YWx1ZVtiXSA9PT0gISh2YWx1ZVthXSA8PSB2YWx1ZVtiXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVthXSA+IHZhbHVlW2JdID8gMSA6IHZhbHVlW2FdIDwgdmFsdWVbYl0gPyAtMSA6IDA7XG4gICAgICAgICAgfSAvLyBJZiBhIGFuZCBiIGNhbiBiZSBwYXJzZWQgYXMgbnVtYmVycywgd2UgY2FuIGNvbXBhcmVcbiAgICAgICAgICAvLyB0aGVpciBudW1lcmljIHZhbHVlXG5cblxuICAgICAgICAgIGlmICghaXNOYU4oYTEgPSBwYXJzZUZsb2F0KHZhbHVlW2FdKSkgJiYgIWlzTmFOKGIxID0gcGFyc2VGbG9hdCh2YWx1ZVtiXSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gYTEgPiBiMSA/IDEgOiBhMSA8IGIxID8gLTEgOiAwO1xuICAgICAgICAgIH0gLy8gSWYgb25lIG9mIHRoZSB2YWx1ZXMgaXMgYSBzdHJpbmcsIHdlIGNvbnZlcnQgdGhlXG4gICAgICAgICAgLy8gb3RoZXIgdmFsdWUgdG8gc3RyaW5nIGFzIHdlbGxcblxuXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZVthXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVthXSA+IHZhbHVlW2JdLnRvU3RyaW5nKCkgPyAxIDogdmFsdWVbYV0gPCB2YWx1ZVtiXS50b1N0cmluZygpID8gLTEgOiAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVbYl0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVbYV0udG9TdHJpbmcoKSA+IHZhbHVlW2JdID8gMSA6IHZhbHVlW2FdLnRvU3RyaW5nKCkgPCB2YWx1ZVtiXSA/IC0xIDogMDtcbiAgICAgICAgICB9IC8vIEV2ZXJ5dGhpbmcgZmFpbGVkIC0gcmV0dXJuICdudWxsJyBhcyBzaWduLCB0aGF0XG4gICAgICAgICAgLy8gdGhlIHZhbHVlcyBhcmUgbm90IGNvbXBhcmFibGVcblxuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICB2YWx1ZS5fa2V5cyA9IHNvcnRlZEtleXM7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGtleXM6IGZ1bmN0aW9uIGtleXModmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleXNldCA9IHZhbHVlLl9rZXlzIHx8IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIGtleXNldC5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ19rZXlzJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBJZ25vcmUgdGhlIF9rZXlzIHByb3BlcnR5XG5cblxuICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgICAgICBvdXRwdXQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSxcblxuICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2UgKi9cbiAgICB1cmxfZW5jb2RlOiBmdW5jdGlvbiB1cmxfZW5jb2RlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChUd2lnLmxpYi5pcygnT2JqZWN0JywgdmFsdWUpKSB7XG4gICAgICAgIHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUob2JqLCBwcmVmaXgpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgdmFyIGtleXNldCA9IG9iai5fa2V5cyB8fCBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICAgIGtleXNldC5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXN1bHRLZXkgPSBwcmVmaXggPyBwcmVmaXggKyAnWycgKyBrZXkgKyAnXScgOiBrZXk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0VmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFR3aWcubGliLmlzKCdPYmplY3QnLCByZXN1bHRWYWx1ZSkgfHwgQXJyYXkuaXNBcnJheShyZXN1bHRWYWx1ZSkgPyBzZXJpYWxpemUocmVzdWx0VmFsdWUsIHJlc3VsdEtleSkgOiBlbmNvZGVVUklDb21wb25lbnQocmVzdWx0S2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChyZXN1bHRWYWx1ZSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQuam9pbignJmFtcDsnKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2VyaWFsaXplKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgnXFwnJywgJyUyNycpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIGpvaW46IGZ1bmN0aW9uIGpvaW4odmFsdWUsIHBhcmFtcykge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgam9pblN0ciA9ICcnO1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgdmFyIGtleXNldCA9IG51bGw7XG5cbiAgICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zWzBdKSB7XG4gICAgICAgIGpvaW5TdHIgPSBwYXJhbXNbMF07XG4gICAgICB9XG5cbiAgICAgIGlmIChpcygnQXJyYXknLCB2YWx1ZSkpIHtcbiAgICAgICAgb3V0cHV0ID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzZXQgPSB2YWx1ZS5fa2V5cyB8fCBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICAgIGtleXNldC5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBpZiAoa2V5ID09PSAnX2tleXMnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSAvLyBJZ25vcmUgdGhlIF9rZXlzIHByb3BlcnR5XG5cblxuICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWVba2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dC5qb2luKGpvaW5TdHIpO1xuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uIF9kZWZhdWx0KHZhbHVlLCBwYXJhbXMpIHtcbiAgICAgIGlmIChwYXJhbXMgIT09IHVuZGVmaW5lZCAmJiBwYXJhbXMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcignZGVmYXVsdCBmaWx0ZXIgZXhwZWN0cyBvbmUgYXJndW1lbnQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgICAgIGlmIChwYXJhbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJhbXNbMF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbWVsY2FzZSAqL1xuICAgIGpzb25fZW5jb2RlOiBmdW5jdGlvbiBqc29uX2VuY29kZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgIH1cblxuICAgICAgaWYgKCgwLCBfdHlwZW9mMltcImRlZmF1bHRcIl0pKHZhbHVlKSA9PT0gJ29iamVjdCcgJiYgaXMoJ0FycmF5JywgdmFsdWUpKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgIG91dHB1dC5wdXNoKFR3aWcuZmlsdGVycy5qc29uX2VuY29kZSh2KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gJ1snICsgb3V0cHV0LmpvaW4oJywnKSArICddJztcbiAgICAgIH1cblxuICAgICAgaWYgKCgwLCBfdHlwZW9mMltcImRlZmF1bHRcIl0pKHZhbHVlKSA9PT0gJ29iamVjdCcgJiYgaXMoJ0RhdGUnLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICdcIicgKyB2YWx1ZS50b0lTT1N0cmluZygpICsgJ1wiJztcbiAgICAgIH1cblxuICAgICAgaWYgKCgwLCBfdHlwZW9mMltcImRlZmF1bHRcIl0pKHZhbHVlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFyIGtleXNldCA9IHZhbHVlLl9rZXlzIHx8IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAgdmFyIF9vdXRwdXQgPSBbXTtcbiAgICAgICAga2V5c2V0LmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIF9vdXRwdXQucHVzaChKU09OLnN0cmluZ2lmeShrZXkpICsgJzonICsgVHdpZy5maWx0ZXJzLmpzb25fZW5jb2RlKHZhbHVlW2tleV0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAneycgKyBfb3V0cHV0LmpvaW4oJywnKSArICd9JztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9LFxuICAgIG1lcmdlOiBmdW5jdGlvbiBtZXJnZSh2YWx1ZSwgcGFyYW1zKSB7XG4gICAgICB2YXIgb2JqID0gW107XG4gICAgICB2YXIgYXJySW5kZXggPSAwO1xuICAgICAgdmFyIGtleXNldCA9IFtdOyAvLyBDaGVjayB0byBzZWUgaWYgYWxsIHRoZSBvYmplY3RzIGJlaW5nIG1lcmdlZCBhcmUgYXJyYXlzXG5cbiAgICAgIGlmIChpcygnQXJyYXknLCB2YWx1ZSkpIHtcbiAgICAgICAgcGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgaWYgKCFpcygnQXJyYXknLCBwYXJhbSkpIHtcbiAgICAgICAgICAgIG9iaiA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDcmVhdGUgb2JqIGFzIGFuIE9iamVjdFxuICAgICAgICBvYmogPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpcygnQXJyYXknLCBvYmopKSB7XG4gICAgICAgIG9iai5fa2V5cyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXMoJ0FycmF5JywgdmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgIGlmIChvYmouX2tleXMpIHtcbiAgICAgICAgICAgIG9iai5fa2V5cy5wdXNoKGFyckluZGV4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvYmpbYXJySW5kZXhdID0gdmFsO1xuICAgICAgICAgIGFyckluZGV4Kys7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5c2V0ID0gdmFsdWUuX2tleXMgfHwgT2JqZWN0LmtleXModmFsdWUpO1xuICAgICAgICBrZXlzZXQuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZVtrZXldO1xuXG4gICAgICAgICAgb2JqLl9rZXlzLnB1c2goa2V5KTsgLy8gSGFuZGxlIGVkZ2UgY2FzZSB3aGVyZSBhIG51bWJlciBpbmRleCBpbiBhbiBvYmplY3QgaXMgZ3JlYXRlciB0aGFuXG4gICAgICAgICAgLy8gICB0aGUgYXJyYXkgY291bnRlci4gSW4gc3VjaCBhIGNhc2UsIHRoZSBhcnJheSBjb3VudGVyIGlzIGluY3JlYXNlZFxuICAgICAgICAgIC8vICAgb25lIHBhc3QgdGhlIGluZGV4LlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gRXhhbXBsZSB7eyBbXCJhXCIsIFwiYlwiXXxtZXJnZSh7XCI0XCI6XCJ2YWx1ZVwifSwgW1wiY1wiLCBcImRcIl0pXG4gICAgICAgICAgLy8gV2l0aG91dCB0aGlzLCBkIHdvdWxkIGhhdmUgYW4gaW5kZXggb2YgXCI0XCIgYW5kIG92ZXJ3cml0ZSB0aGUgdmFsdWVcbiAgICAgICAgICAvLyAgIG9mIFwidmFsdWVcIlxuXG5cbiAgICAgICAgICB2YXIgaW50S2V5ID0gcGFyc2VJbnQoa2V5LCAxMCk7XG5cbiAgICAgICAgICBpZiAoIWlzTmFOKGludEtleSkgJiYgaW50S2V5ID49IGFyckluZGV4KSB7XG4gICAgICAgICAgICBhcnJJbmRleCA9IGludEtleSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gLy8gTWl4aW4gdGhlIG1lcmdlIGFycmF5c1xuXG5cbiAgICAgIHBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICBpZiAoaXMoJ0FycmF5JywgcGFyYW0pKSB7XG4gICAgICAgICAgcGFyYW0uZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBpZiAob2JqLl9rZXlzKSB7XG4gICAgICAgICAgICAgIG9iai5fa2V5cy5wdXNoKGFyckluZGV4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqW2FyckluZGV4XSA9IHZhbDtcbiAgICAgICAgICAgIGFyckluZGV4Kys7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2V5c2V0ID0gcGFyYW0uX2tleXMgfHwgT2JqZWN0LmtleXMocGFyYW0pO1xuICAgICAgICAgIGtleXNldC5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICghb2JqW2tleV0pIHtcbiAgICAgICAgICAgICAgb2JqLl9rZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqW2tleV0gPSBwYXJhbVtrZXldO1xuICAgICAgICAgICAgdmFyIGludEtleSA9IHBhcnNlSW50KGtleSwgMTApO1xuXG4gICAgICAgICAgICBpZiAoIWlzTmFOKGludEtleSkgJiYgaW50S2V5ID49IGFyckluZGV4KSB7XG4gICAgICAgICAgICAgIGFyckluZGV4ID0gaW50S2V5ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKCdGaWx0ZXIgbWVyZ2UgZXhwZWN0cyBhdCBsZWFzdCBvbmUgcGFyYW1ldGVyJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBkYXRlOiBmdW5jdGlvbiBkYXRlKHZhbHVlLCBwYXJhbXMpIHtcbiAgICAgIHZhciBkYXRlID0gVHdpZy5mdW5jdGlvbnMuZGF0ZSh2YWx1ZSk7XG4gICAgICB2YXIgZm9ybWF0ID0gcGFyYW1zICYmIEJvb2xlYW4ocGFyYW1zLmxlbmd0aCkgPyBwYXJhbXNbMF0gOiAnRiBqLCBZIEg6aSc7XG4gICAgICByZXR1cm4gVHdpZy5saWIuZGF0ZShmb3JtYXQucmVwbGFjZSgvXFxcXFxcXFwvZywgJ1xcXFwnKSwgZGF0ZSk7XG4gICAgfSxcblxuICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2UgKi9cbiAgICBkYXRlX21vZGlmeTogZnVuY3Rpb24gZGF0ZV9tb2RpZnkodmFsdWUsIHBhcmFtcykge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQgfHwgcGFyYW1zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcignZGF0ZV9tb2RpZnkgZmlsdGVyIGV4cGVjdHMgMSBhcmd1bWVudCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbW9kaWZ5VGV4dCA9IHBhcmFtc1swXTtcbiAgICAgIHZhciB0aW1lO1xuXG4gICAgICBpZiAoVHdpZy5saWIuaXMoJ0RhdGUnLCB2YWx1ZSkpIHtcbiAgICAgICAgdGltZSA9IFR3aWcubGliLnN0cnRvdGltZShtb2RpZnlUZXh0LCB2YWx1ZS5nZXRUaW1lKCkgLyAxMDAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFR3aWcubGliLmlzKCdTdHJpbmcnLCB2YWx1ZSkpIHtcbiAgICAgICAgdGltZSA9IFR3aWcubGliLnN0cnRvdGltZShtb2RpZnlUZXh0LCBUd2lnLmxpYi5zdHJ0b3RpbWUodmFsdWUpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFR3aWcubGliLmlzKCdOdW1iZXInLCB2YWx1ZSkpIHtcbiAgICAgICAgdGltZSA9IFR3aWcubGliLnN0cnRvdGltZShtb2RpZnlUZXh0LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgRGF0ZSh0aW1lICogMTAwMCk7XG4gICAgfSxcbiAgICByZXBsYWNlOiBmdW5jdGlvbiByZXBsYWNlKHZhbHVlLCBwYXJhbXMpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhaXJzID0gcGFyYW1zWzBdO1xuICAgICAgdmFyIHRhZztcblxuICAgICAgZm9yICh0YWcgaW4gcGFpcnMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhaXJzLCB0YWcpICYmIHRhZyAhPT0gJ19rZXlzJykge1xuICAgICAgICAgIHZhbHVlID0gVHdpZy5saWIucmVwbGFjZUFsbCh2YWx1ZSwgdGFnLCBwYWlyc1t0YWddKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBmb3JtYXQ6IGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSwgcGFyYW1zKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBUd2lnLmxpYi52c3ByaW50Zih2YWx1ZSwgcGFyYW1zKTtcbiAgICB9LFxuICAgIHN0cmlwdGFnczogZnVuY3Rpb24gc3RyaXB0YWdzKHZhbHVlLCBhbGxvd2VkKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBUd2lnLmxpYi5zdHJpcFRhZ3ModmFsdWUsIGFsbG93ZWQpO1xuICAgIH0sXG4gICAgZXNjYXBlOiBmdW5jdGlvbiBlc2NhcGUodmFsdWUsIHBhcmFtcykge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0cmF0ZWd5ID0gJ2h0bWwnO1xuXG4gICAgICBpZiAocGFyYW1zICYmIEJvb2xlYW4ocGFyYW1zLmxlbmd0aCkgJiYgcGFyYW1zWzBdICE9PSB0cnVlKSB7XG4gICAgICAgIHN0cmF0ZWd5ID0gcGFyYW1zWzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RyYXRlZ3kgPT09ICdodG1sJykge1xuICAgICAgICB2YXIgcmF3VmFsdWUgPSB2YWx1ZS50b1N0cmluZygpLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JykucmVwbGFjZSgvJy9nLCAnJiMwMzk7Jyk7XG4gICAgICAgIHJldHVybiBuZXcgVHdpZy5NYXJrdXAocmF3VmFsdWUsICdodG1sJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJhdGVneSA9PT0gJ2pzJykge1xuICAgICAgICB2YXIgX3Jhd1ZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfcmF3VmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoX3Jhd1ZhbHVlW2ldLm1hdGNoKC9eW2EtekEtWjAtOSwuX10kLykpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBfcmF3VmFsdWVbaV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfY2hhciA9IF9yYXdWYWx1ZS5jaGFyQXQoaSk7XG5cbiAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IF9yYXdWYWx1ZS5jaGFyQ29kZUF0KGkpOyAvLyBBIGZldyBjaGFyYWN0ZXJzIGhhdmUgc2hvcnQgZXNjYXBlIHNlcXVlbmNlcyBpbiBKU09OIGFuZCBKYXZhU2NyaXB0LlxuICAgICAgICAgICAgLy8gRXNjYXBlIHNlcXVlbmNlcyBzdXBwb3J0ZWQgb25seSBieSBKYXZhU2NyaXB0LCBub3QgSlNPTiwgYXJlIG9tbWl0dGVkLlxuICAgICAgICAgICAgLy8gXFxcIiBpcyBhbHNvIHN1cHBvcnRlZCBidXQgb21pdHRlZCwgYmVjYXVzZSB0aGUgcmVzdWx0aW5nIHN0cmluZyBpcyBub3QgSFRNTCBzYWZlLlxuXG5cbiAgICAgICAgICAgIHZhciBzaG9ydE1hcCA9IHtcbiAgICAgICAgICAgICAgJ1xcXFwnOiAnXFxcXFxcXFwnLFxuICAgICAgICAgICAgICAnLyc6ICdcXFxcLycsXG4gICAgICAgICAgICAgIFwiXFxiXCI6ICdcXFxcYicsXG4gICAgICAgICAgICAgIFwiXFxmXCI6ICdcXFxcZicsXG4gICAgICAgICAgICAgIFwiXFxuXCI6ICdcXFxcbicsXG4gICAgICAgICAgICAgIFwiXFxyXCI6ICdcXFxccicsXG4gICAgICAgICAgICAgIFwiXFx0XCI6ICdcXFxcdCdcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChzaG9ydE1hcFtfY2hhcl0pIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IHNob3J0TWFwW19jaGFyXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBUd2lnLmxpYi5zcHJpbnRmKFwiXFxcXHUlMDRzXCIsIGNoYXJDb2RlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFR3aWcuTWFya3VwKHJlc3VsdCwgJ2pzJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJhdGVneSA9PT0gJ2NzcycpIHtcbiAgICAgICAgdmFyIF9yYXdWYWx1ZTIgPSB2YWx1ZS50b1N0cmluZygpO1xuXG4gICAgICAgIHZhciBfcmVzdWx0ID0gJyc7XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IF9yYXdWYWx1ZTIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgaWYgKF9yYXdWYWx1ZTJbX2ldLm1hdGNoKC9eW2EtekEtWjAtOV0kLykpIHtcbiAgICAgICAgICAgIF9yZXN1bHQgKz0gX3Jhd1ZhbHVlMltfaV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfY2hhckNvZGUgPSBfcmF3VmFsdWUyLmNoYXJDb2RlQXQoX2kpO1xuXG4gICAgICAgICAgICBfcmVzdWx0ICs9ICdcXFxcJyArIF9jaGFyQ29kZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArICcgJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFR3aWcuTWFya3VwKF9yZXN1bHQsICdjc3MnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cmF0ZWd5ID09PSAndXJsJykge1xuICAgICAgICB2YXIgX3Jlc3VsdDIgPSBUd2lnLmZpbHRlcnMudXJsX2VuY29kZSh2YWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUd2lnLk1hcmt1cChfcmVzdWx0MiwgJ3VybCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RyYXRlZ3kgPT09ICdodG1sX2F0dHInKSB7XG4gICAgICAgIHZhciBfcmF3VmFsdWUzID0gdmFsdWUudG9TdHJpbmcoKTtcblxuICAgICAgICB2YXIgX3Jlc3VsdDMgPSAnJztcblxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBfcmF3VmFsdWUzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICBpZiAoX3Jhd1ZhbHVlM1tfaTJdLm1hdGNoKC9eW2EtekEtWjAtOSwuXFwtX10kLykpIHtcbiAgICAgICAgICAgIF9yZXN1bHQzICs9IF9yYXdWYWx1ZTNbX2kyXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKF9yYXdWYWx1ZTNbX2kyXS5tYXRjaCgvXlsmPD5cIl0kLykpIHtcbiAgICAgICAgICAgIF9yZXN1bHQzICs9IF9yYXdWYWx1ZTNbX2kyXS5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7JykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgX2NoYXJDb2RlMiA9IF9yYXdWYWx1ZTMuY2hhckNvZGVBdChfaTIpOyAvLyBUaGUgZm9sbG93aW5nIHJlcGxhY2VzIGNoYXJhY3RlcnMgdW5kZWZpbmVkIGluIEhUTUwgd2l0aFxuICAgICAgICAgICAgLy8gdGhlIGhleCBlbnRpdHkgZm9yIHRoZSBVbmljb2RlIHJlcGxhY2VtZW50IGNoYXJhY3Rlci5cblxuXG4gICAgICAgICAgICBpZiAoX2NoYXJDb2RlMiA8PSAweDFGICYmIF9jaGFyQ29kZTIgIT09IDB4MDkgJiYgX2NoYXJDb2RlMiAhPT0gMHgwQSAmJiBfY2hhckNvZGUyICE9PSAweDBEKSB7XG4gICAgICAgICAgICAgIF9yZXN1bHQzICs9ICcmI3hGRkZEOyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF9jaGFyQ29kZTIgPCAweDgwKSB7XG4gICAgICAgICAgICAgIF9yZXN1bHQzICs9IFR3aWcubGliLnNwcmludGYoJyYjeCUwMnM7JywgX2NoYXJDb2RlMi50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfcmVzdWx0MyArPSBUd2lnLmxpYi5zcHJpbnRmKCcmI3glMDRzOycsIF9jaGFyQ29kZTIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVHdpZy5NYXJrdXAoX3Jlc3VsdDMsICdodG1sX2F0dHInKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoJ2VzY2FwZSBzdHJhdGVneSB1bnN1cHBvcnRlZCcpO1xuICAgIH0sXG5cbiAgICAvKiBBbGlhcyBvZiBlc2NhcGUgKi9cbiAgICBlOiBmdW5jdGlvbiBlKHZhbHVlLCBwYXJhbXMpIHtcbiAgICAgIHJldHVybiBUd2lnLmZpbHRlcnMuZXNjYXBlKHZhbHVlLCBwYXJhbXMpO1xuICAgIH0sXG4gICAgbmwyYnI6IGZ1bmN0aW9uIG5sMmJyKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGluZWJyZWFrVGFnID0gJ0JBQ0tTTEFTSF9uX3JlcGxhY2UnO1xuICAgICAgdmFyIGJyID0gJzxiciAvPicgKyBsaW5lYnJlYWtUYWc7XG4gICAgICB2YWx1ZSA9IFR3aWcuZmlsdGVycy5lc2NhcGUodmFsdWUpLnJlcGxhY2UoL1xcclxcbi9nLCBicikucmVwbGFjZSgvXFxyL2csIGJyKS5yZXBsYWNlKC9cXG4vZywgYnIpO1xuICAgICAgdmFsdWUgPSBUd2lnLmxpYi5yZXBsYWNlQWxsKHZhbHVlLCBsaW5lYnJlYWtUYWcsICdcXG4nKTtcbiAgICAgIHJldHVybiBuZXcgVHdpZy5NYXJrdXAodmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGFwdGVkIGZyb206IGh0dHA6Ly9waHBqcy5vcmcvZnVuY3Rpb25zL251bWJlcl9mb3JtYXQ6NDgxXG4gICAgICovXG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlICovXG4gICAgbnVtYmVyX2Zvcm1hdDogZnVuY3Rpb24gbnVtYmVyX2Zvcm1hdCh2YWx1ZSwgcGFyYW1zKSB7XG4gICAgICB2YXIgbnVtYmVyID0gdmFsdWU7XG4gICAgICB2YXIgZGVjaW1hbHMgPSBwYXJhbXMgJiYgcGFyYW1zWzBdID8gcGFyYW1zWzBdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGRlYyA9IHBhcmFtcyAmJiBwYXJhbXNbMV0gIT09IHVuZGVmaW5lZCA/IHBhcmFtc1sxXSA6ICcuJztcbiAgICAgIHZhciBzZXAgPSBwYXJhbXMgJiYgcGFyYW1zWzJdICE9PSB1bmRlZmluZWQgPyBwYXJhbXNbMl0gOiAnLCc7XG4gICAgICBudW1iZXIgPSBTdHJpbmcobnVtYmVyKS5yZXBsYWNlKC9bXjAtOStcXC1FZS5dL2csICcnKTtcbiAgICAgIHZhciBuID0gaXNGaW5pdGUoTnVtYmVyKG51bWJlcikpID8gTnVtYmVyKG51bWJlcikgOiAwO1xuICAgICAgdmFyIHByZWMgPSBpc0Zpbml0ZShOdW1iZXIoZGVjaW1hbHMpKSA/IE1hdGguYWJzKGRlY2ltYWxzKSA6IDA7XG4gICAgICB2YXIgcyA9ICcnO1xuXG4gICAgICB2YXIgdG9GaXhlZEZpeCA9IGZ1bmN0aW9uIHRvRml4ZWRGaXgobiwgcHJlYykge1xuICAgICAgICB2YXIgayA9IE1hdGgucG93KDEwLCBwcmVjKTtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhNYXRoLnJvdW5kKG4gKiBrKSAvIGspO1xuICAgICAgfTsgLy8gRml4IGZvciBJRSBwYXJzZUZsb2F0KDAuNTUpLnRvRml4ZWQoMCkgPSAwO1xuXG5cbiAgICAgIHMgPSAocHJlYyA/IHRvRml4ZWRGaXgobiwgcHJlYykgOiBTdHJpbmcoTWF0aC5yb3VuZChuKSkpLnNwbGl0KCcuJyk7XG5cbiAgICAgIGlmIChzWzBdLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgc1swXSA9IHNbMF0ucmVwbGFjZSgvXFxCKD89KD86XFxkezN9KSsoPyFcXGQpKS9nLCBzZXApO1xuICAgICAgfVxuXG4gICAgICBpZiAoKHNbMV0gfHwgJycpLmxlbmd0aCA8IHByZWMpIHtcbiAgICAgICAgc1sxXSA9IHNbMV0gfHwgJyc7XG4gICAgICAgIHNbMV0gKz0gbmV3IEFycmF5KHByZWMgLSBzWzFdLmxlbmd0aCArIDEpLmpvaW4oJzAnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMuam9pbihkZWMpO1xuICAgIH0sXG4gICAgdHJpbTogZnVuY3Rpb24gdHJpbSh2YWx1ZSwgcGFyYW1zKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzdHIgPSBTdHJpbmcodmFsdWUpO1xuICAgICAgdmFyIHdoaXRlc3BhY2U7XG5cbiAgICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zWzBdKSB7XG4gICAgICAgIHdoaXRlc3BhY2UgPSBTdHJpbmcocGFyYW1zWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaXRlc3BhY2UgPSBcIiBcXG5cXHJcXHRcXGZcXHgwQlxceEEwXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDBCXFx1MjAyOFxcdTIwMjlcXHUzMDAwXCI7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghd2hpdGVzcGFjZS5pbmNsdWRlcyhzdHIuY2hhckF0KGkpKSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zbGljZShNYXRoLm1heCgwLCBpKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2kzID0gc3RyLmxlbmd0aCAtIDE7IF9pMyA+PSAwOyBfaTMtLSkge1xuICAgICAgICBpZiAoIXdoaXRlc3BhY2UuaW5jbHVkZXMoc3RyLmNoYXJBdChfaTMpKSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCBNYXRoLm1heCgwLCBfaTMgKyAxKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHdoaXRlc3BhY2UuaW5jbHVkZXMoc3RyLmNoYXJBdCgwKSkgPyAnJyA6IHN0cjtcbiAgICB9LFxuICAgIHRydW5jYXRlOiBmdW5jdGlvbiB0cnVuY2F0ZSh2YWx1ZSwgcGFyYW1zKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gMzA7XG4gICAgICB2YXIgcHJlc2VydmUgPSBmYWxzZTtcbiAgICAgIHZhciBzZXBhcmF0b3IgPSAnLi4uJztcbiAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcblxuICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zWzBdKSB7XG4gICAgICAgICAgbGVuZ3RoID0gcGFyYW1zWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtc1sxXSkge1xuICAgICAgICAgIHByZXNlcnZlID0gcGFyYW1zWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtc1syXSkge1xuICAgICAgICAgIHNlcGFyYXRvciA9IHBhcmFtc1syXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUubGVuZ3RoID4gbGVuZ3RoKSB7XG4gICAgICAgIGlmIChwcmVzZXJ2ZSkge1xuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmluZGV4T2YoJyAnLCBsZW5ndGgpO1xuXG4gICAgICAgICAgaWYgKGxlbmd0aCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIGxlbmd0aCkgKyBzZXBhcmF0b3I7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHNsaWNlOiBmdW5jdGlvbiBzbGljZSh2YWx1ZSwgcGFyYW1zKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMgPT09IHVuZGVmaW5lZCB8fCBwYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKCdzbGljZSBmaWx0ZXIgZXhwZWN0cyBhdCBsZWFzdCAxIGFyZ3VtZW50Jyk7XG4gICAgICB9IC8vIERlZmF1bHQgdG8gc3RhcnQgb2Ygc3RyaW5nXG5cblxuICAgICAgdmFyIHN0YXJ0ID0gcGFyYW1zWzBdIHx8IDA7IC8vIERlZmF1bHQgdG8gbGVuZ3RoIG9mIHN0cmluZ1xuXG4gICAgICB2YXIgbGVuZ3RoID0gcGFyYW1zLmxlbmd0aCA+IDEgPyBwYXJhbXNbMV0gOiB2YWx1ZS5sZW5ndGg7IC8vIEhhbmRsZSBuZWdhdGl2ZSBzdGFydCB2YWx1ZXNcblxuICAgICAgdmFyIHN0YXJ0SW5kZXggPSBzdGFydCA+PSAwID8gc3RhcnQgOiBNYXRoLm1heCh2YWx1ZS5sZW5ndGggKyBzdGFydCwgMCk7XG5cbiAgICAgIGlmIChUd2lnLmxpYi5pcygnQXJyYXknLCB2YWx1ZSkpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgc3RhcnRJbmRleCArIGxlbmd0aCAmJiBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZVtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgfVxuXG4gICAgICBpZiAoVHdpZy5saWIuaXMoJ1N0cmluZycsIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2Uoc3RhcnRJbmRleCwgc3RhcnRJbmRleCArIGxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKCdzbGljZSBmaWx0ZXIgZXhwZWN0cyB2YWx1ZSB0byBiZSBhbiBhcnJheSBvciBzdHJpbmcnKTtcbiAgICB9LFxuICAgIGFiczogZnVuY3Rpb24gYWJzKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBNYXRoLmFicyh2YWx1ZSk7XG4gICAgfSxcbiAgICBmaXJzdDogZnVuY3Rpb24gZmlyc3QodmFsdWUpIHtcbiAgICAgIGlmIChpcygnQXJyYXknLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlWzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXMoJ09iamVjdCcsIHZhbHVlKSkge1xuICAgICAgICBpZiAoJ19rZXlzJyBpbiB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZVt2YWx1ZS5fa2V5c1swXV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMCwgMSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzcGxpdDogZnVuY3Rpb24gc3BsaXQodmFsdWUsIHBhcmFtcykge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQgfHwgcGFyYW1zLmxlbmd0aCA9PT0gMCB8fCBwYXJhbXMubGVuZ3RoID4gMikge1xuICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcignc3BsaXQgZmlsdGVyIGV4cGVjdHMgMSBvciAyIGFyZ3VtZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChUd2lnLmxpYi5pcygnU3RyaW5nJywgdmFsdWUpKSB7XG4gICAgICAgIHZhciBkZWxpbWl0ZXIgPSBwYXJhbXNbMF07XG4gICAgICAgIHZhciBsaW1pdCA9IHBhcmFtc1sxXTtcbiAgICAgICAgdmFyIHNwbGl0ID0gdmFsdWUuc3BsaXQoZGVsaW1pdGVyKTtcblxuICAgICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBzcGxpdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW1pdCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUuc3BsaXQoZGVsaW1pdGVyLCBzcGxpdC5sZW5ndGggKyBsaW1pdCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGltaXRlZFNwbGl0ID0gW107XG5cbiAgICAgICAgaWYgKGRlbGltaXRlciA9PT0gJycpIHtcbiAgICAgICAgICAvLyBFbXB0eSBkZWxpbWl0ZXJcbiAgICAgICAgICAvLyBcImFhYmJjY1wifHNwbGl0KCcnLCAyKVxuICAgICAgICAgIC8vICAgICAtPiBbJ2FhJywgJ2JiJywgJ2NjJ11cbiAgICAgICAgICB3aGlsZSAoc3BsaXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHRlbXAgPSAnJztcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW1pdCAmJiBzcGxpdC5sZW5ndGggPiAwOyBpKyspIHtcbiAgICAgICAgICAgICAgdGVtcCArPSBzcGxpdC5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaW1pdGVkU3BsaXQucHVzaCh0ZW1wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm9uLWVtcHR5IGRlbGltaXRlclxuICAgICAgICAgIC8vIFwib25lLHR3byx0aHJlZSxmb3VyLGZpdmVcInxzcGxpdCgnLCcsIDMpXG4gICAgICAgICAgLy8gICAgIC0+IFsnb25lJywgJ3R3bycsICd0aHJlZSxmb3VyLGZpdmUnXVxuICAgICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGxpbWl0IC0gMSAmJiBzcGxpdC5sZW5ndGggPiAwOyBfaTQrKykge1xuICAgICAgICAgICAgbGltaXRlZFNwbGl0LnB1c2goc3BsaXQuc2hpZnQoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNwbGl0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxpbWl0ZWRTcGxpdC5wdXNoKHNwbGl0LmpvaW4oZGVsaW1pdGVyKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpbWl0ZWRTcGxpdDtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoJ3NwbGl0IGZpbHRlciBleHBlY3RzIHZhbHVlIHRvIGJlIGEgc3RyaW5nJyk7XG4gICAgfSxcbiAgICBsYXN0OiBmdW5jdGlvbiBsYXN0KHZhbHVlKSB7XG4gICAgICBpZiAoVHdpZy5saWIuaXMoJ09iamVjdCcsIHZhbHVlKSkge1xuICAgICAgICB2YXIga2V5cztcblxuICAgICAgICBpZiAodmFsdWUuX2tleXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2V5cyA9IHZhbHVlLl9rZXlzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlW2tleXNba2V5cy5sZW5ndGggLSAxXV07XG4gICAgICB9XG5cbiAgICAgIGlmIChUd2lnLmxpYi5pcygnTnVtYmVyJywgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpLnNsaWNlKC0xKTtcbiAgICAgIH0gLy8gU3RyaW5nfGFycmF5XG5cblxuICAgICAgcmV0dXJuIHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdO1xuICAgIH0sXG4gICAgcmF3OiBmdW5jdGlvbiByYXcodmFsdWUpIHtcbiAgICAgIHJldHVybiBuZXcgVHdpZy5NYXJrdXAodmFsdWUgfHwgJycpO1xuICAgIH0sXG4gICAgYmF0Y2g6IGZ1bmN0aW9uIGJhdGNoKGl0ZW1zLCBwYXJhbXMpIHtcbiAgICAgIHZhciBzaXplID0gcGFyYW1zLnNoaWZ0KCk7XG4gICAgICB2YXIgZmlsbCA9IHBhcmFtcy5zaGlmdCgpO1xuICAgICAgdmFyIGxhc3Q7XG4gICAgICB2YXIgbWlzc2luZztcblxuICAgICAgaWYgKCFUd2lnLmxpYi5pcygnQXJyYXknLCBpdGVtcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoJ2JhdGNoIGZpbHRlciBleHBlY3RzIGl0ZW1zIHRvIGJlIGFuIGFycmF5Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghVHdpZy5saWIuaXMoJ051bWJlcicsIHNpemUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKCdiYXRjaCBmaWx0ZXIgZXhwZWN0cyBzaXplIHRvIGJlIGEgbnVtYmVyJyk7XG4gICAgICB9XG5cbiAgICAgIHNpemUgPSBNYXRoLmNlaWwoc2l6ZSk7XG4gICAgICB2YXIgcmVzdWx0ID0gVHdpZy5saWIuY2h1bmtBcnJheShpdGVtcywgc2l6ZSk7XG5cbiAgICAgIGlmIChmaWxsICYmIGl0ZW1zLmxlbmd0aCAlIHNpemUgIT09IDApIHtcbiAgICAgICAgbGFzdCA9IHJlc3VsdC5wb3AoKTtcbiAgICAgICAgbWlzc2luZyA9IHNpemUgLSBsYXN0Lmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAobWlzc2luZy0tKSB7XG4gICAgICAgICAgbGFzdC5wdXNoKGZpbGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2gobGFzdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICByb3VuZDogZnVuY3Rpb24gcm91bmQodmFsdWUsIHBhcmFtcykge1xuICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IFtdO1xuICAgICAgdmFyIHByZWNpc2lvbiA9IHBhcmFtcy5sZW5ndGggPiAwID8gcGFyYW1zWzBdIDogMDtcbiAgICAgIHZhciBtZXRob2QgPSBwYXJhbXMubGVuZ3RoID4gMSA/IHBhcmFtc1sxXSA6ICdjb21tb24nO1xuICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcblxuICAgICAgaWYgKHByZWNpc2lvbiAmJiAhVHdpZy5saWIuaXMoJ051bWJlcicsIHByZWNpc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoJ3JvdW5kIGZpbHRlciBleHBlY3RzIHByZWNpc2lvbiB0byBiZSBhIG51bWJlcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAobWV0aG9kID09PSAnY29tbW9uJykge1xuICAgICAgICByZXR1cm4gVHdpZy5saWIucm91bmQodmFsdWUsIHByZWNpc2lvbik7XG4gICAgICB9XG5cbiAgICAgIGlmICghVHdpZy5saWIuaXMoJ0Z1bmN0aW9uJywgTWF0aFttZXRob2RdKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcigncm91bmQgZmlsdGVyIGV4cGVjdHMgbWV0aG9kIHRvIGJlIFxcJ2Zsb29yXFwnLCBcXCdjZWlsXFwnLCBvciBcXCdjb21tb25cXCcnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE1hdGhbbWV0aG9kXSh2YWx1ZSAqIE1hdGgucG93KDEwLCBwcmVjaXNpb24pKSAvIE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICAgIH0sXG4gICAgc3BhY2VsZXNzOiBmdW5jdGlvbiBzcGFjZWxlc3ModmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC8+XFxzKzwvZywgJz48JykudHJpbSgpO1xuICAgIH1cbiAgfTtcblxuICBUd2lnLmZpbHRlciA9IGZ1bmN0aW9uIChmaWx0ZXIsIHZhbHVlLCBwYXJhbXMpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzO1xuXG4gICAgaWYgKCFUd2lnLmZpbHRlcnNbZmlsdGVyXSkge1xuICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoJ1VuYWJsZSB0byBmaW5kIGZpbHRlciAnICsgZmlsdGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gVHdpZy5maWx0ZXJzW2ZpbHRlcl0uY2FsbChzdGF0ZSwgdmFsdWUsIHBhcmFtcyk7XG4gIH07XG5cbiAgVHdpZy5maWx0ZXIuZXh0ZW5kID0gZnVuY3Rpb24gKGZpbHRlciwgZGVmaW5pdGlvbikge1xuICAgIFR3aWcuZmlsdGVyc1tmaWx0ZXJdID0gZGVmaW5pdGlvbjtcbiAgfTtcblxuICByZXR1cm4gVHdpZztcbn07XG5cbi8qKiovIH0pLFxuLyogMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xuXG4vLyAjIyB0d2lnLmZ1bmN0aW9ucy5qc1xuLy9cbi8vIFRoaXMgZmlsZSBoYW5kbGVzIHBhcnNpbmcgZmlsdGVycy5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFR3aWcpIHtcbiAgLyoqXG4gICAqIEBjb25zdGFudFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdmFyIFRFTVBMQVRFX05PVF9GT1VORF9NRVNTQUdFID0gJ1RlbXBsYXRlIFwie25hbWV9XCIgaXMgbm90IGRlZmluZWQuJztcbiAgVHdpZy5mdW5jdGlvbnMgPSB7XG4gICAgLy8gIEF0dHJpYnV0ZSwgYmxvY2ssIGNvbnN0YW50LCBkYXRlLCBkdW1wLCBwYXJlbnQsIHJhbmRvbSwuXG4gICAgLy8gUmFuZ2UgZnVuY3Rpb24gZnJvbSBodHRwOi8vcGhwanMub3JnL2Z1bmN0aW9ucy9yYW5nZTo0OTlcbiAgICAvLyBVc2VkIHVuZGVyIGFuIE1JVCBMaWNlbnNlXG4gICAgcmFuZ2U6IGZ1bmN0aW9uIHJhbmdlKGxvdywgaGlnaCwgc3RlcCkge1xuICAgICAgLy8gaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXRcbiAgICAgIC8vICsgICBvcmlnaW5hbCBieTogV2FsZG8gTWFscXVpIFNpbHZhXG4gICAgICAvLyAqICAgICBleGFtcGxlIDE6IHJhbmdlICggMCwgMTIgKTtcbiAgICAgIC8vICogICAgIHJldHVybnMgMTogWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTJdXG4gICAgICAvLyAqICAgICBleGFtcGxlIDI6IHJhbmdlKCAwLCAxMDAsIDEwICk7XG4gICAgICAvLyAqICAgICByZXR1cm5zIDI6IFswLCAxMCwgMjAsIDMwLCA0MCwgNTAsIDYwLCA3MCwgODAsIDkwLCAxMDBdXG4gICAgICAvLyAqICAgICBleGFtcGxlIDM6IHJhbmdlKCAnYScsICdpJyApO1xuICAgICAgLy8gKiAgICAgcmV0dXJucyAzOiBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCcsICdpJ11cbiAgICAgIC8vICogICAgIGV4YW1wbGUgNDogcmFuZ2UoICdjJywgJ2EnICk7XG4gICAgICAvLyAqICAgICByZXR1cm5zIDQ6IFsnYycsICdiJywgJ2EnXVxuICAgICAgdmFyIG1hdHJpeCA9IFtdO1xuICAgICAgdmFyIGluaXZhbDtcbiAgICAgIHZhciBlbmR2YWw7XG4gICAgICB2YXIgd2Fsa2VyID0gc3RlcCB8fCAxO1xuICAgICAgdmFyIGNoYXJzID0gZmFsc2U7XG5cbiAgICAgIGlmICghaXNOYU4obG93KSAmJiAhaXNOYU4oaGlnaCkpIHtcbiAgICAgICAgaW5pdmFsID0gcGFyc2VJbnQobG93LCAxMCk7XG4gICAgICAgIGVuZHZhbCA9IHBhcnNlSW50KGhpZ2gsIDEwKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNOYU4obG93KSAmJiBpc05hTihoaWdoKSkge1xuICAgICAgICBjaGFycyA9IHRydWU7XG4gICAgICAgIGluaXZhbCA9IGxvdy5jaGFyQ29kZUF0KDApO1xuICAgICAgICBlbmR2YWwgPSBoaWdoLmNoYXJDb2RlQXQoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml2YWwgPSBpc05hTihsb3cpID8gMCA6IGxvdztcbiAgICAgICAgZW5kdmFsID0gaXNOYU4oaGlnaCkgPyAwIDogaGlnaDtcbiAgICAgIH1cblxuICAgICAgdmFyIHBsdXMgPSAhKGluaXZhbCA+IGVuZHZhbCk7XG5cbiAgICAgIGlmIChwbHVzKSB7XG4gICAgICAgIHdoaWxlIChpbml2YWwgPD0gZW5kdmFsKSB7XG4gICAgICAgICAgbWF0cml4LnB1c2goY2hhcnMgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGluaXZhbCkgOiBpbml2YWwpO1xuICAgICAgICAgIGluaXZhbCArPSB3YWxrZXI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlIChpbml2YWwgPj0gZW5kdmFsKSB7XG4gICAgICAgICAgbWF0cml4LnB1c2goY2hhcnMgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGluaXZhbCkgOiBpbml2YWwpO1xuICAgICAgICAgIGluaXZhbCAtPSB3YWxrZXI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9LFxuICAgIGN5Y2xlOiBmdW5jdGlvbiBjeWNsZShhcnIsIGkpIHtcbiAgICAgIHZhciBwb3MgPSBpICUgYXJyLmxlbmd0aDtcbiAgICAgIHJldHVybiBhcnJbcG9zXTtcbiAgICB9LFxuICAgIGR1bXA6IGZ1bmN0aW9uIGR1bXAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgLy8gRG9uJ3QgcGFzcyBhcmd1bWVudHMgdG8gYEFycmF5LnNsaWNlYCwgdGhhdCBpcyBhIHBlcmZvcm1hbmNlIGtpbGxlclxuICAgICAgdmFyIGFyZ3NDb3B5ID0gW10uY29uY2F0KGFyZ3MpO1xuICAgICAgdmFyIHN0YXRlID0gdGhpcztcbiAgICAgIHZhciBFT0wgPSAnXFxuJztcbiAgICAgIHZhciBpbmRlbnRDaGFyID0gJyAgJztcbiAgICAgIHZhciBpbmRlbnRUaW1lcyA9IDA7XG4gICAgICB2YXIgb3V0ID0gJyc7XG5cbiAgICAgIHZhciBpbmRlbnQgPSBmdW5jdGlvbiBpbmRlbnQodGltZXMpIHtcbiAgICAgICAgdmFyIGluZCA9ICcnO1xuXG4gICAgICAgIHdoaWxlICh0aW1lcyA+IDApIHtcbiAgICAgICAgICB0aW1lcy0tO1xuICAgICAgICAgIGluZCArPSBpbmRlbnRDaGFyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZDtcbiAgICAgIH07XG5cbiAgICAgIHZhciBkaXNwbGF5VmFyID0gZnVuY3Rpb24gZGlzcGxheVZhcih2YXJpYWJsZSkge1xuICAgICAgICBvdXQgKz0gaW5kZW50KGluZGVudFRpbWVzKTtcblxuICAgICAgICBpZiAoKDAsIF90eXBlb2YyW1wiZGVmYXVsdFwiXSkodmFyaWFibGUpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGR1bXBWYXIodmFyaWFibGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YXJpYWJsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG91dCArPSAnZnVuY3Rpb24oKScgKyBFT0w7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhcmlhYmxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIG91dCArPSAnc3RyaW5nKCcgKyB2YXJpYWJsZS5sZW5ndGggKyAnKSBcIicgKyB2YXJpYWJsZSArICdcIicgKyBFT0w7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhcmlhYmxlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIG91dCArPSAnbnVtYmVyKCcgKyB2YXJpYWJsZSArICcpJyArIEVPTDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFyaWFibGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIG91dCArPSAnYm9vbCgnICsgdmFyaWFibGUgKyAnKScgKyBFT0w7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBkdW1wVmFyID0gZnVuY3Rpb24gZHVtcFZhcih2YXJpYWJsZSkge1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBpZiAodmFyaWFibGUgPT09IG51bGwpIHtcbiAgICAgICAgICBvdXQgKz0gJ05VTEwnICsgRU9MO1xuICAgICAgICB9IGVsc2UgaWYgKHZhcmlhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvdXQgKz0gJ3VuZGVmaW5lZCcgKyBFT0w7XG4gICAgICAgIH0gZWxzZSBpZiAoKDAsIF90eXBlb2YyW1wiZGVmYXVsdFwiXSkodmFyaWFibGUpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIG91dCArPSBpbmRlbnQoaW5kZW50VGltZXMpICsgKDAsIF90eXBlb2YyW1wiZGVmYXVsdFwiXSkodmFyaWFibGUpO1xuICAgICAgICAgIGluZGVudFRpbWVzKys7XG5cbiAgICAgICAgICBvdXQgKz0gJygnICsgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgdmFyIHNpemUgPSAwO1xuICAgICAgICAgICAgdmFyIGtleTtcblxuICAgICAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgICAgfSh2YXJpYWJsZSkgKyAnKSB7JyArIEVPTDtcblxuICAgICAgICAgIGZvciAoaSBpbiB2YXJpYWJsZSkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhcmlhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBvdXQgKz0gaW5kZW50KGluZGVudFRpbWVzKSArICdbJyArIGkgKyAnXT0+ICcgKyBFT0w7XG4gICAgICAgICAgICAgIGRpc3BsYXlWYXIodmFyaWFibGVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGluZGVudFRpbWVzLS07XG4gICAgICAgICAgb3V0ICs9IGluZGVudChpbmRlbnRUaW1lcykgKyAnfScgKyBFT0w7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlzcGxheVZhcih2YXJpYWJsZSk7XG4gICAgICAgIH1cbiAgICAgIH07IC8vIEhhbmRsZSBubyBhcmd1bWVudCBjYXNlIGJ5IGR1bXBpbmcgdGhlIGVudGlyZSByZW5kZXIgY29udGV4dFxuXG5cbiAgICAgIGlmIChhcmdzQ29weS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYXJnc0NvcHkucHVzaChzdGF0ZS5jb250ZXh0KTtcbiAgICAgIH1cblxuICAgICAgYXJnc0NvcHkuZm9yRWFjaChmdW5jdGlvbiAodmFyaWFibGUpIHtcbiAgICAgICAgZHVtcFZhcih2YXJpYWJsZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfSxcbiAgICBkYXRlOiBmdW5jdGlvbiBkYXRlKF9kYXRlKSB7XG4gICAgICB2YXIgZGF0ZU9iajtcblxuICAgICAgaWYgKF9kYXRlID09PSB1bmRlZmluZWQgfHwgX2RhdGUgPT09IG51bGwgfHwgX2RhdGUgPT09ICcnKSB7XG4gICAgICAgIGRhdGVPYmogPSBuZXcgRGF0ZSgpO1xuICAgICAgfSBlbHNlIGlmIChUd2lnLmxpYi5pcygnRGF0ZScsIF9kYXRlKSkge1xuICAgICAgICBkYXRlT2JqID0gX2RhdGU7XG4gICAgICB9IGVsc2UgaWYgKFR3aWcubGliLmlzKCdTdHJpbmcnLCBfZGF0ZSkpIHtcbiAgICAgICAgaWYgKF9kYXRlLm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgICAgIGRhdGVPYmogPSBuZXcgRGF0ZShfZGF0ZSAqIDEwMDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGVPYmogPSBuZXcgRGF0ZShUd2lnLmxpYi5zdHJ0b3RpbWUoX2RhdGUpICogMTAwMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoVHdpZy5saWIuaXMoJ051bWJlcicsIF9kYXRlKSkge1xuICAgICAgICAvLyBUaW1lc3RhbXBcbiAgICAgICAgZGF0ZU9iaiA9IG5ldyBEYXRlKF9kYXRlICogMTAwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcignVW5hYmxlIHRvIHBhcnNlIGRhdGUgJyArIF9kYXRlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGVPYmo7XG4gICAgfSxcbiAgICBibG9jazogZnVuY3Rpb24gYmxvY2soYmxvY2tOYW1lKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzO1xuICAgICAgdmFyIGJsb2NrID0gc3RhdGUuZ2V0QmxvY2soYmxvY2tOYW1lKTtcblxuICAgICAgaWYgKGJsb2NrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrLnJlbmRlcihzdGF0ZSwgc3RhdGUuY29udGV4dCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudCgpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXM7XG4gICAgICByZXR1cm4gc3RhdGUuZ2V0QmxvY2soc3RhdGUuZ2V0TmVzdGluZ1N0YWNrVG9rZW4oVHdpZy5sb2dpYy50eXBlLmJsb2NrKS5ibG9ja05hbWUsIHRydWUpLnJlbmRlcihzdGF0ZSwgc3RhdGUuY29udGV4dCk7XG4gICAgfSxcbiAgICBhdHRyaWJ1dGU6IGZ1bmN0aW9uIGF0dHJpYnV0ZShvYmplY3QsIG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICBpZiAoVHdpZy5saWIuaXMoJ09iamVjdCcsIG9iamVjdCkpIHtcbiAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgbWV0aG9kKSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RbbWV0aG9kXS5hcHBseSh1bmRlZmluZWQsIHBhcmFtcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG9iamVjdFttZXRob2RdO1xuICAgICAgICB9XG4gICAgICB9IC8vIEFycmF5IHdpbGwgcmV0dXJuIGVsZW1lbnQgMC1pbmRleFxuXG5cbiAgICAgIHJldHVybiBvYmplY3QgPyBvYmplY3RbbWV0aG9kXSB8fCB1bmRlZmluZWQgOiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBtYXg6IGZ1bmN0aW9uIG1heCh2YWx1ZXMpIHtcbiAgICAgIGlmIChUd2lnLmxpYi5pcygnT2JqZWN0JywgdmFsdWVzKSkge1xuICAgICAgICBkZWxldGUgdmFsdWVzLl9rZXlzO1xuICAgICAgICByZXR1cm4gVHdpZy5saWIubWF4KHZhbHVlcyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBSZWZsZWN0LmFwcGx5KFR3aWcubGliLm1heCwgbnVsbCwgW3ZhbHVlc10uY29uY2F0KGFyZ3MpKTtcbiAgICB9LFxuICAgIG1pbjogZnVuY3Rpb24gbWluKHZhbHVlcykge1xuICAgICAgaWYgKFR3aWcubGliLmlzKCdPYmplY3QnLCB2YWx1ZXMpKSB7XG4gICAgICAgIGRlbGV0ZSB2YWx1ZXMuX2tleXM7XG4gICAgICAgIHJldHVybiBUd2lnLmxpYi5taW4odmFsdWVzKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zID4gMSA/IF9sZW4zIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFJlZmxlY3QuYXBwbHkoVHdpZy5saWIubWluLCBudWxsLCBbdmFsdWVzXS5jb25jYXQoYXJncykpO1xuICAgIH0sXG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlICovXG4gICAgdGVtcGxhdGVfZnJvbV9zdHJpbmc6IGZ1bmN0aW9uIHRlbXBsYXRlX2Zyb21fc3RyaW5nKHRlbXBsYXRlKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzO1xuXG4gICAgICBpZiAodGVtcGxhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0ZW1wbGF0ZSA9ICcnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gVHdpZy5UZW1wbGF0ZXMucGFyc2Vycy50d2lnKHtcbiAgICAgICAgb3B0aW9uczogc3RhdGUudGVtcGxhdGUub3B0aW9ucyxcbiAgICAgICAgZGF0YTogdGVtcGxhdGVcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcmFuZG9tOiBmdW5jdGlvbiByYW5kb20odmFsdWUpIHtcbiAgICAgIHZhciBMSU1JVF9JTlQzMSA9IDB4ODAwMDAwMDA7XG5cbiAgICAgIGZ1bmN0aW9uIGdldFJhbmRvbU51bWJlcihuKSB7XG4gICAgICAgIHZhciByYW5kb20gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBMSU1JVF9JTlQzMSk7XG4gICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbi5jYWxsKG51bGwsIDAsIG4pO1xuICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXguY2FsbChudWxsLCAwLCBuKTtcbiAgICAgICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoKG1heCAtIG1pbiArIDEpICogcmFuZG9tIC8gTElNSVRfSU5UMzEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoVHdpZy5saWIuaXMoJ051bWJlcicsIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZ2V0UmFuZG9tTnVtYmVyKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFR3aWcubGliLmlzKCdTdHJpbmcnLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmNoYXJBdChnZXRSYW5kb21OdW1iZXIodmFsdWUubGVuZ3RoIC0gMSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoVHdpZy5saWIuaXMoJ0FycmF5JywgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVtnZXRSYW5kb21OdW1iZXIodmFsdWUubGVuZ3RoIC0gMSldO1xuICAgICAgfVxuXG4gICAgICBpZiAoVHdpZy5saWIuaXMoJ09iamVjdCcsIHZhbHVlKSkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlW2tleXNbZ2V0UmFuZG9tTnVtYmVyKGtleXMubGVuZ3RoIC0gMSldXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldFJhbmRvbU51bWJlcihMSU1JVF9JTlQzMSAtIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250ZW50IG9mIGEgdGVtcGxhdGUgd2l0aG91dCByZW5kZXJpbmcgaXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lnbm9yZU1pc3Npbmc9ZmFsc2VdXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzb3VyY2U6IGZ1bmN0aW9uIHNvdXJjZShuYW1lLCBpZ25vcmVNaXNzaW5nKSB7XG4gICAgICB2YXIgdGVtcGxhdGVTb3VyY2U7XG4gICAgICB2YXIgdGVtcGxhdGVGb3VuZCA9IGZhbHNlO1xuICAgICAgdmFyIGlzTm9kZUVudmlyb25tZW50ID0gIHRydWUgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJztcbiAgICAgIHZhciBsb2FkZXI7XG4gICAgICB2YXIgcGF0aCA9IG5hbWU7IC8vIElmIHdlIGFyZSBydW5uaW5nIGluIGEgbm9kZS5qcyBlbnZpcm9ubWVudCwgc2V0IHRoZSBsb2FkZXIgdG8gJ2ZzJy5cblxuICAgICAgaWYgKGlzTm9kZUVudmlyb25tZW50KSB7XG4gICAgICAgIGxvYWRlciA9ICdmcyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkZXIgPSAnYWpheCc7XG4gICAgICB9IC8vIEJ1aWxkIHRoZSBwYXJhbXMgb2JqZWN0XG5cblxuICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgaWQ6IG5hbWUsXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIG1ldGhvZDogbG9hZGVyLFxuICAgICAgICBwYXJzZXI6ICdzb3VyY2UnLFxuICAgICAgICBhc3luYzogZmFsc2UsXG4gICAgICAgIGZldGNoVGVtcGxhdGVTb3VyY2U6IHRydWVcbiAgICAgIH07IC8vIERlZmF1bHQgaWdub3JlTWlzc2luZyB0byBmYWxzZVxuXG4gICAgICBpZiAodHlwZW9mIGlnbm9yZU1pc3NpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlnbm9yZU1pc3NpbmcgPSBmYWxzZTtcbiAgICAgIH0gLy8gVHJ5IHRvIGxvYWQgdGhlIHJlbW90ZSB0ZW1wbGF0ZVxuICAgICAgLy9cbiAgICAgIC8vIG9uIGV4Y2VwdGlvbiwgbG9nIGl0XG5cblxuICAgICAgdHJ5IHtcbiAgICAgICAgdGVtcGxhdGVTb3VyY2UgPSBUd2lnLlRlbXBsYXRlcy5sb2FkUmVtb3RlKG5hbWUsIHBhcmFtcyk7IC8vIElmIHRoZSB0ZW1wbGF0ZSBpcyB1bmRlZmluZWQgb3IgbnVsbCwgc2V0IHRoZSB0ZW1wbGF0ZSB0byBhbiBlbXB0eSBzdHJpbmcgYW5kIGRvIE5PVCBmbGlwIHRoZVxuICAgICAgICAvLyBib29sZWFuIGluZGljYXRpbmcgd2UgZm91bmQgdGhlIHRlbXBsYXRlXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGVsc2UsIGFsbCBpcyBnb29kISBmbGlwIHRoZSBib29sZWFuIGluZGljYXRpbmcgd2UgZm91bmQgdGhlIHRlbXBsYXRlXG5cbiAgICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZVNvdXJjZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdGVtcGxhdGVTb3VyY2UgPT09IG51bGwpIHtcbiAgICAgICAgICB0ZW1wbGF0ZVNvdXJjZSA9ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRlbXBsYXRlRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBUd2lnLmxvZy5kZWJ1ZygnVHdpZy5mdW5jdGlvbnMuc291cmNlOiAnLCAnUHJvYmxlbSBsb2FkaW5nIHRlbXBsYXRlICAnLCBlcnJvcik7XG4gICAgICB9IC8vIElmIHRoZSB0ZW1wbGF0ZSB3YXMgTk9UIGZvdW5kIEFORCB3ZSBhcmUgbm90IGlnbm9yaW5nIG1pc3NpbmcgdGVtcGxhdGVzLCByZXR1cm4gdGhlIHNhbWUgbWVzc2FnZVxuICAgICAgLy8gdGhhdCBpcyByZXR1cm5lZCBieSB0aGUgUEhQIGltcGxlbWVudGF0aW9uIG9mIHRoZSB0d2lnIHNvdXJjZSgpIGZ1bmN0aW9uXG4gICAgICAvL1xuICAgICAgLy8gZWxzZSwgcmV0dXJuIHRoZSB0ZW1wbGF0ZSBzb3VyY2VcblxuXG4gICAgICBpZiAoIXRlbXBsYXRlRm91bmQgJiYgIWlnbm9yZU1pc3NpbmcpIHtcbiAgICAgICAgcmV0dXJuIFRFTVBMQVRFX05PVF9GT1VORF9NRVNTQUdFLnJlcGxhY2UoJ3tuYW1lfScsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGVtcGxhdGVTb3VyY2U7XG4gICAgfVxuICB9O1xuXG4gIFR3aWcuX2Z1bmN0aW9uID0gZnVuY3Rpb24gKF9mdW5jdGlvbiwgdmFsdWUsIHBhcmFtcykge1xuICAgIGlmICghVHdpZy5mdW5jdGlvbnNbX2Z1bmN0aW9uXSkge1xuICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoJ1VuYWJsZSB0byBmaW5kIGZ1bmN0aW9uICcgKyBfZnVuY3Rpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBUd2lnLmZ1bmN0aW9uc1tfZnVuY3Rpb25dKHZhbHVlLCBwYXJhbXMpO1xuICB9O1xuXG4gIFR3aWcuX2Z1bmN0aW9uLmV4dGVuZCA9IGZ1bmN0aW9uIChfZnVuY3Rpb24sIGRlZmluaXRpb24pIHtcbiAgICBUd2lnLmZ1bmN0aW9uc1tfZnVuY3Rpb25dID0gZGVmaW5pdGlvbjtcbiAgfTtcblxuICByZXR1cm4gVHdpZztcbn07XG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gIyMgdHdpZy5saWIuanNcbi8vXG4vLyBUaGlzIGZpbGUgY29udGFpbnMgM3JkIHBhcnR5IGxpYnJhcmllcyB1c2VkIHdpdGhpbiB0d2lnLlxuLy9cbi8vIENvcGllcyBvZiB0aGUgbGljZW5zZXMgZm9yIHRoZSBjb2RlIGluY2x1ZGVkIGhlcmUgY2FuIGJlIGZvdW5kIGluIHRoZVxuLy8gTElDRU5TRVMubWQgZmlsZS5cbi8vXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUd2lnKSB7XG4gIC8vIE5hbWVzcGFjZSBmb3IgbGlicmFyaWVzXG4gIFR3aWcubGliID0ge307XG4gIFR3aWcubGliLnNwcmludGYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuICBUd2lnLmxpYi52c3ByaW50ZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuICBUd2lnLmxpYi5yb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuICBUd2lnLmxpYi5tYXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcbiAgVHdpZy5saWIubWluID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG4gIFR3aWcubGliLnN0cmlwVGFncyA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuICBUd2lnLmxpYi5zdHJ0b3RpbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcbiAgVHdpZy5saWIuZGF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuICBUd2lnLmxpYi5ib29sdmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cbiAgVHdpZy5saWIuaXMgPSBmdW5jdGlvbiAodHlwZSwgb2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopO1xuXG4gICAgICBjYXNlICdEYXRlJzpcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIERhdGU7XG5cbiAgICAgIGNhc2UgJ1N0cmluZyc6XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnc3RyaW5nJyB8fCBvYmogaW5zdGFuY2VvZiBTdHJpbmc7XG5cbiAgICAgIGNhc2UgJ051bWJlcic6XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBOdW1iZXI7XG5cbiAgICAgIGNhc2UgJ0Z1bmN0aW9uJzpcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7XG5cbiAgICAgIGNhc2UgJ09iamVjdCc6XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBPYmplY3Q7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgVHdpZy5saWIucmVwbGFjZUFsbCA9IGZ1bmN0aW9uIChzdHJpbmcsIHNlYXJjaCwgcmVwbGFjZSkge1xuICAgIC8vIEVzY2FwZSBwb3NzaWJsZSByZWd1bGFyIGV4cHJlc3Npb24gc3ludGF4XG4gICAgdmFyIHNlYXJjaEVzY2FwZWQgPSBzZWFyY2gucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UobmV3IFJlZ0V4cChzZWFyY2hFc2NhcGVkLCAnZycpLCByZXBsYWNlKTtcbiAgfTsgLy8gQ2h1bmsgYW4gYXJyYXkgKGFycikgaW50byBhcnJheXMgb2YgKHNpemUpIGl0ZW1zLCByZXR1cm5zIGFuIGFycmF5IG9mIGFycmF5cywgb3IgYW4gZW1wdHkgYXJyYXkgb24gaW52YWxpZCBpbnB1dFxuXG5cbiAgVHdpZy5saWIuY2h1bmtBcnJheSA9IGZ1bmN0aW9uIChhcnIsIHNpemUpIHtcbiAgICB2YXIgcmV0dXJuVmFsID0gW107XG4gICAgdmFyIHggPSAwO1xuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gICAgaWYgKHNpemUgPCAxIHx8ICFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB3aGlsZSAoeCA8IGxlbikge1xuICAgICAgcmV0dXJuVmFsLnB1c2goYXJyLnNsaWNlKHgsIHggKz0gc2l6ZSkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXR1cm5WYWw7XG4gIH07XG5cbiAgcmV0dXJuIFR3aWc7XG59O1xuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdnNwcmludGYoZm9ybWF0LCBhcmdzKSB7XG4gIC8vICBkaXNjdXNzIGF0OiBodHRwOi8vbG9jdXR1cy5pby9waHAvdnNwcmludGYvXG4gIC8vIG9yaWdpbmFsIGJ5OiBlanNhbmRlcnNcbiAgLy8gICBleGFtcGxlIDE6IHZzcHJpbnRmKCclMDRkLSUwMmQtJTAyZCcsIFsxOTg4LCA4LCAxXSlcbiAgLy8gICByZXR1cm5zIDE6ICcxOTg4LTA4LTAxJ1xuXG4gIHZhciBzcHJpbnRmID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuICByZXR1cm4gc3ByaW50Zi5hcHBseSh0aGlzLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZzcHJpbnRmLmpzLm1hcFxuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcm91bmQodmFsdWUsIHByZWNpc2lvbiwgbW9kZSkge1xuICAvLyAgZGlzY3VzcyBhdDogaHR0cDovL2xvY3V0dXMuaW8vcGhwL3JvdW5kL1xuICAvLyBvcmlnaW5hbCBieTogUGhpbGlwIFBldGVyc29uXG4gIC8vICByZXZpc2VkIGJ5OiBPbm5vIE1hcnNtYW4gKGh0dHBzOi8vdHdpdHRlci5jb20vb25ub21hcnNtYW4pXG4gIC8vICByZXZpc2VkIGJ5OiBULldpbGRcbiAgLy8gIHJldmlzZWQgYnk6IFJhZmHFgiBLdWthd3NraSAoaHR0cDovL2Jsb2cua3VrYXdza2kucGwpXG4gIC8vICAgIGlucHV0IGJ5OiBHcmVlbnNlZWRcbiAgLy8gICAgaW5wdXQgYnk6IG1lb1xuICAvLyAgICBpbnB1dCBieTogV2lsbGlhbVxuICAvLyAgICBpbnB1dCBieTogSm9zZXAgU2FueiAoaHR0cDovL3d3dy53czMuZXMvKVxuICAvLyBidWdmaXhlZCBieTogQnJldHQgWmFtaXIgKGh0dHA6Ly9icmV0dC16YW1pci5tZSlcbiAgLy8gICAgICBub3RlIDE6IEdyZWF0IHdvcmsuIElkZWFzIGZvciBpbXByb3ZlbWVudDpcbiAgLy8gICAgICBub3RlIDE6IC0gY29kZSBtb3JlIGNvbXBsaWFudCB3aXRoIGRldmVsb3BlciBndWlkZWxpbmVzXG4gIC8vICAgICAgbm90ZSAxOiAtIGZvciBpbXBsZW1lbnRpbmcgUEhQIGNvbnN0YW50IGFyZ3VtZW50cyBsb29rIGF0XG4gIC8vICAgICAgbm90ZSAxOiB0aGUgcGF0aGluZm8oKSBmdW5jdGlvbiwgaXQgb2ZmZXJzIHRoZSBncmVhdGVzdFxuICAvLyAgICAgIG5vdGUgMTogZmxleGliaWxpdHkgJiBjb21wYXRpYmlsaXR5IHBvc3NpYmxlXG4gIC8vICAgZXhhbXBsZSAxOiByb3VuZCgxMjQxNzU3LCAtMylcbiAgLy8gICByZXR1cm5zIDE6IDEyNDIwMDBcbiAgLy8gICBleGFtcGxlIDI6IHJvdW5kKDMuNilcbiAgLy8gICByZXR1cm5zIDI6IDRcbiAgLy8gICBleGFtcGxlIDM6IHJvdW5kKDIuODM1LCAyKVxuICAvLyAgIHJldHVybnMgMzogMi44NFxuICAvLyAgIGV4YW1wbGUgNDogcm91bmQoMS4xNzQ5OTk5OTk5OTk5LCAyKVxuICAvLyAgIHJldHVybnMgNDogMS4xN1xuICAvLyAgIGV4YW1wbGUgNTogcm91bmQoNTg1NTEuNzk5OTk5OTk5OTk2LCAyKVxuICAvLyAgIHJldHVybnMgNTogNTg1NTEuOFxuXG4gIHZhciBtLCBmLCBpc0hhbGYsIHNnbjsgLy8gaGVscGVyIHZhcmlhYmxlc1xuICAvLyBtYWtpbmcgc3VyZSBwcmVjaXNpb24gaXMgaW50ZWdlclxuICBwcmVjaXNpb24gfD0gMDtcbiAgbSA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICB2YWx1ZSAqPSBtO1xuICAvLyBzaWduIG9mIHRoZSBudW1iZXJcbiAgc2duID0gdmFsdWUgPiAwIHwgLSh2YWx1ZSA8IDApO1xuICBpc0hhbGYgPSB2YWx1ZSAlIDEgPT09IDAuNSAqIHNnbjtcbiAgZiA9IE1hdGguZmxvb3IodmFsdWUpO1xuXG4gIGlmIChpc0hhbGYpIHtcbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgIGNhc2UgJ1BIUF9ST1VORF9IQUxGX0RPV04nOlxuICAgICAgICAvLyByb3VuZHMgLjUgdG93YXJkIHplcm9cbiAgICAgICAgdmFsdWUgPSBmICsgKHNnbiA8IDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1BIUF9ST1VORF9IQUxGX0VWRU4nOlxuICAgICAgICAvLyByb3VkcyAuNSB0b3dhcmRzIHRoZSBuZXh0IGV2ZW4gaW50ZWdlclxuICAgICAgICB2YWx1ZSA9IGYgKyBmICUgMiAqIHNnbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdQSFBfUk9VTkRfSEFMRl9PREQnOlxuICAgICAgICAvLyByb3VuZHMgLjUgdG93YXJkcyB0aGUgbmV4dCBvZGQgaW50ZWdlclxuICAgICAgICB2YWx1ZSA9IGYgKyAhKGYgJSAyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyByb3VuZHMgLjUgYXdheSBmcm9tIHplcm9cbiAgICAgICAgdmFsdWUgPSBmICsgKHNnbiA+IDApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoaXNIYWxmID8gdmFsdWUgOiBNYXRoLnJvdW5kKHZhbHVlKSkgLyBtO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdW5kLmpzLm1hcFxuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYXgoKSB7XG4gIC8vICBkaXNjdXNzIGF0OiBodHRwOi8vbG9jdXR1cy5pby9waHAvbWF4L1xuICAvLyBvcmlnaW5hbCBieTogT25ubyBNYXJzbWFuIChodHRwczovL3R3aXR0ZXIuY29tL29ubm9tYXJzbWFuKVxuICAvLyAgcmV2aXNlZCBieTogT25ubyBNYXJzbWFuIChodHRwczovL3R3aXR0ZXIuY29tL29ubm9tYXJzbWFuKVxuICAvLyBpbXByb3ZlZCBieTogSmFja1xuICAvLyAgICAgIG5vdGUgMTogTG9uZyBjb2RlIGNhdXNlIHdlJ3JlIGFpbWluZyBmb3IgbWF4aW11bSBQSFAgY29tcGF0aWJpbGl0eVxuICAvLyAgIGV4YW1wbGUgMTogbWF4KDEsIDMsIDUsIDYsIDcpXG4gIC8vICAgcmV0dXJucyAxOiA3XG4gIC8vICAgZXhhbXBsZSAyOiBtYXgoWzIsIDQsIDVdKVxuICAvLyAgIHJldHVybnMgMjogNVxuICAvLyAgIGV4YW1wbGUgMzogbWF4KDAsICdoZWxsbycpXG4gIC8vICAgcmV0dXJucyAzOiAwXG4gIC8vICAgZXhhbXBsZSA0OiBtYXgoJ2hlbGxvJywgMClcbiAgLy8gICByZXR1cm5zIDQ6ICdoZWxsbydcbiAgLy8gICBleGFtcGxlIDU6IG1heCgtMSwgJ2hlbGxvJylcbiAgLy8gICByZXR1cm5zIDU6ICdoZWxsbydcbiAgLy8gICBleGFtcGxlIDY6IG1heChbMiwgNCwgOF0sIFsyLCA1LCA3XSlcbiAgLy8gICByZXR1cm5zIDY6IFsyLCA1LCA3XVxuXG4gIHZhciBhcjtcbiAgdmFyIHJldFZhbDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbiA9IDA7XG4gIHZhciBhcmd2ID0gYXJndW1lbnRzO1xuICB2YXIgYXJnYyA9IGFyZ3YubGVuZ3RoO1xuICB2YXIgX29iajJBcnJheSA9IGZ1bmN0aW9uIF9vYmoyQXJyYXkob2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXIgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICBhci5wdXNoKG9ialtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcjtcbiAgICB9XG4gIH07XG4gIHZhciBfY29tcGFyZSA9IGZ1bmN0aW9uIF9jb21wYXJlKGN1cnJlbnQsIG5leHQpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIG4gPSAwO1xuICAgIHZhciB0bXAgPSAwO1xuICAgIHZhciBubCA9IDA7XG4gICAgdmFyIGNsID0gMDtcblxuICAgIGlmIChjdXJyZW50ID09PSBuZXh0KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKCh0eXBlb2YgY3VycmVudCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoY3VycmVudCkpID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKCh0eXBlb2YgbmV4dCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobmV4dCkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjdXJyZW50ID0gX29iajJBcnJheShjdXJyZW50KTtcbiAgICAgICAgbmV4dCA9IF9vYmoyQXJyYXkobmV4dCk7XG4gICAgICAgIGNsID0gY3VycmVudC5sZW5ndGg7XG4gICAgICAgIG5sID0gbmV4dC5sZW5ndGg7XG4gICAgICAgIGlmIChubCA+IGNsKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSBpZiAobmwgPCBjbCkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwLCBuID0gY2w7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICB0bXAgPSBfY29tcGFyZShjdXJyZW50W2ldLCBuZXh0W2ldKTtcbiAgICAgICAgICBpZiAodG1wID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRtcCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIGlmICgodHlwZW9mIG5leHQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG5leHQpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoaXNOYU4obmV4dCkgJiYgIWlzTmFOKGN1cnJlbnQpKSB7XG4gICAgICBpZiAoY3VycmVudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyZW50IDwgMCA/IDEgOiAtMTtcbiAgICB9IGVsc2UgaWYgKGlzTmFOKGN1cnJlbnQpICYmICFpc05hTihuZXh0KSkge1xuICAgICAgaWYgKG5leHQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV4dCA+IDAgPyAxIDogLTE7XG4gICAgfVxuXG4gICAgaWYgKG5leHQgPT09IGN1cnJlbnQpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0ID4gY3VycmVudCA/IDEgOiAtMTtcbiAgfTtcblxuICBpZiAoYXJnYyA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQXQgbGVhc3Qgb25lIHZhbHVlIHNob3VsZCBiZSBwYXNzZWQgdG8gbWF4KCknKTtcbiAgfSBlbHNlIGlmIChhcmdjID09PSAxKSB7XG4gICAgaWYgKF90eXBlb2YoYXJndlswXSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBhciA9IF9vYmoyQXJyYXkoYXJndlswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgcGFyYW1ldGVyIGNvdW50IGZvciBtYXgoKScpO1xuICAgIH1cbiAgICBpZiAoYXIubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FycmF5IG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgZWxlbWVudCBmb3IgbWF4KCknKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYXIgPSBhcmd2O1xuICB9XG5cbiAgcmV0VmFsID0gYXJbMF07XG4gIGZvciAoaSA9IDEsIG4gPSBhci5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoX2NvbXBhcmUocmV0VmFsLCBhcltpXSkgPT09IDEpIHtcbiAgICAgIHJldFZhbCA9IGFyW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXRWYWw7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF4LmpzLm1hcFxuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtaW4oKSB7XG4gIC8vICBkaXNjdXNzIGF0OiBodHRwOi8vbG9jdXR1cy5pby9waHAvbWluL1xuICAvLyBvcmlnaW5hbCBieTogT25ubyBNYXJzbWFuIChodHRwczovL3R3aXR0ZXIuY29tL29ubm9tYXJzbWFuKVxuICAvLyAgcmV2aXNlZCBieTogT25ubyBNYXJzbWFuIChodHRwczovL3R3aXR0ZXIuY29tL29ubm9tYXJzbWFuKVxuICAvLyBpbXByb3ZlZCBieTogSmFja1xuICAvLyAgICAgIG5vdGUgMTogTG9uZyBjb2RlIGNhdXNlIHdlJ3JlIGFpbWluZyBmb3IgbWF4aW11bSBQSFAgY29tcGF0aWJpbGl0eVxuICAvLyAgIGV4YW1wbGUgMTogbWluKDEsIDMsIDUsIDYsIDcpXG4gIC8vICAgcmV0dXJucyAxOiAxXG4gIC8vICAgZXhhbXBsZSAyOiBtaW4oWzIsIDQsIDVdKVxuICAvLyAgIHJldHVybnMgMjogMlxuICAvLyAgIGV4YW1wbGUgMzogbWluKDAsICdoZWxsbycpXG4gIC8vICAgcmV0dXJucyAzOiAwXG4gIC8vICAgZXhhbXBsZSA0OiBtaW4oJ2hlbGxvJywgMClcbiAgLy8gICByZXR1cm5zIDQ6ICdoZWxsbydcbiAgLy8gICBleGFtcGxlIDU6IG1pbigtMSwgJ2hlbGxvJylcbiAgLy8gICByZXR1cm5zIDU6IC0xXG4gIC8vICAgZXhhbXBsZSA2OiBtaW4oWzIsIDQsIDhdLCBbMiwgNSwgN10pXG4gIC8vICAgcmV0dXJucyA2OiBbMiwgNCwgOF1cblxuICB2YXIgYXI7XG4gIHZhciByZXRWYWw7XG4gIHZhciBpID0gMDtcbiAgdmFyIG4gPSAwO1xuICB2YXIgYXJndiA9IGFyZ3VtZW50cztcbiAgdmFyIGFyZ2MgPSBhcmd2Lmxlbmd0aDtcbiAgdmFyIF9vYmoyQXJyYXkgPSBmdW5jdGlvbiBfb2JqMkFycmF5KG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgdmFyIGFyID0gW107XG4gICAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgYXIucHVzaChvYmpbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG4gIH07XG5cbiAgdmFyIF9jb21wYXJlID0gZnVuY3Rpb24gX2NvbXBhcmUoY3VycmVudCwgbmV4dCkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbiA9IDA7XG4gICAgdmFyIHRtcCA9IDA7XG4gICAgdmFyIG5sID0gMDtcbiAgICB2YXIgY2wgPSAwO1xuXG4gICAgaWYgKGN1cnJlbnQgPT09IG5leHQpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBjdXJyZW50ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjdXJyZW50KSkgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoKHR5cGVvZiBuZXh0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihuZXh0KSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGN1cnJlbnQgPSBfb2JqMkFycmF5KGN1cnJlbnQpO1xuICAgICAgICBuZXh0ID0gX29iajJBcnJheShuZXh0KTtcbiAgICAgICAgY2wgPSBjdXJyZW50Lmxlbmd0aDtcbiAgICAgICAgbmwgPSBuZXh0Lmxlbmd0aDtcbiAgICAgICAgaWYgKG5sID4gY2wpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIGlmIChubCA8IGNsKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDAsIG4gPSBjbDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIHRtcCA9IF9jb21wYXJlKGN1cnJlbnRbaV0sIG5leHRbaV0pO1xuICAgICAgICAgIGlmICh0bXAgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG1wID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKCh0eXBlb2YgbmV4dCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobmV4dCkpID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChpc05hTihuZXh0KSAmJiAhaXNOYU4oY3VycmVudCkpIHtcbiAgICAgIGlmIChjdXJyZW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJlbnQgPCAwID8gMSA6IC0xO1xuICAgIH0gZWxzZSBpZiAoaXNOYU4oY3VycmVudCkgJiYgIWlzTmFOKG5leHQpKSB7XG4gICAgICBpZiAobmV4dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXh0ID4gMCA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gY3VycmVudCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHQgPiBjdXJyZW50ID8gMSA6IC0xO1xuICB9O1xuXG4gIGlmIChhcmdjID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBdCBsZWFzdCBvbmUgdmFsdWUgc2hvdWxkIGJlIHBhc3NlZCB0byBtaW4oKScpO1xuICB9IGVsc2UgaWYgKGFyZ2MgPT09IDEpIHtcbiAgICBpZiAoX3R5cGVvZihhcmd2WzBdKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGFyID0gX29iajJBcnJheShhcmd2WzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBwYXJhbWV0ZXIgY291bnQgZm9yIG1pbigpJyk7XG4gICAgfVxuXG4gICAgaWYgKGFyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcnJheSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIGVsZW1lbnQgZm9yIG1pbigpJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFyID0gYXJndjtcbiAgfVxuXG4gIHJldFZhbCA9IGFyWzBdO1xuXG4gIGZvciAoaSA9IDEsIG4gPSBhci5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoX2NvbXBhcmUocmV0VmFsLCBhcltpXSkgPT09IC0xKSB7XG4gICAgICByZXRWYWwgPSBhcltpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0VmFsO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pbi5qcy5tYXBcblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN0cmlwX3RhZ3MoaW5wdXQsIGFsbG93ZWQpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgLy8gIGRpc2N1c3MgYXQ6IGh0dHA6Ly9sb2N1dHVzLmlvL3BocC9zdHJpcF90YWdzL1xuICAvLyBvcmlnaW5hbCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2t2ei5pbylcbiAgLy8gaW1wcm92ZWQgYnk6IEx1a2UgR29kZnJleVxuICAvLyBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2t2ei5pbylcbiAgLy8gICAgaW5wdXQgYnk6IFB1bFxuICAvLyAgICBpbnB1dCBieTogQWxleFxuICAvLyAgICBpbnB1dCBieTogTWFyYyBQYWxhdVxuICAvLyAgICBpbnB1dCBieTogQnJldHQgWmFtaXIgKGh0dHA6Ly9icmV0dC16YW1pci5tZSlcbiAgLy8gICAgaW5wdXQgYnk6IEJvYmJ5IERyYWtlXG4gIC8vICAgIGlucHV0IGJ5OiBFdmVydGphbiBHYXJyZXRzZW5cbiAgLy8gYnVnZml4ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rdnouaW8pXG4gIC8vIGJ1Z2ZpeGVkIGJ5OiBPbm5vIE1hcnNtYW4gKGh0dHBzOi8vdHdpdHRlci5jb20vb25ub21hcnNtYW4pXG4gIC8vIGJ1Z2ZpeGVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va3Z6LmlvKVxuICAvLyBidWdmaXhlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2t2ei5pbylcbiAgLy8gYnVnZml4ZWQgYnk6IEVyaWMgTmFnZWxcbiAgLy8gYnVnZml4ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rdnouaW8pXG4gIC8vIGJ1Z2ZpeGVkIGJ5OiBUb21hc3ogV2Vzb2xvd3NraVxuICAvLyBidWdmaXhlZCBieTogVHltb24gU3R1cmdlb24gKGh0dHBzOi8vc2NyeXB0b25pdGUuY29tKVxuICAvLyBidWdmaXhlZCBieTogVGltIGRlIEtvbmluZyAoaHR0cHM6Ly93d3cua2luZ3NxdWFyZS5ubClcbiAgLy8gIHJldmlzZWQgYnk6IFJhZmHFgiBLdWthd3NraSAoaHR0cDovL2Jsb2cua3VrYXdza2kucGwpXG4gIC8vICAgZXhhbXBsZSAxOiBzdHJpcF90YWdzKCc8cD5LZXZpbjwvcD4gPGJyIC8+PGI+dmFuPC9iPiA8aT5ab25uZXZlbGQ8L2k+JywgJzxpPjxiPicpXG4gIC8vICAgcmV0dXJucyAxOiAnS2V2aW4gPGI+dmFuPC9iPiA8aT5ab25uZXZlbGQ8L2k+J1xuICAvLyAgIGV4YW1wbGUgMjogc3RyaXBfdGFncygnPHA+S2V2aW4gPGltZyBzcmM9XCJzb21laW1hZ2UucG5nXCIgb25tb3VzZW92ZXI9XCJzb21lRnVuY3Rpb24oKVwiPnZhbiA8aT5ab25uZXZlbGQ8L2k+PC9wPicsICc8cD4nKVxuICAvLyAgIHJldHVybnMgMjogJzxwPktldmluIHZhbiBab25uZXZlbGQ8L3A+J1xuICAvLyAgIGV4YW1wbGUgMzogc3RyaXBfdGFncyhcIjxhIGhyZWY9J2h0dHA6Ly9rdnouaW8nPktldmluIHZhbiBab25uZXZlbGQ8L2E+XCIsIFwiPGE+XCIpXG4gIC8vICAgcmV0dXJucyAzOiBcIjxhIGhyZWY9J2h0dHA6Ly9rdnouaW8nPktldmluIHZhbiBab25uZXZlbGQ8L2E+XCJcbiAgLy8gICBleGFtcGxlIDQ6IHN0cmlwX3RhZ3MoJzEgPCA1IDUgPiAxJylcbiAgLy8gICByZXR1cm5zIDQ6ICcxIDwgNSA1ID4gMSdcbiAgLy8gICBleGFtcGxlIDU6IHN0cmlwX3RhZ3MoJzEgPGJyLz4gMScpXG4gIC8vICAgcmV0dXJucyA1OiAnMSAgMSdcbiAgLy8gICBleGFtcGxlIDY6IHN0cmlwX3RhZ3MoJzEgPGJyLz4gMScsICc8YnI+JylcbiAgLy8gICByZXR1cm5zIDY6ICcxIDxici8+IDEnXG4gIC8vICAgZXhhbXBsZSA3OiBzdHJpcF90YWdzKCcxIDxici8+IDEnLCAnPGJyPjxici8+JylcbiAgLy8gICByZXR1cm5zIDc6ICcxIDxici8+IDEnXG4gIC8vICAgZXhhbXBsZSA4OiBzdHJpcF90YWdzKCc8aT5oZWxsbzwvaT4gPDxmb28+c2NyaXB0PndvcmxkPDwvZm9vPi9zY3JpcHQ+JylcbiAgLy8gICByZXR1cm5zIDg6ICdoZWxsbyB3b3JsZCdcbiAgLy8gICBleGFtcGxlIDk6IHN0cmlwX3RhZ3MoNClcbiAgLy8gICByZXR1cm5zIDk6ICc0J1xuXG4gIHZhciBfcGhwQ2FzdFN0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXG4gIC8vIG1ha2luZyBzdXJlIHRoZSBhbGxvd2VkIGFyZyBpcyBhIHN0cmluZyBjb250YWluaW5nIG9ubHkgdGFncyBpbiBsb3dlcmNhc2UgKDxhPjxiPjxjPilcbiAgYWxsb3dlZCA9ICgoKGFsbG93ZWQgfHwgJycpICsgJycpLnRvTG93ZXJDYXNlKCkubWF0Y2goLzxbYS16XVthLXowLTldKj4vZykgfHwgW10pLmpvaW4oJycpO1xuXG4gIHZhciB0YWdzID0gLzxcXC8/KFthLXowLTldKilcXGJbXj5dKj4/L2dpO1xuICB2YXIgY29tbWVudHNBbmRQaHBUYWdzID0gLzwhLS1bXFxzXFxTXSo/LS0+fDxcXD8oPzpwaHApP1tcXHNcXFNdKj9cXD8+L2dpO1xuXG4gIHZhciBhZnRlciA9IF9waHBDYXN0U3RyaW5nKGlucHV0KTtcbiAgLy8gcmVtb3ZlcyB0aGEgJzwnIGNoYXIgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nIHRvIHJlcGxpY2F0ZSBQSFAncyBiZWhhdmlvdXJcbiAgYWZ0ZXIgPSBhZnRlci5zdWJzdHJpbmcoYWZ0ZXIubGVuZ3RoIC0gMSkgPT09ICc8JyA/IGFmdGVyLnN1YnN0cmluZygwLCBhZnRlci5sZW5ndGggLSAxKSA6IGFmdGVyO1xuXG4gIC8vIHJlY3Vyc2l2ZWx5IHJlbW92ZSB0YWdzIHRvIGVuc3VyZSB0aGF0IHRoZSByZXR1cm5lZCBzdHJpbmcgZG9lc24ndCBjb250YWluIGZvcmJpZGRlbiB0YWdzIGFmdGVyIHByZXZpb3VzIHBhc3NlcyAoZS5nLiAnPDxiYWl0Lz5zd2l0Y2gvPicpXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIGJlZm9yZSA9IGFmdGVyO1xuICAgIGFmdGVyID0gYmVmb3JlLnJlcGxhY2UoY29tbWVudHNBbmRQaHBUYWdzLCAnJykucmVwbGFjZSh0YWdzLCBmdW5jdGlvbiAoJDAsICQxKSB7XG4gICAgICByZXR1cm4gYWxsb3dlZC5pbmRleE9mKCc8JyArICQxLnRvTG93ZXJDYXNlKCkgKyAnPicpID4gLTEgPyAkMCA6ICcnO1xuICAgIH0pO1xuXG4gICAgLy8gcmV0dXJuIG9uY2Ugbm8gbW9yZSB0YWdzIGFyZSByZW1vdmVkXG4gICAgaWYgKGJlZm9yZSA9PT0gYWZ0ZXIpIHtcbiAgICAgIHJldHVybiBhZnRlcjtcbiAgICB9XG4gIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpcF90YWdzLmpzLm1hcFxuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBfcGhwQ2FzdFN0cmluZyh2YWx1ZSkge1xuICAvLyBvcmlnaW5hbCBieTogUmFmYcWCIEt1a2F3c2tpXG4gIC8vICAgZXhhbXBsZSAxOiBfcGhwQ2FzdFN0cmluZyh0cnVlKVxuICAvLyAgIHJldHVybnMgMTogJzEnXG4gIC8vICAgZXhhbXBsZSAyOiBfcGhwQ2FzdFN0cmluZyhmYWxzZSlcbiAgLy8gICByZXR1cm5zIDI6ICcnXG4gIC8vICAgZXhhbXBsZSAzOiBfcGhwQ2FzdFN0cmluZygnZm9vJylcbiAgLy8gICByZXR1cm5zIDM6ICdmb28nXG4gIC8vICAgZXhhbXBsZSA0OiBfcGhwQ2FzdFN0cmluZygwLzApXG4gIC8vICAgcmV0dXJucyA0OiAnTkFOJ1xuICAvLyAgIGV4YW1wbGUgNTogX3BocENhc3RTdHJpbmcoMS8wKVxuICAvLyAgIHJldHVybnMgNTogJ0lORidcbiAgLy8gICBleGFtcGxlIDY6IF9waHBDYXN0U3RyaW5nKC0xLzApXG4gIC8vICAgcmV0dXJucyA2OiAnLUlORidcbiAgLy8gICBleGFtcGxlIDc6IF9waHBDYXN0U3RyaW5nKG51bGwpXG4gIC8vICAgcmV0dXJucyA3OiAnJ1xuICAvLyAgIGV4YW1wbGUgODogX3BocENhc3RTdHJpbmcodW5kZWZpbmVkKVxuICAvLyAgIHJldHVybnMgODogJydcbiAgLy8gICBleGFtcGxlIDk6IF9waHBDYXN0U3RyaW5nKFtdKVxuICAvLyAgIHJldHVybnMgOTogJ0FycmF5J1xuICAvLyAgIGV4YW1wbGUgMTA6IF9waHBDYXN0U3RyaW5nKHt9KVxuICAvLyAgIHJldHVybnMgMTA6ICdPYmplY3QnXG4gIC8vICAgZXhhbXBsZSAxMTogX3BocENhc3RTdHJpbmcoMClcbiAgLy8gICByZXR1cm5zIDExOiAnMCdcbiAgLy8gICBleGFtcGxlIDEyOiBfcGhwQ2FzdFN0cmluZygxKVxuICAvLyAgIHJldHVybnMgMTI6ICcxJ1xuICAvLyAgIGV4YW1wbGUgMTM6IF9waHBDYXN0U3RyaW5nKDMuMTQpXG4gIC8vICAgcmV0dXJucyAxMzogJzMuMTQnXG5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKTtcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2YWx1ZSA/ICcxJyA6ICcnO1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICdOQU4nO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlIDwgMCA/ICctJyA6ICcnKSArICdJTkYnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWUgKyAnJztcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuICcnO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICdBcnJheSc7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ09iamVjdCc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnJztcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgdmFsdWUgdHlwZScpO1xuICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3BocENhc3RTdHJpbmcuanMubWFwXG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHJlU3BhY2UgPSAnWyBcXFxcdF0rJztcbnZhciByZVNwYWNlT3B0ID0gJ1sgXFxcXHRdKic7XG52YXIgcmVNZXJpZGlhbiA9ICcoPzooW2FwXSlcXFxcLj9tXFxcXC4/KFtcXFxcdCBdfCQpKSc7XG52YXIgcmVIb3VyMjQgPSAnKDJbMC00XXxbMDFdP1swLTldKSc7XG52YXIgcmVIb3VyMjRseiA9ICcoWzAxXVswLTldfDJbMC00XSknO1xudmFyIHJlSG91cjEyID0gJygwP1sxLTldfDFbMC0yXSknO1xudmFyIHJlTWludXRlID0gJyhbMC01XT9bMC05XSknO1xudmFyIHJlTWludXRlbHogPSAnKFswLTVdWzAtOV0pJztcbnZhciByZVNlY29uZCA9ICcoNjB8WzAtNV0/WzAtOV0pJztcbnZhciByZVNlY29uZGx6ID0gJyg2MHxbMC01XVswLTldKSc7XG52YXIgcmVGcmFjID0gJyg/OlxcXFwuKFswLTldKykpJztcblxudmFyIHJlRGF5ZnVsbCA9ICdzdW5kYXl8bW9uZGF5fHR1ZXNkYXl8d2VkbmVzZGF5fHRodXJzZGF5fGZyaWRheXxzYXR1cmRheSc7XG52YXIgcmVEYXlhYmJyID0gJ3N1bnxtb258dHVlfHdlZHx0aHV8ZnJpfHNhdCc7XG52YXIgcmVEYXl0ZXh0ID0gcmVEYXlmdWxsICsgJ3wnICsgcmVEYXlhYmJyICsgJ3x3ZWVrZGF5cz8nO1xuXG52YXIgcmVSZWx0ZXh0bnVtYmVyID0gJ2ZpcnN0fHNlY29uZHx0aGlyZHxmb3VydGh8ZmlmdGh8c2l4dGh8c2V2ZW50aHxlaWdodGg/fG5pbnRofHRlbnRofGVsZXZlbnRofHR3ZWxmdGgnO1xudmFyIHJlUmVsdGV4dHRleHQgPSAnbmV4dHxsYXN0fHByZXZpb3VzfHRoaXMnO1xudmFyIHJlUmVsdGV4dHVuaXQgPSAnKD86c2Vjb25kfHNlY3xtaW51dGV8bWlufGhvdXJ8ZGF5fGZvcnRuaWdodHxmb3J0aG5pZ2h0fG1vbnRofHllYXIpcz98d2Vla3N8JyArIHJlRGF5dGV4dDtcblxudmFyIHJlWWVhciA9ICcoWzAtOV17MSw0fSknO1xudmFyIHJlWWVhcjIgPSAnKFswLTldezJ9KSc7XG52YXIgcmVZZWFyNCA9ICcoWzAtOV17NH0pJztcbnZhciByZVllYXI0d2l0aFNpZ24gPSAnKFsrLV0/WzAtOV17NH0pJztcbnZhciByZU1vbnRoID0gJygxWzAtMl18MD9bMC05XSknO1xudmFyIHJlTW9udGhseiA9ICcoMFswLTldfDFbMC0yXSknO1xudmFyIHJlRGF5ID0gJyg/OigzWzAxXXxbMC0yXT9bMC05XSkoPzpzdHxuZHxyZHx0aCk/KSc7XG52YXIgcmVEYXlseiA9ICcoMFswLTldfFsxLTJdWzAtOV18M1swMV0pJztcblxudmFyIHJlTW9udGhGdWxsID0gJ2phbnVhcnl8ZmVicnVhcnl8bWFyY2h8YXByaWx8bWF5fGp1bmV8anVseXxhdWd1c3R8c2VwdGVtYmVyfG9jdG9iZXJ8bm92ZW1iZXJ8ZGVjZW1iZXInO1xudmFyIHJlTW9udGhBYmJyID0gJ2phbnxmZWJ8bWFyfGFwcnxtYXl8anVufGp1bHxhdWd8c2VwdD98b2N0fG5vdnxkZWMnO1xudmFyIHJlTW9udGhyb21hbiA9ICdpW3Z4XXx2aXswLDN9fHhpezAsMn18aXsxLDN9JztcbnZhciByZU1vbnRoVGV4dCA9ICcoJyArIHJlTW9udGhGdWxsICsgJ3wnICsgcmVNb250aEFiYnIgKyAnfCcgKyByZU1vbnRocm9tYW4gKyAnKSc7XG5cbnZhciByZVR6Q29ycmVjdGlvbiA9ICcoKD86R01UKT8oWystXSknICsgcmVIb3VyMjQgKyAnOj8nICsgcmVNaW51dGUgKyAnPyknO1xudmFyIHJlRGF5T2ZZZWFyID0gJygwMFsxLTldfDBbMS05XVswLTldfFsxMl1bMC05XVswLTldfDNbMC01XVswLTldfDM2WzAtNl0pJztcbnZhciByZVdlZWtPZlllYXIgPSAnKDBbMS05XXxbMS00XVswLTldfDVbMC0zXSknO1xuXG5mdW5jdGlvbiBwcm9jZXNzTWVyaWRpYW4oaG91ciwgbWVyaWRpYW4pIHtcbiAgbWVyaWRpYW4gPSBtZXJpZGlhbiAmJiBtZXJpZGlhbi50b0xvd2VyQ2FzZSgpO1xuXG4gIHN3aXRjaCAobWVyaWRpYW4pIHtcbiAgICBjYXNlICdhJzpcbiAgICAgIGhvdXIgKz0gaG91ciA9PT0gMTIgPyAtMTIgOiAwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncCc6XG4gICAgICBob3VyICs9IGhvdXIgIT09IDEyID8gMTIgOiAwO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gaG91cjtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1llYXIoeWVhclN0cikge1xuICB2YXIgeWVhciA9ICt5ZWFyU3RyO1xuXG4gIGlmICh5ZWFyU3RyLmxlbmd0aCA8IDQgJiYgeWVhciA8IDEwMCkge1xuICAgIHllYXIgKz0geWVhciA8IDcwID8gMjAwMCA6IDE5MDA7XG4gIH1cblxuICByZXR1cm4geWVhcjtcbn1cblxuZnVuY3Rpb24gbG9va3VwTW9udGgobW9udGhTdHIpIHtcbiAgcmV0dXJuIHtcbiAgICBqYW46IDAsXG4gICAgamFudWFyeTogMCxcbiAgICBpOiAwLFxuICAgIGZlYjogMSxcbiAgICBmZWJydWFyeTogMSxcbiAgICBpaTogMSxcbiAgICBtYXI6IDIsXG4gICAgbWFyY2g6IDIsXG4gICAgaWlpOiAyLFxuICAgIGFwcjogMyxcbiAgICBhcHJpbDogMyxcbiAgICBpdjogMyxcbiAgICBtYXk6IDQsXG4gICAgdjogNCxcbiAgICBqdW46IDUsXG4gICAganVuZTogNSxcbiAgICB2aTogNSxcbiAgICBqdWw6IDYsXG4gICAganVseTogNixcbiAgICB2aWk6IDYsXG4gICAgYXVnOiA3LFxuICAgIGF1Z3VzdDogNyxcbiAgICB2aWlpOiA3LFxuICAgIHNlcDogOCxcbiAgICBzZXB0OiA4LFxuICAgIHNlcHRlbWJlcjogOCxcbiAgICBpeDogOCxcbiAgICBvY3Q6IDksXG4gICAgb2N0b2JlcjogOSxcbiAgICB4OiA5LFxuICAgIG5vdjogMTAsXG4gICAgbm92ZW1iZXI6IDEwLFxuICAgIHhpOiAxMCxcbiAgICBkZWM6IDExLFxuICAgIGRlY2VtYmVyOiAxMSxcbiAgICB4aWk6IDExXG4gIH1bbW9udGhTdHIudG9Mb3dlckNhc2UoKV07XG59XG5cbmZ1bmN0aW9uIGxvb2t1cFdlZWtkYXkoZGF5U3RyKSB7XG4gIHZhciBkZXNpcmVkU3VuZGF5TnVtYmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuXG4gIHZhciBkYXlOdW1iZXJzID0ge1xuICAgIG1vbjogMSxcbiAgICBtb25kYXk6IDEsXG4gICAgdHVlOiAyLFxuICAgIHR1ZXNkYXk6IDIsXG4gICAgd2VkOiAzLFxuICAgIHdlZG5lc2RheTogMyxcbiAgICB0aHU6IDQsXG4gICAgdGh1cnNkYXk6IDQsXG4gICAgZnJpOiA1LFxuICAgIGZyaWRheTogNSxcbiAgICBzYXQ6IDYsXG4gICAgc2F0dXJkYXk6IDYsXG4gICAgc3VuOiAwLFxuICAgIHN1bmRheTogMFxuICB9O1xuXG4gIHJldHVybiBkYXlOdW1iZXJzW2RheVN0ci50b0xvd2VyQ2FzZSgpXSB8fCBkZXNpcmVkU3VuZGF5TnVtYmVyO1xufVxuXG5mdW5jdGlvbiBsb29rdXBSZWxhdGl2ZShyZWxUZXh0KSB7XG4gIHZhciByZWxhdGl2ZU51bWJlcnMgPSB7XG4gICAgbGFzdDogLTEsXG4gICAgcHJldmlvdXM6IC0xLFxuICAgIHRoaXM6IDAsXG4gICAgZmlyc3Q6IDEsXG4gICAgbmV4dDogMSxcbiAgICBzZWNvbmQ6IDIsXG4gICAgdGhpcmQ6IDMsXG4gICAgZm91cnRoOiA0LFxuICAgIGZpZnRoOiA1LFxuICAgIHNpeHRoOiA2LFxuICAgIHNldmVudGg6IDcsXG4gICAgZWlnaHQ6IDgsXG4gICAgZWlnaHRoOiA4LFxuICAgIG5pbnRoOiA5LFxuICAgIHRlbnRoOiAxMCxcbiAgICBlbGV2ZW50aDogMTEsXG4gICAgdHdlbGZ0aDogMTJcbiAgfTtcblxuICB2YXIgcmVsYXRpdmVCZWhhdmlvciA9IHtcbiAgICB0aGlzOiAxXG4gIH07XG5cbiAgdmFyIHJlbFRleHRMb3dlciA9IHJlbFRleHQudG9Mb3dlckNhc2UoKTtcblxuICByZXR1cm4ge1xuICAgIGFtb3VudDogcmVsYXRpdmVOdW1iZXJzW3JlbFRleHRMb3dlcl0sXG4gICAgYmVoYXZpb3I6IHJlbGF0aXZlQmVoYXZpb3JbcmVsVGV4dExvd2VyXSB8fCAwXG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NUekNvcnJlY3Rpb24odHpPZmZzZXQsIG9sZFZhbHVlKSB7XG4gIHZhciByZVR6Q29ycmVjdGlvbkxvb3NlID0gLyg/OkdNVCk/KFsrLV0pKFxcZCspKDo/KShcXGR7MCwyfSkvaTtcbiAgdHpPZmZzZXQgPSB0ek9mZnNldCAmJiB0ek9mZnNldC5tYXRjaChyZVR6Q29ycmVjdGlvbkxvb3NlKTtcblxuICBpZiAoIXR6T2Zmc2V0KSB7XG4gICAgcmV0dXJuIG9sZFZhbHVlO1xuICB9XG5cbiAgdmFyIHNpZ24gPSB0ek9mZnNldFsxXSA9PT0gJy0nID8gMSA6IC0xO1xuICB2YXIgaG91cnMgPSArdHpPZmZzZXRbMl07XG4gIHZhciBtaW51dGVzID0gK3R6T2Zmc2V0WzRdO1xuXG4gIGlmICghdHpPZmZzZXRbNF0gJiYgIXR6T2Zmc2V0WzNdKSB7XG4gICAgbWludXRlcyA9IE1hdGguZmxvb3IoaG91cnMgJSAxMDApO1xuICAgIGhvdXJzID0gTWF0aC5mbG9vcihob3VycyAvIDEwMCk7XG4gIH1cblxuICByZXR1cm4gc2lnbiAqIChob3VycyAqIDYwICsgbWludXRlcyk7XG59XG5cbnZhciBmb3JtYXRzID0ge1xuICB5ZXN0ZXJkYXk6IHtcbiAgICByZWdleDogL155ZXN0ZXJkYXkvaSxcbiAgICBuYW1lOiAneWVzdGVyZGF5JyxcbiAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2soKSB7XG4gICAgICB0aGlzLnJkIC09IDE7XG4gICAgICByZXR1cm4gdGhpcy5yZXNldFRpbWUoKTtcbiAgICB9XG4gIH0sXG5cbiAgbm93OiB7XG4gICAgcmVnZXg6IC9ebm93L2ksXG4gICAgbmFtZTogJ25vdydcbiAgICAvLyBkbyBub3RoaW5nXG4gIH0sXG5cbiAgbm9vbjoge1xuICAgIHJlZ2V4OiAvXm5vb24vaSxcbiAgICBuYW1lOiAnbm9vbicsXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVzZXRUaW1lKCkgJiYgdGhpcy50aW1lKDEyLCAwLCAwLCAwKTtcbiAgICB9XG4gIH0sXG5cbiAgbWlkbmlnaHRPclRvZGF5OiB7XG4gICAgcmVnZXg6IC9eKG1pZG5pZ2h0fHRvZGF5KS9pLFxuICAgIG5hbWU6ICdtaWRuaWdodCB8IHRvZGF5JyxcbiAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2soKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXNldFRpbWUoKTtcbiAgICB9XG4gIH0sXG5cbiAgdG9tb3Jyb3c6IHtcbiAgICByZWdleDogL150b21vcnJvdy9pLFxuICAgIG5hbWU6ICd0b21vcnJvdycsXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuICAgICAgdGhpcy5yZCArPSAxO1xuICAgICAgcmV0dXJuIHRoaXMucmVzZXRUaW1lKCk7XG4gICAgfVxuICB9LFxuXG4gIHRpbWVzdGFtcDoge1xuICAgIHJlZ2V4OiAvXkAoLT9cXGQrKS9pLFxuICAgIG5hbWU6ICd0aW1lc3RhbXAnLFxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjayhtYXRjaCwgdGltZXN0YW1wKSB7XG4gICAgICB0aGlzLnJzICs9ICt0aW1lc3RhbXA7XG4gICAgICB0aGlzLnkgPSAxOTcwO1xuICAgICAgdGhpcy5tID0gMDtcbiAgICAgIHRoaXMuZCA9IDE7XG4gICAgICB0aGlzLmRhdGVzID0gMDtcblxuICAgICAgcmV0dXJuIHRoaXMucmVzZXRUaW1lKCkgJiYgdGhpcy56b25lKDApO1xuICAgIH1cbiAgfSxcblxuICBmaXJzdE9yTGFzdERheToge1xuICAgIHJlZ2V4OiAvXihmaXJzdHxsYXN0KSBkYXkgb2YvaSxcbiAgICBuYW1lOiAnZmlyc3RkYXlvZiB8IGxhc3RkYXlvZicsXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKG1hdGNoLCBkYXkpIHtcbiAgICAgIGlmIChkYXkudG9Mb3dlckNhc2UoKSA9PT0gJ2ZpcnN0Jykge1xuICAgICAgICB0aGlzLmZpcnN0T3JMYXN0RGF5T2ZNb250aCA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZpcnN0T3JMYXN0RGF5T2ZNb250aCA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBiYWNrT3JGcm9udE9mOiB7XG4gICAgcmVnZXg6IFJlZ0V4cCgnXihiYWNrfGZyb250KSBvZiAnICsgcmVIb3VyMjQgKyByZVNwYWNlT3B0ICsgcmVNZXJpZGlhbiArICc/JywgJ2knKSxcbiAgICBuYW1lOiAnYmFja29mIHwgZnJvbnRvZicsXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKG1hdGNoLCBzaWRlLCBob3VycywgbWVyaWRpYW4pIHtcbiAgICAgIHZhciBiYWNrID0gc2lkZS50b0xvd2VyQ2FzZSgpID09PSAnYmFjayc7XG4gICAgICB2YXIgaG91ciA9ICtob3VycztcbiAgICAgIHZhciBtaW51dGUgPSAxNTtcblxuICAgICAgaWYgKCFiYWNrKSB7XG4gICAgICAgIGhvdXIgLT0gMTtcbiAgICAgICAgbWludXRlID0gNDU7XG4gICAgICB9XG5cbiAgICAgIGhvdXIgPSBwcm9jZXNzTWVyaWRpYW4oaG91ciwgbWVyaWRpYW4pO1xuXG4gICAgICByZXR1cm4gdGhpcy5yZXNldFRpbWUoKSAmJiB0aGlzLnRpbWUoaG91ciwgbWludXRlLCAwLCAwKTtcbiAgICB9XG4gIH0sXG5cbiAgd2Vla2RheU9mOiB7XG4gICAgcmVnZXg6IFJlZ0V4cCgnXignICsgcmVSZWx0ZXh0bnVtYmVyICsgJ3wnICsgcmVSZWx0ZXh0dGV4dCArICcpJyArIHJlU3BhY2UgKyAnKCcgKyByZURheWZ1bGwgKyAnfCcgKyByZURheWFiYnIgKyAnKScgKyByZVNwYWNlICsgJ29mJywgJ2knKSxcbiAgICBuYW1lOiAnd2Vla2RheW9mJ1xuICAgIC8vIHRvZG9cbiAgfSxcblxuICBtc3NxbHRpbWU6IHtcbiAgICByZWdleDogUmVnRXhwKCdeJyArIHJlSG91cjEyICsgJzonICsgcmVNaW51dGVseiArICc6JyArIHJlU2Vjb25kbHogKyAnWzouXShbMC05XSspJyArIHJlTWVyaWRpYW4sICdpJyksXG4gICAgbmFtZTogJ21zc3FsdGltZScsXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKG1hdGNoLCBob3VyLCBtaW51dGUsIHNlY29uZCwgZnJhYywgbWVyaWRpYW4pIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbWUocHJvY2Vzc01lcmlkaWFuKCtob3VyLCBtZXJpZGlhbiksICttaW51dGUsICtzZWNvbmQsICtmcmFjLnN1YnN0cigwLCAzKSk7XG4gICAgfVxuICB9LFxuXG4gIHRpbWVMb25nMTI6IHtcbiAgICByZWdleDogUmVnRXhwKCdeJyArIHJlSG91cjEyICsgJ1s6Ll0nICsgcmVNaW51dGUgKyAnWzouXScgKyByZVNlY29uZGx6ICsgcmVTcGFjZU9wdCArIHJlTWVyaWRpYW4sICdpJyksXG4gICAgbmFtZTogJ3RpbWVsb25nMTInLFxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjayhtYXRjaCwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1lcmlkaWFuKSB7XG4gICAgICByZXR1cm4gdGhpcy50aW1lKHByb2Nlc3NNZXJpZGlhbigraG91ciwgbWVyaWRpYW4pLCArbWludXRlLCArc2Vjb25kLCAwKTtcbiAgICB9XG4gIH0sXG5cbiAgdGltZVNob3J0MTI6IHtcbiAgICByZWdleDogUmVnRXhwKCdeJyArIHJlSG91cjEyICsgJ1s6Ll0nICsgcmVNaW51dGVseiArIHJlU3BhY2VPcHQgKyByZU1lcmlkaWFuLCAnaScpLFxuICAgIG5hbWU6ICd0aW1lc2hvcnQxMicsXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKG1hdGNoLCBob3VyLCBtaW51dGUsIG1lcmlkaWFuKSB7XG4gICAgICByZXR1cm4gdGhpcy50aW1lKHByb2Nlc3NNZXJpZGlhbigraG91ciwgbWVyaWRpYW4pLCArbWludXRlLCAwLCAwKTtcbiAgICB9XG4gIH0sXG5cbiAgdGltZVRpbnkxMjoge1xuICAgIHJlZ2V4OiBSZWdFeHAoJ14nICsgcmVIb3VyMTIgKyByZVNwYWNlT3B0ICsgcmVNZXJpZGlhbiwgJ2knKSxcbiAgICBuYW1lOiAndGltZXRpbnkxMicsXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKG1hdGNoLCBob3VyLCBtZXJpZGlhbikge1xuICAgICAgcmV0dXJuIHRoaXMudGltZShwcm9jZXNzTWVyaWRpYW4oK2hvdXIsIG1lcmlkaWFuKSwgMCwgMCwgMCk7XG4gICAgfVxuICB9LFxuXG4gIHNvYXA6IHtcbiAgICByZWdleDogUmVnRXhwKCdeJyArIHJlWWVhcjQgKyAnLScgKyByZU1vbnRobHogKyAnLScgKyByZURheWx6ICsgJ1QnICsgcmVIb3VyMjRseiArICc6JyArIHJlTWludXRlbHogKyAnOicgKyByZVNlY29uZGx6ICsgcmVGcmFjICsgcmVUekNvcnJlY3Rpb24gKyAnPycsICdpJyksXG4gICAgbmFtZTogJ3NvYXAnLFxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjayhtYXRjaCwgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIGZyYWMsIHR6Q29ycmVjdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMueW1kKCt5ZWFyLCBtb250aCAtIDEsICtkYXkpICYmIHRoaXMudGltZSgraG91ciwgK21pbnV0ZSwgK3NlY29uZCwgK2ZyYWMuc3Vic3RyKDAsIDMpKSAmJiB0aGlzLnpvbmUocHJvY2Vzc1R6Q29ycmVjdGlvbih0ekNvcnJlY3Rpb24pKTtcbiAgICB9XG4gIH0sXG5cbiAgd2RkeDoge1xuICAgIHJlZ2V4OiBSZWdFeHAoJ14nICsgcmVZZWFyNCArICctJyArIHJlTW9udGggKyAnLScgKyByZURheSArICdUJyArIHJlSG91cjI0ICsgJzonICsgcmVNaW51dGUgKyAnOicgKyByZVNlY29uZCksXG4gICAgbmFtZTogJ3dkZHgnLFxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjayhtYXRjaCwgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLnltZCgreWVhciwgbW9udGggLSAxLCArZGF5KSAmJiB0aGlzLnRpbWUoK2hvdXIsICttaW51dGUsICtzZWNvbmQsIDApO1xuICAgIH1cbiAgfSxcblxuICBleGlmOiB7XG4gICAgcmVnZXg6IFJlZ0V4cCgnXicgKyByZVllYXI0ICsgJzonICsgcmVNb250aGx6ICsgJzonICsgcmVEYXlseiArICcgJyArIHJlSG91cjI0bHogKyAnOicgKyByZU1pbnV0ZWx6ICsgJzonICsgcmVTZWNvbmRseiwgJ2knKSxcbiAgICBuYW1lOiAnZXhpZicsXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKG1hdGNoLCB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCkge1xuICAgICAgcmV0dXJuIHRoaXMueW1kKCt5ZWFyLCBtb250aCAtIDEsICtkYXkpICYmIHRoaXMudGltZSgraG91ciwgK21pbnV0ZSwgK3NlY29uZCwgMCk7XG4gICAgfVxuICB9LFxuXG4gIHhtbFJwYzoge1xuICAgIHJlZ2V4OiBSZWdFeHAoJ14nICsgcmVZZWFyNCArIHJlTW9udGhseiArIHJlRGF5bHogKyAnVCcgKyByZUhvdXIyNCArICc6JyArIHJlTWludXRlbHogKyAnOicgKyByZVNlY29uZGx6KSxcbiAgICBuYW1lOiAneG1scnBjJyxcbiAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2sobWF0Y2gsIHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kKSB7XG4gICAgICByZXR1cm4gdGhpcy55bWQoK3llYXIsIG1vbnRoIC0gMSwgK2RheSkgJiYgdGhpcy50aW1lKCtob3VyLCArbWludXRlLCArc2Vjb25kLCAwKTtcbiAgICB9XG4gIH0sXG5cbiAgeG1sUnBjTm9Db2xvbjoge1xuICAgIHJlZ2V4OiBSZWdFeHAoJ14nICsgcmVZZWFyNCArIHJlTW9udGhseiArIHJlRGF5bHogKyAnW1R0XScgKyByZUhvdXIyNCArIHJlTWludXRlbHogKyByZVNlY29uZGx6KSxcbiAgICBuYW1lOiAneG1scnBjbm9jb2xvbicsXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKG1hdGNoLCB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCkge1xuICAgICAgcmV0dXJuIHRoaXMueW1kKCt5ZWFyLCBtb250aCAtIDEsICtkYXkpICYmIHRoaXMudGltZSgraG91ciwgK21pbnV0ZSwgK3NlY29uZCwgMCk7XG4gICAgfVxuICB9LFxuXG4gIGNsZjoge1xuICAgIHJlZ2V4OiBSZWdFeHAoJ14nICsgcmVEYXkgKyAnLygnICsgcmVNb250aEFiYnIgKyAnKS8nICsgcmVZZWFyNCArICc6JyArIHJlSG91cjI0bHogKyAnOicgKyByZU1pbnV0ZWx6ICsgJzonICsgcmVTZWNvbmRseiArIHJlU3BhY2UgKyByZVR6Q29ycmVjdGlvbiwgJ2knKSxcbiAgICBuYW1lOiAnY2xmJyxcbiAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2sobWF0Y2gsIGRheSwgbW9udGgsIHllYXIsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCB0ekNvcnJlY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLnltZCgreWVhciwgbG9va3VwTW9udGgobW9udGgpLCArZGF5KSAmJiB0aGlzLnRpbWUoK2hvdXIsICttaW51dGUsICtzZWNvbmQsIDApICYmIHRoaXMuem9uZShwcm9jZXNzVHpDb3JyZWN0aW9uKHR6Q29ycmVjdGlvbikpO1xuICAgIH1cbiAgfSxcblxuICBpc284NjAxbG9uZzoge1xuICAgIHJlZ2V4OiBSZWdFeHAoJ150PycgKyByZUhvdXIyNCArICdbOi5dJyArIHJlTWludXRlICsgJ1s6Ll0nICsgcmVTZWNvbmQgKyByZUZyYWMsICdpJyksXG4gICAgbmFtZTogJ2lzbzg2MDFsb25nJyxcbiAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2sobWF0Y2gsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBmcmFjKSB7XG4gICAgICByZXR1cm4gdGhpcy50aW1lKCtob3VyLCArbWludXRlLCArc2Vjb25kLCArZnJhYy5zdWJzdHIoMCwgMykpO1xuICAgIH1cbiAgfSxcblxuICBkYXRlVGV4dHVhbDoge1xuICAgIHJlZ2V4OiBSZWdFeHAoJ14nICsgcmVNb250aFRleHQgKyAnWyAuXFxcXHQtXSonICsgcmVEYXkgKyAnWywuc3RuZHJoXFxcXHQgXSsnICsgcmVZZWFyLCAnaScpLFxuICAgIG5hbWU6ICdkYXRldGV4dHVhbCcsXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKG1hdGNoLCBtb250aCwgZGF5LCB5ZWFyKSB7XG4gICAgICByZXR1cm4gdGhpcy55bWQocHJvY2Vzc1llYXIoeWVhciksIGxvb2t1cE1vbnRoKG1vbnRoKSwgK2RheSk7XG4gICAgfVxuICB9LFxuXG4gIHBvaW50ZWREYXRlNDoge1xuICAgIHJlZ2V4OiBSZWdFeHAoJ14nICsgcmVEYXkgKyAnWy5cXFxcdC1dJyArIHJlTW9udGggKyAnWy4tXScgKyByZVllYXI0KSxcbiAgICBuYW1lOiAncG9pbnRlZGRhdGU0JyxcbiAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2sobWF0Y2gsIGRheSwgbW9udGgsIHllYXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnltZCgreWVhciwgbW9udGggLSAxLCArZGF5KTtcbiAgICB9XG4gIH0sXG5cbiAgcG9pbnRlZERhdGUyOiB7XG4gICAgcmVnZXg6IFJlZ0V4cCgnXicgKyByZURheSArICdbLlxcXFx0XScgKyByZU1vbnRoICsgJ1xcXFwuJyArIHJlWWVhcjIpLFxuICAgIG5hbWU6ICdwb2ludGVkZGF0ZTInLFxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjayhtYXRjaCwgZGF5LCBtb250aCwgeWVhcikge1xuICAgICAgcmV0dXJuIHRoaXMueW1kKHByb2Nlc3NZZWFyKHllYXIpLCBtb250aCAtIDEsICtkYXkpO1xuICAgIH1cbiAgfSxcblxuICB0aW1lTG9uZzI0OiB7XG4gICAgcmVnZXg6IFJlZ0V4cCgnXnQ/JyArIHJlSG91cjI0ICsgJ1s6Ll0nICsgcmVNaW51dGUgKyAnWzouXScgKyByZVNlY29uZCksXG4gICAgbmFtZTogJ3RpbWVsb25nMjQnLFxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjayhtYXRjaCwgaG91ciwgbWludXRlLCBzZWNvbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbWUoK2hvdXIsICttaW51dGUsICtzZWNvbmQsIDApO1xuICAgIH1cbiAgfSxcblxuICBkYXRlTm9Db2xvbjoge1xuICAgIHJlZ2V4OiBSZWdFeHAoJ14nICsgcmVZZWFyNCArIHJlTW9udGhseiArIHJlRGF5bHopLFxuICAgIG5hbWU6ICdkYXRlbm9jb2xvbicsXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKG1hdGNoLCB5ZWFyLCBtb250aCwgZGF5KSB7XG4gICAgICByZXR1cm4gdGhpcy55bWQoK3llYXIsIG1vbnRoIC0gMSwgK2RheSk7XG4gICAgfVxuICB9LFxuXG4gIHBneWRvdGQ6IHtcbiAgICByZWdleDogUmVnRXhwKCdeJyArIHJlWWVhcjQgKyAnXFxcXC4/JyArIHJlRGF5T2ZZZWFyKSxcbiAgICBuYW1lOiAncGd5ZG90ZCcsXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKG1hdGNoLCB5ZWFyLCBkYXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnltZCgreWVhciwgMCwgK2RheSk7XG4gICAgfVxuICB9LFxuXG4gIHRpbWVTaG9ydDI0OiB7XG4gICAgcmVnZXg6IFJlZ0V4cCgnXnQ/JyArIHJlSG91cjI0ICsgJ1s6Ll0nICsgcmVNaW51dGUsICdpJyksXG4gICAgbmFtZTogJ3RpbWVzaG9ydDI0JyxcbiAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2sobWF0Y2gsIGhvdXIsIG1pbnV0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudGltZSgraG91ciwgK21pbnV0ZSwgMCwgMCk7XG4gICAgfVxuICB9LFxuXG4gIGlzbzg2MDFub0NvbG9uOiB7XG4gICAgcmVnZXg6IFJlZ0V4cCgnXnQ/JyArIHJlSG91cjI0bHogKyByZU1pbnV0ZWx6ICsgcmVTZWNvbmRseiwgJ2knKSxcbiAgICBuYW1lOiAnaXNvODYwMW5vY29sb24nLFxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjayhtYXRjaCwgaG91ciwgbWludXRlLCBzZWNvbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbWUoK2hvdXIsICttaW51dGUsICtzZWNvbmQsIDApO1xuICAgIH1cbiAgfSxcblxuICBpc284NjAxZGF0ZVNsYXNoOiB7XG4gICAgLy8gZXZlbnRob3VnaCB0aGUgdHJhaWxpbmcgc2xhc2ggaXMgb3B0aW9uYWwgaW4gUEhQXG4gICAgLy8gaGVyZSBpdCdzIG1hbmRhdG9yeSBhbmQgaW5wdXRzIHdpdGhvdXQgdGhlIHNsYXNoXG4gICAgLy8gYXJlIGhhbmRsZWQgYnkgZGF0ZXNsYXNoXG4gICAgcmVnZXg6IFJlZ0V4cCgnXicgKyByZVllYXI0ICsgJy8nICsgcmVNb250aGx6ICsgJy8nICsgcmVEYXlseiArICcvJyksXG4gICAgbmFtZTogJ2lzbzg2MDFkYXRlc2xhc2gnLFxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjayhtYXRjaCwgeWVhciwgbW9udGgsIGRheSkge1xuICAgICAgcmV0dXJuIHRoaXMueW1kKCt5ZWFyLCBtb250aCAtIDEsICtkYXkpO1xuICAgIH1cbiAgfSxcblxuICBkYXRlU2xhc2g6IHtcbiAgICByZWdleDogUmVnRXhwKCdeJyArIHJlWWVhcjQgKyAnLycgKyByZU1vbnRoICsgJy8nICsgcmVEYXkpLFxuICAgIG5hbWU6ICdkYXRlc2xhc2gnLFxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjayhtYXRjaCwgeWVhciwgbW9udGgsIGRheSkge1xuICAgICAgcmV0dXJuIHRoaXMueW1kKCt5ZWFyLCBtb250aCAtIDEsICtkYXkpO1xuICAgIH1cbiAgfSxcblxuICBhbWVyaWNhbjoge1xuICAgIHJlZ2V4OiBSZWdFeHAoJ14nICsgcmVNb250aCArICcvJyArIHJlRGF5ICsgJy8nICsgcmVZZWFyKSxcbiAgICBuYW1lOiAnYW1lcmljYW4nLFxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjayhtYXRjaCwgbW9udGgsIGRheSwgeWVhcikge1xuICAgICAgcmV0dXJuIHRoaXMueW1kKHByb2Nlc3NZZWFyKHllYXIpLCBtb250aCAtIDEsICtkYXkpO1xuICAgIH1cbiAgfSxcblxuICBhbWVyaWNhblNob3J0OiB7XG4gICAgcmVnZXg6IFJlZ0V4cCgnXicgKyByZU1vbnRoICsgJy8nICsgcmVEYXkpLFxuICAgIG5hbWU6ICdhbWVyaWNhbnNob3J0JyxcbiAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2sobWF0Y2gsIG1vbnRoLCBkYXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnltZCh0aGlzLnksIG1vbnRoIC0gMSwgK2RheSk7XG4gICAgfVxuICB9LFxuXG4gIGdudURhdGVTaG9ydE9ySXNvODYwMWRhdGUyOiB7XG4gICAgLy8gaXNvODYwMWRhdGUyIGlzIGNvbXBsZXRlIHN1YnNldCBvZiBnbnVkYXRlc2hvcnRcbiAgICByZWdleDogUmVnRXhwKCdeJyArIHJlWWVhciArICctJyArIHJlTW9udGggKyAnLScgKyByZURheSksXG4gICAgbmFtZTogJ2dudWRhdGVzaG9ydCB8IGlzbzg2MDFkYXRlMicsXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKG1hdGNoLCB5ZWFyLCBtb250aCwgZGF5KSB7XG4gICAgICByZXR1cm4gdGhpcy55bWQocHJvY2Vzc1llYXIoeWVhciksIG1vbnRoIC0gMSwgK2RheSk7XG4gICAgfVxuICB9LFxuXG4gIGlzbzg2MDFkYXRlNDoge1xuICAgIHJlZ2V4OiBSZWdFeHAoJ14nICsgcmVZZWFyNHdpdGhTaWduICsgJy0nICsgcmVNb250aGx6ICsgJy0nICsgcmVEYXlseiksXG4gICAgbmFtZTogJ2lzbzg2MDFkYXRlNCcsXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKG1hdGNoLCB5ZWFyLCBtb250aCwgZGF5KSB7XG4gICAgICByZXR1cm4gdGhpcy55bWQoK3llYXIsIG1vbnRoIC0gMSwgK2RheSk7XG4gICAgfVxuICB9LFxuXG4gIGdudU5vQ29sb246IHtcbiAgICByZWdleDogUmVnRXhwKCdedCcgKyByZUhvdXIyNGx6ICsgcmVNaW51dGVseiwgJ2knKSxcbiAgICBuYW1lOiAnZ251bm9jb2xvbicsXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKG1hdGNoLCBob3VyLCBtaW51dGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbWUoK2hvdXIsICttaW51dGUsIDAsIHRoaXMuZik7XG4gICAgfVxuICB9LFxuXG4gIGdudURhdGVTaG9ydGVyOiB7XG4gICAgcmVnZXg6IFJlZ0V4cCgnXicgKyByZVllYXI0ICsgJy0nICsgcmVNb250aCksXG4gICAgbmFtZTogJ2dudWRhdGVzaG9ydGVyJyxcbiAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2sobWF0Y2gsIHllYXIsIG1vbnRoKSB7XG4gICAgICByZXR1cm4gdGhpcy55bWQoK3llYXIsIG1vbnRoIC0gMSwgMSk7XG4gICAgfVxuICB9LFxuXG4gIHBnVGV4dFJldmVyc2U6IHtcbiAgICAvLyBub3RlOiBhbGxvd2VkIHllYXJzIGFyZSBmcm9tIDMyLTk5OTlcbiAgICAvLyB5ZWFycyBiZWxvdyAzMiBzaG91bGQgYmUgdHJlYXRlZCBhcyBkYXlzIGluIGRhdGVmdWxsXG4gICAgcmVnZXg6IFJlZ0V4cCgnXicgKyAnKFxcXFxkezMsNH18WzQtOV1cXFxcZHwzWzItOV0pLSgnICsgcmVNb250aEFiYnIgKyAnKS0nICsgcmVEYXlseiwgJ2knKSxcbiAgICBuYW1lOiAncGd0ZXh0cmV2ZXJzZScsXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKG1hdGNoLCB5ZWFyLCBtb250aCwgZGF5KSB7XG4gICAgICByZXR1cm4gdGhpcy55bWQocHJvY2Vzc1llYXIoeWVhciksIGxvb2t1cE1vbnRoKG1vbnRoKSwgK2RheSk7XG4gICAgfVxuICB9LFxuXG4gIGRhdGVGdWxsOiB7XG4gICAgcmVnZXg6IFJlZ0V4cCgnXicgKyByZURheSArICdbIFxcXFx0Li1dKicgKyByZU1vbnRoVGV4dCArICdbIFxcXFx0Li1dKicgKyByZVllYXIsICdpJyksXG4gICAgbmFtZTogJ2RhdGVmdWxsJyxcbiAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2sobWF0Y2gsIGRheSwgbW9udGgsIHllYXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnltZChwcm9jZXNzWWVhcih5ZWFyKSwgbG9va3VwTW9udGgobW9udGgpLCArZGF5KTtcbiAgICB9XG4gIH0sXG5cbiAgZGF0ZU5vRGF5OiB7XG4gICAgcmVnZXg6IFJlZ0V4cCgnXicgKyByZU1vbnRoVGV4dCArICdbIC5cXFxcdC1dKicgKyByZVllYXI0LCAnaScpLFxuICAgIG5hbWU6ICdkYXRlbm9kYXknLFxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjayhtYXRjaCwgbW9udGgsIHllYXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnltZCgreWVhciwgbG9va3VwTW9udGgobW9udGgpLCAxKTtcbiAgICB9XG4gIH0sXG5cbiAgZGF0ZU5vRGF5UmV2OiB7XG4gICAgcmVnZXg6IFJlZ0V4cCgnXicgKyByZVllYXI0ICsgJ1sgLlxcXFx0LV0qJyArIHJlTW9udGhUZXh0LCAnaScpLFxuICAgIG5hbWU6ICdkYXRlbm9kYXlyZXYnLFxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjayhtYXRjaCwgeWVhciwgbW9udGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnltZCgreWVhciwgbG9va3VwTW9udGgobW9udGgpLCAxKTtcbiAgICB9XG4gIH0sXG5cbiAgcGdUZXh0U2hvcnQ6IHtcbiAgICByZWdleDogUmVnRXhwKCdeKCcgKyByZU1vbnRoQWJiciArICcpLScgKyByZURheWx6ICsgJy0nICsgcmVZZWFyLCAnaScpLFxuICAgIG5hbWU6ICdwZ3RleHRzaG9ydCcsXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKG1hdGNoLCBtb250aCwgZGF5LCB5ZWFyKSB7XG4gICAgICByZXR1cm4gdGhpcy55bWQocHJvY2Vzc1llYXIoeWVhciksIGxvb2t1cE1vbnRoKG1vbnRoKSwgK2RheSk7XG4gICAgfVxuICB9LFxuXG4gIGRhdGVOb1llYXI6IHtcbiAgICByZWdleDogUmVnRXhwKCdeJyArIHJlTW9udGhUZXh0ICsgJ1sgLlxcXFx0LV0qJyArIHJlRGF5ICsgJ1ssLnN0bmRyaFxcXFx0IF0qJywgJ2knKSxcbiAgICBuYW1lOiAnZGF0ZW5veWVhcicsXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKG1hdGNoLCBtb250aCwgZGF5KSB7XG4gICAgICByZXR1cm4gdGhpcy55bWQodGhpcy55LCBsb29rdXBNb250aChtb250aCksICtkYXkpO1xuICAgIH1cbiAgfSxcblxuICBkYXRlTm9ZZWFyUmV2OiB7XG4gICAgcmVnZXg6IFJlZ0V4cCgnXicgKyByZURheSArICdbIC5cXFxcdC1dKicgKyByZU1vbnRoVGV4dCwgJ2knKSxcbiAgICBuYW1lOiAnZGF0ZW5veWVhcnJldicsXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKG1hdGNoLCBkYXksIG1vbnRoKSB7XG4gICAgICByZXR1cm4gdGhpcy55bWQodGhpcy55LCBsb29rdXBNb250aChtb250aCksICtkYXkpO1xuICAgIH1cbiAgfSxcblxuICBpc29XZWVrRGF5OiB7XG4gICAgcmVnZXg6IFJlZ0V4cCgnXicgKyByZVllYXI0ICsgJy0/VycgKyByZVdlZWtPZlllYXIgKyAnKD86LT8oWzAtN10pKT8nKSxcbiAgICBuYW1lOiAnaXNvd2Vla2RheSB8IGlzb3dlZWsnLFxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjayhtYXRjaCwgeWVhciwgd2VlaywgZGF5KSB7XG4gICAgICBkYXkgPSBkYXkgPyArZGF5IDogMTtcblxuICAgICAgaWYgKCF0aGlzLnltZCgreWVhciwgMCwgMSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBnZXQgZGF5IG9mIHdlZWsgZm9yIEphbiAxc3RcbiAgICAgIHZhciBkYXlPZldlZWsgPSBuZXcgRGF0ZSh0aGlzLnksIHRoaXMubSwgdGhpcy5kKS5nZXREYXkoKTtcblxuICAgICAgLy8gYW5kIHVzZSB0aGUgZGF5IHRvIGZpZ3VyZSBvdXQgdGhlIG9mZnNldCBmb3IgZGF5IDEgb2Ygd2VlayAxXG4gICAgICBkYXlPZldlZWsgPSAwIC0gKGRheU9mV2VlayA+IDQgPyBkYXlPZldlZWsgLSA3IDogZGF5T2ZXZWVrKTtcblxuICAgICAgdGhpcy5yZCArPSBkYXlPZldlZWsgKyAod2VlayAtIDEpICogNyArIGRheTtcbiAgICB9XG4gIH0sXG5cbiAgcmVsYXRpdmVUZXh0OiB7XG4gICAgcmVnZXg6IFJlZ0V4cCgnXignICsgcmVSZWx0ZXh0bnVtYmVyICsgJ3wnICsgcmVSZWx0ZXh0dGV4dCArICcpJyArIHJlU3BhY2UgKyAnKCcgKyByZVJlbHRleHR1bml0ICsgJyknLCAnaScpLFxuICAgIG5hbWU6ICdyZWxhdGl2ZXRleHQnLFxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjayhtYXRjaCwgcmVsVmFsdWUsIHJlbFVuaXQpIHtcbiAgICAgIC8vIHRvZG86IGltcGxlbWVudCBoYW5kbGluZyBvZiAndGhpcyB0aW1lLXVuaXQnXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHZhciBfbG9va3VwUmVsYXRpdmUgPSBsb29rdXBSZWxhdGl2ZShyZWxWYWx1ZSksXG4gICAgICAgICAgYW1vdW50ID0gX2xvb2t1cFJlbGF0aXZlLmFtb3VudCxcbiAgICAgICAgICBiZWhhdmlvciA9IF9sb29rdXBSZWxhdGl2ZS5iZWhhdmlvcjtcblxuICAgICAgc3dpdGNoIChyZWxVbml0LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnc2VjJzpcbiAgICAgICAgY2FzZSAnc2Vjcyc6XG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgICAgICAgIHRoaXMucnMgKz0gYW1vdW50O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtaW4nOlxuICAgICAgICBjYXNlICdtaW5zJzpcbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgY2FzZSAnbWludXRlcyc6XG4gICAgICAgICAgdGhpcy5yaSArPSBhbW91bnQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICBjYXNlICdob3Vycyc6XG4gICAgICAgICAgdGhpcy5yaCArPSBhbW91bnQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgIGNhc2UgJ2RheXMnOlxuICAgICAgICAgIHRoaXMucmQgKz0gYW1vdW50O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmb3J0bmlnaHQnOlxuICAgICAgICBjYXNlICdmb3J0bmlnaHRzJzpcbiAgICAgICAgY2FzZSAnZm9ydGhuaWdodCc6XG4gICAgICAgIGNhc2UgJ2ZvcnRobmlnaHRzJzpcbiAgICAgICAgICB0aGlzLnJkICs9IGFtb3VudCAqIDE0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgY2FzZSAnd2Vla3MnOlxuICAgICAgICAgIHRoaXMucmQgKz0gYW1vdW50ICogNztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICBjYXNlICdtb250aHMnOlxuICAgICAgICAgIHRoaXMucm0gKz0gYW1vdW50O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgY2FzZSAneWVhcnMnOlxuICAgICAgICAgIHRoaXMucnkgKz0gYW1vdW50O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtb24nOmNhc2UgJ21vbmRheSc6XG4gICAgICAgIGNhc2UgJ3R1ZSc6Y2FzZSAndHVlc2RheSc6XG4gICAgICAgIGNhc2UgJ3dlZCc6Y2FzZSAnd2VkbmVzZGF5JzpcbiAgICAgICAgY2FzZSAndGh1JzpjYXNlICd0aHVyc2RheSc6XG4gICAgICAgIGNhc2UgJ2ZyaSc6Y2FzZSAnZnJpZGF5JzpcbiAgICAgICAgY2FzZSAnc2F0JzpjYXNlICdzYXR1cmRheSc6XG4gICAgICAgIGNhc2UgJ3N1bic6Y2FzZSAnc3VuZGF5JzpcbiAgICAgICAgICB0aGlzLnJlc2V0VGltZSgpO1xuICAgICAgICAgIHRoaXMud2Vla2RheSA9IGxvb2t1cFdlZWtkYXkocmVsVW5pdCwgNyk7XG4gICAgICAgICAgdGhpcy53ZWVrZGF5QmVoYXZpb3IgPSAxO1xuICAgICAgICAgIHRoaXMucmQgKz0gKGFtb3VudCA+IDAgPyBhbW91bnQgLSAxIDogYW1vdW50KSAqIDc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3dlZWtkYXknOlxuICAgICAgICBjYXNlICd3ZWVrZGF5cyc6XG4gICAgICAgICAgLy8gdG9kb1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICByZWxhdGl2ZToge1xuICAgIHJlZ2V4OiBSZWdFeHAoJ14oWystXSopWyBcXFxcdF0qKFxcXFxkKyknICsgcmVTcGFjZU9wdCArICcoJyArIHJlUmVsdGV4dHVuaXQgKyAnfHdlZWspJywgJ2knKSxcbiAgICBuYW1lOiAncmVsYXRpdmUnLFxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjayhtYXRjaCwgc2lnbnMsIHJlbFZhbHVlLCByZWxVbml0KSB7XG4gICAgICB2YXIgbWludXNlcyA9IHNpZ25zLnJlcGxhY2UoL1teLV0vZywgJycpLmxlbmd0aDtcblxuICAgICAgdmFyIGFtb3VudCA9ICtyZWxWYWx1ZSAqIE1hdGgucG93KC0xLCBtaW51c2VzKTtcblxuICAgICAgc3dpdGNoIChyZWxVbml0LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnc2VjJzpcbiAgICAgICAgY2FzZSAnc2Vjcyc6XG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgICAgICAgIHRoaXMucnMgKz0gYW1vdW50O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtaW4nOlxuICAgICAgICBjYXNlICdtaW5zJzpcbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgY2FzZSAnbWludXRlcyc6XG4gICAgICAgICAgdGhpcy5yaSArPSBhbW91bnQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICBjYXNlICdob3Vycyc6XG4gICAgICAgICAgdGhpcy5yaCArPSBhbW91bnQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgIGNhc2UgJ2RheXMnOlxuICAgICAgICAgIHRoaXMucmQgKz0gYW1vdW50O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmb3J0bmlnaHQnOlxuICAgICAgICBjYXNlICdmb3J0bmlnaHRzJzpcbiAgICAgICAgY2FzZSAnZm9ydGhuaWdodCc6XG4gICAgICAgIGNhc2UgJ2ZvcnRobmlnaHRzJzpcbiAgICAgICAgICB0aGlzLnJkICs9IGFtb3VudCAqIDE0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgY2FzZSAnd2Vla3MnOlxuICAgICAgICAgIHRoaXMucmQgKz0gYW1vdW50ICogNztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICBjYXNlICdtb250aHMnOlxuICAgICAgICAgIHRoaXMucm0gKz0gYW1vdW50O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgY2FzZSAneWVhcnMnOlxuICAgICAgICAgIHRoaXMucnkgKz0gYW1vdW50O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtb24nOmNhc2UgJ21vbmRheSc6XG4gICAgICAgIGNhc2UgJ3R1ZSc6Y2FzZSAndHVlc2RheSc6XG4gICAgICAgIGNhc2UgJ3dlZCc6Y2FzZSAnd2VkbmVzZGF5JzpcbiAgICAgICAgY2FzZSAndGh1JzpjYXNlICd0aHVyc2RheSc6XG4gICAgICAgIGNhc2UgJ2ZyaSc6Y2FzZSAnZnJpZGF5JzpcbiAgICAgICAgY2FzZSAnc2F0JzpjYXNlICdzYXR1cmRheSc6XG4gICAgICAgIGNhc2UgJ3N1bic6Y2FzZSAnc3VuZGF5JzpcbiAgICAgICAgICB0aGlzLnJlc2V0VGltZSgpO1xuICAgICAgICAgIHRoaXMud2Vla2RheSA9IGxvb2t1cFdlZWtkYXkocmVsVW5pdCwgNyk7XG4gICAgICAgICAgdGhpcy53ZWVrZGF5QmVoYXZpb3IgPSAxO1xuICAgICAgICAgIHRoaXMucmQgKz0gKGFtb3VudCA+IDAgPyBhbW91bnQgLSAxIDogYW1vdW50KSAqIDc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3dlZWtkYXknOlxuICAgICAgICBjYXNlICd3ZWVrZGF5cyc6XG4gICAgICAgICAgLy8gdG9kb1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkYXlUZXh0OiB7XG4gICAgcmVnZXg6IFJlZ0V4cCgnXignICsgcmVEYXl0ZXh0ICsgJyknLCAnaScpLFxuICAgIG5hbWU6ICdkYXl0ZXh0JyxcbiAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2sobWF0Y2gsIGRheVRleHQpIHtcbiAgICAgIHRoaXMucmVzZXRUaW1lKCk7XG4gICAgICB0aGlzLndlZWtkYXkgPSBsb29rdXBXZWVrZGF5KGRheVRleHQsIDApO1xuXG4gICAgICBpZiAodGhpcy53ZWVrZGF5QmVoYXZpb3IgIT09IDIpIHtcbiAgICAgICAgdGhpcy53ZWVrZGF5QmVoYXZpb3IgPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICByZWxhdGl2ZVRleHRXZWVrOiB7XG4gICAgcmVnZXg6IFJlZ0V4cCgnXignICsgcmVSZWx0ZXh0dGV4dCArICcpJyArIHJlU3BhY2UgKyAnd2VlaycsICdpJyksXG4gICAgbmFtZTogJ3JlbGF0aXZldGV4dHdlZWsnLFxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjayhtYXRjaCwgcmVsVGV4dCkge1xuICAgICAgdGhpcy53ZWVrZGF5QmVoYXZpb3IgPSAyO1xuXG4gICAgICBzd2l0Y2ggKHJlbFRleHQudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBjYXNlICd0aGlzJzpcbiAgICAgICAgICB0aGlzLnJkICs9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ25leHQnOlxuICAgICAgICAgIHRoaXMucmQgKz0gNztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGFzdCc6XG4gICAgICAgIGNhc2UgJ3ByZXZpb3VzJzpcbiAgICAgICAgICB0aGlzLnJkIC09IDc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc05hTih0aGlzLndlZWtkYXkpKSB7XG4gICAgICAgIHRoaXMud2Vla2RheSA9IDE7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIG1vbnRoRnVsbE9yTW9udGhBYmJyOiB7XG4gICAgcmVnZXg6IFJlZ0V4cCgnXignICsgcmVNb250aEZ1bGwgKyAnfCcgKyByZU1vbnRoQWJiciArICcpJywgJ2knKSxcbiAgICBuYW1lOiAnbW9udGhmdWxsIHwgbW9udGhhYmJyJyxcbiAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2sobWF0Y2gsIG1vbnRoKSB7XG4gICAgICByZXR1cm4gdGhpcy55bWQodGhpcy55LCBsb29rdXBNb250aChtb250aCksIHRoaXMuZCk7XG4gICAgfVxuICB9LFxuXG4gIHR6Q29ycmVjdGlvbjoge1xuICAgIHJlZ2V4OiBSZWdFeHAoJ14nICsgcmVUekNvcnJlY3Rpb24sICdpJyksXG4gICAgbmFtZTogJ3R6Y29ycmVjdGlvbicsXG4gICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKHR6Q29ycmVjdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuem9uZShwcm9jZXNzVHpDb3JyZWN0aW9uKHR6Q29ycmVjdGlvbikpO1xuICAgIH1cbiAgfSxcblxuICBhZ286IHtcbiAgICByZWdleDogL15hZ28vaSxcbiAgICBuYW1lOiAnYWdvJyxcbiAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2soKSB7XG4gICAgICB0aGlzLnJ5ID0gLXRoaXMucnk7XG4gICAgICB0aGlzLnJtID0gLXRoaXMucm07XG4gICAgICB0aGlzLnJkID0gLXRoaXMucmQ7XG4gICAgICB0aGlzLnJoID0gLXRoaXMucmg7XG4gICAgICB0aGlzLnJpID0gLXRoaXMucmk7XG4gICAgICB0aGlzLnJzID0gLXRoaXMucnM7XG4gICAgICB0aGlzLnJmID0gLXRoaXMucmY7XG4gICAgfVxuICB9LFxuXG4gIGdudU5vQ29sb24yOiB7XG4gICAgLy8gc2Vjb25kIGluc3RhbmNlIG9mIGdudW5vY29sb24sIHdpdGhvdXQgbGVhZGluZyAndCdcbiAgICAvLyBpdCdzIGRvd24gaGVyZSwgYmVjYXVzZSBpdCBpcyB2ZXJ5IGdlbmVyaWMgKDQgZGlnaXRzIGluIGEgcm93KVxuICAgIC8vIHRodXMgY29uZmxpY3RzIHdpdGggbWFueSBydWxlcyBhYm92ZVxuICAgIC8vIG9ubHkgeWVhcjQgc2hvdWxkIGNvbWUgYWZ0ZXJ3YXJkc1xuICAgIHJlZ2V4OiBSZWdFeHAoJ14nICsgcmVIb3VyMjRseiArIHJlTWludXRlbHosICdpJyksXG4gICAgbmFtZTogJ2dudW5vY29sb24nLFxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjayhtYXRjaCwgaG91ciwgbWludXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy50aW1lKCtob3VyLCArbWludXRlLCAwLCB0aGlzLmYpO1xuICAgIH1cbiAgfSxcblxuICB5ZWFyNDoge1xuICAgIHJlZ2V4OiBSZWdFeHAoJ14nICsgcmVZZWFyNCksXG4gICAgbmFtZTogJ3llYXI0JyxcbiAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2sobWF0Y2gsIHllYXIpIHtcbiAgICAgIHRoaXMueSA9ICt5ZWFyO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LFxuXG4gIHdoaXRlc3BhY2U6IHtcbiAgICByZWdleDogL15bIC4sXFx0XSsvLFxuICAgIG5hbWU6ICd3aGl0ZXNwYWNlJ1xuICAgIC8vIGRvIG5vdGhpbmdcbiAgfSxcblxuICBhbnk6IHtcbiAgICByZWdleDogL15bXFxzXFxTXSsvLFxuICAgIG5hbWU6ICdhbnknLFxuICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjaygpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciByZXN1bHRQcm90byA9IHtcbiAgLy8gZGF0ZVxuICB5OiBOYU4sXG4gIG06IE5hTixcbiAgZDogTmFOLFxuICAvLyB0aW1lXG4gIGg6IE5hTixcbiAgaTogTmFOLFxuICBzOiBOYU4sXG4gIGY6IE5hTixcblxuICAvLyByZWxhdGl2ZSBzaGlmdHNcbiAgcnk6IDAsXG4gIHJtOiAwLFxuICByZDogMCxcbiAgcmg6IDAsXG4gIHJpOiAwLFxuICByczogMCxcbiAgcmY6IDAsXG5cbiAgLy8gd2Vla2RheSByZWxhdGVkIHNoaWZ0c1xuICB3ZWVrZGF5OiBOYU4sXG4gIHdlZWtkYXlCZWhhdmlvcjogMCxcblxuICAvLyBmaXJzdCBvciBsYXN0IGRheSBvZiBtb250aFxuICAvLyAwIG5vbmUsIDEgZmlyc3QsIC0xIGxhc3RcbiAgZmlyc3RPckxhc3REYXlPZk1vbnRoOiAwLFxuXG4gIC8vIHRpbWV6b25lIGNvcnJlY3Rpb24gaW4gbWludXRlc1xuICB6OiBOYU4sXG5cbiAgLy8gY291bnRlcnNcbiAgZGF0ZXM6IDAsXG4gIHRpbWVzOiAwLFxuICB6b25lczogMCxcblxuICAvLyBoZWxwZXIgZnVuY3Rpb25zXG4gIHltZDogZnVuY3Rpb24geW1kKHksIG0sIGQpIHtcbiAgICBpZiAodGhpcy5kYXRlcyA+IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGVzKys7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLm0gPSBtO1xuICAgIHRoaXMuZCA9IGQ7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIHRpbWU6IGZ1bmN0aW9uIHRpbWUoaCwgaSwgcywgZikge1xuICAgIGlmICh0aGlzLnRpbWVzID4gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMudGltZXMrKztcbiAgICB0aGlzLmggPSBoO1xuICAgIHRoaXMuaSA9IGk7XG4gICAgdGhpcy5zID0gcztcbiAgICB0aGlzLmYgPSBmO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIHJlc2V0VGltZTogZnVuY3Rpb24gcmVzZXRUaW1lKCkge1xuICAgIHRoaXMuaCA9IDA7XG4gICAgdGhpcy5pID0gMDtcbiAgICB0aGlzLnMgPSAwO1xuICAgIHRoaXMuZiA9IDA7XG4gICAgdGhpcy50aW1lcyA9IDA7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgem9uZTogZnVuY3Rpb24gem9uZShtaW51dGVzKSB7XG4gICAgaWYgKHRoaXMuem9uZXMgPD0gMSkge1xuICAgICAgdGhpcy56b25lcysrO1xuICAgICAgdGhpcy56ID0gbWludXRlcztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgdG9EYXRlOiBmdW5jdGlvbiB0b0RhdGUocmVsYXRpdmVUbykge1xuICAgIGlmICh0aGlzLmRhdGVzICYmICF0aGlzLnRpbWVzKSB7XG4gICAgICB0aGlzLmggPSB0aGlzLmkgPSB0aGlzLnMgPSB0aGlzLmYgPSAwO1xuICAgIH1cblxuICAgIC8vIGZpbGwgaG9sZXNcbiAgICBpZiAoaXNOYU4odGhpcy55KSkge1xuICAgICAgdGhpcy55ID0gcmVsYXRpdmVUby5nZXRGdWxsWWVhcigpO1xuICAgIH1cblxuICAgIGlmIChpc05hTih0aGlzLm0pKSB7XG4gICAgICB0aGlzLm0gPSByZWxhdGl2ZVRvLmdldE1vbnRoKCk7XG4gICAgfVxuXG4gICAgaWYgKGlzTmFOKHRoaXMuZCkpIHtcbiAgICAgIHRoaXMuZCA9IHJlbGF0aXZlVG8uZ2V0RGF0ZSgpO1xuICAgIH1cblxuICAgIGlmIChpc05hTih0aGlzLmgpKSB7XG4gICAgICB0aGlzLmggPSByZWxhdGl2ZVRvLmdldEhvdXJzKCk7XG4gICAgfVxuXG4gICAgaWYgKGlzTmFOKHRoaXMuaSkpIHtcbiAgICAgIHRoaXMuaSA9IHJlbGF0aXZlVG8uZ2V0TWludXRlcygpO1xuICAgIH1cblxuICAgIGlmIChpc05hTih0aGlzLnMpKSB7XG4gICAgICB0aGlzLnMgPSByZWxhdGl2ZVRvLmdldFNlY29uZHMoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNOYU4odGhpcy5mKSkge1xuICAgICAgdGhpcy5mID0gcmVsYXRpdmVUby5nZXRNaWxsaXNlY29uZHMoKTtcbiAgICB9XG5cbiAgICAvLyBhZGp1c3Qgc3BlY2lhbCBlYXJseVxuICAgIHN3aXRjaCAodGhpcy5maXJzdE9yTGFzdERheU9mTW9udGgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgdGhpcy5kID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIC0xOlxuICAgICAgICB0aGlzLmQgPSAwO1xuICAgICAgICB0aGlzLm0gKz0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKCFpc05hTih0aGlzLndlZWtkYXkpKSB7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHJlbGF0aXZlVG8uZ2V0VGltZSgpKTtcbiAgICAgIGRhdGUuc2V0RnVsbFllYXIodGhpcy55LCB0aGlzLm0sIHRoaXMuZCk7XG4gICAgICBkYXRlLnNldEhvdXJzKHRoaXMuaCwgdGhpcy5pLCB0aGlzLnMsIHRoaXMuZik7XG5cbiAgICAgIHZhciBkb3cgPSBkYXRlLmdldERheSgpO1xuXG4gICAgICBpZiAodGhpcy53ZWVrZGF5QmVoYXZpb3IgPT09IDIpIHtcbiAgICAgICAgLy8gVG8gbWFrZSBcInRoaXMgd2Vla1wiIHdvcmssIHdoZXJlIHRoZSBjdXJyZW50IGRheSBvZiB3ZWVrIGlzIGEgXCJzdW5kYXlcIlxuICAgICAgICBpZiAoZG93ID09PSAwICYmIHRoaXMud2Vla2RheSAhPT0gMCkge1xuICAgICAgICAgIHRoaXMud2Vla2RheSA9IC02O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVG8gbWFrZSBcInN1bmRheSB0aGlzIHdlZWtcIiB3b3JrLCB3aGVyZSB0aGUgY3VycmVudCBkYXkgb2Ygd2VlayBpcyBub3QgYSBcInN1bmRheVwiXG4gICAgICAgIGlmICh0aGlzLndlZWtkYXkgPT09IDAgJiYgZG93ICE9PSAwKSB7XG4gICAgICAgICAgdGhpcy53ZWVrZGF5ID0gNztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZCAtPSBkb3c7XG4gICAgICAgIHRoaXMuZCArPSB0aGlzLndlZWtkYXk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGlmZiA9IHRoaXMud2Vla2RheSAtIGRvdztcblxuICAgICAgICAvLyBzb21lIFBIUCBtYWdpY1xuICAgICAgICBpZiAodGhpcy5yZCA8IDAgJiYgZGlmZiA8IDAgfHwgdGhpcy5yZCA+PSAwICYmIGRpZmYgPD0gLXRoaXMud2Vla2RheUJlaGF2aW9yKSB7XG4gICAgICAgICAgZGlmZiArPSA3O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMud2Vla2RheSA+PSAwKSB7XG4gICAgICAgICAgdGhpcy5kICs9IGRpZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kIC09IDcgLSAoTWF0aC5hYnModGhpcy53ZWVrZGF5KSAtIGRvdyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLndlZWtkYXkgPSBOYU47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IHJlbGF0aXZlXG4gICAgdGhpcy55ICs9IHRoaXMucnk7XG4gICAgdGhpcy5tICs9IHRoaXMucm07XG4gICAgdGhpcy5kICs9IHRoaXMucmQ7XG5cbiAgICB0aGlzLmggKz0gdGhpcy5yaDtcbiAgICB0aGlzLmkgKz0gdGhpcy5yaTtcbiAgICB0aGlzLnMgKz0gdGhpcy5ycztcbiAgICB0aGlzLmYgKz0gdGhpcy5yZjtcblxuICAgIHRoaXMucnkgPSB0aGlzLnJtID0gdGhpcy5yZCA9IDA7XG4gICAgdGhpcy5yaCA9IHRoaXMucmkgPSB0aGlzLnJzID0gdGhpcy5yZiA9IDA7XG5cbiAgICB2YXIgcmVzdWx0ID0gbmV3IERhdGUocmVsYXRpdmVUby5nZXRUaW1lKCkpO1xuICAgIC8vIHNpbmNlIERhdGUgY29uc3RydWN0b3IgdHJlYXRzIHllYXJzIDw9IDk5IGFzIDE5MDArXG4gICAgLy8gaXQgY2FuJ3QgYmUgdXNlZCwgdGh1cyB0aGlzIHdlaXJkIHdheVxuICAgIHJlc3VsdC5zZXRGdWxsWWVhcih0aGlzLnksIHRoaXMubSwgdGhpcy5kKTtcbiAgICByZXN1bHQuc2V0SG91cnModGhpcy5oLCB0aGlzLmksIHRoaXMucywgdGhpcy5mKTtcblxuICAgIC8vIG5vdGU6IHRoaXMgaXMgZG9uZSB0d2ljZSBpbiBQSFBcbiAgICAvLyBlYXJseSB3aGVuIHByb2Nlc3Npbmcgc3BlY2lhbCByZWxhdGl2ZXNcbiAgICAvLyBhbmQgbGF0ZVxuICAgIC8vIHRvZG86IGNoZWNrIGlmIHRoZSBsb2dpYyBjYW4gYmUgcmVkdWNlZFxuICAgIC8vIHRvIGp1c3Qgb25lIHRpbWUgYWN0aW9uXG4gICAgc3dpdGNoICh0aGlzLmZpcnN0T3JMYXN0RGF5T2ZNb250aCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXN1bHQuc2V0RGF0ZSgxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIC0xOlxuICAgICAgICByZXN1bHQuc2V0TW9udGgocmVzdWx0LmdldE1vbnRoKCkgKyAxLCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IHRpbWV6b25lXG4gICAgaWYgKCFpc05hTih0aGlzLnopICYmIHJlc3VsdC5nZXRUaW1lem9uZU9mZnNldCgpICE9PSB0aGlzLnopIHtcbiAgICAgIHJlc3VsdC5zZXRVVENGdWxsWWVhcihyZXN1bHQuZ2V0RnVsbFllYXIoKSwgcmVzdWx0LmdldE1vbnRoKCksIHJlc3VsdC5nZXREYXRlKCkpO1xuXG4gICAgICByZXN1bHQuc2V0VVRDSG91cnMocmVzdWx0LmdldEhvdXJzKCksIHJlc3VsdC5nZXRNaW51dGVzKCkgKyB0aGlzLnosIHJlc3VsdC5nZXRTZWNvbmRzKCksIHJlc3VsdC5nZXRNaWxsaXNlY29uZHMoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdHJ0b3RpbWUoc3RyLCBub3cpIHtcbiAgLy8gICAgICAgZGlzY3VzcyBhdDogaHR0cDovL2xvY3V0dXMuaW8vcGhwL3N0cnRvdGltZS9cbiAgLy8gICAgICBvcmlnaW5hbCBieTogQ2FpbyBBcmllZGUgKGh0dHA6Ly9jYWlvYXJpZWRlLmNvbSlcbiAgLy8gICAgICBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2t2ei5pbylcbiAgLy8gICAgICBpbXByb3ZlZCBieTogQ2FpbyBBcmllZGUgKGh0dHA6Ly9jYWlvYXJpZWRlLmNvbSlcbiAgLy8gICAgICBpbXByb3ZlZCBieTogQS4gTWF0w61hcyBRdWV6YWRhIChodHRwOi8vYW1hdGlhc3EuY29tKVxuICAvLyAgICAgIGltcHJvdmVkIGJ5OiBwcmV1dGVyXG4gIC8vICAgICAgaW1wcm92ZWQgYnk6IEJyZXR0IFphbWlyIChodHRwOi8vYnJldHQtemFtaXIubWUpXG4gIC8vICAgICAgaW1wcm92ZWQgYnk6IE1pcmtvIEZhYmVyXG4gIC8vICAgICAgICAgaW5wdXQgYnk6IERhdmlkXG4gIC8vICAgICAgYnVnZml4ZWQgYnk6IFdhZ25lciBCLiBTb2FyZXNcbiAgLy8gICAgICBidWdmaXhlZCBieTogQXJ0dXIgVGNoZXJueWNoZXZcbiAgLy8gICAgICBidWdmaXhlZCBieTogU3RlcGhhbiBCw7ZzY2gtUGxlcGVsaXRzIChodHRwOi8vZ2l0aHViLmNvbS9wbGVwZSlcbiAgLy8gcmVpbXBsZW1lbnRlZCBieTogUmFmYcWCIEt1a2F3c2tpXG4gIC8vICAgICAgICAgICBub3RlIDE6IEV4YW1wbGVzIGFsbCBoYXZlIGEgZml4ZWQgdGltZXN0YW1wIHRvIHByZXZlbnRcbiAgLy8gICAgICAgICAgIG5vdGUgMTogdGVzdHMgdG8gZmFpbCBiZWNhdXNlIG9mIHZhcmlhYmxlIHRpbWUoem9uZXMpXG4gIC8vICAgICAgICBleGFtcGxlIDE6IHN0cnRvdGltZSgnKzEgZGF5JywgMTEyOTYzMzIwMClcbiAgLy8gICAgICAgIHJldHVybnMgMTogMTEyOTcxOTYwMFxuICAvLyAgICAgICAgZXhhbXBsZSAyOiBzdHJ0b3RpbWUoJysxIHdlZWsgMiBkYXlzIDQgaG91cnMgMiBzZWNvbmRzJywgMTEyOTYzMzIwMClcbiAgLy8gICAgICAgIHJldHVybnMgMjogMTEzMDQyNTIwMlxuICAvLyAgICAgICAgZXhhbXBsZSAzOiBzdHJ0b3RpbWUoJ2xhc3QgbW9udGgnLCAxMTI5NjMzMjAwKVxuICAvLyAgICAgICAgcmV0dXJucyAzOiAxMTI3MDQxMjAwXG4gIC8vICAgICAgICBleGFtcGxlIDQ6IHN0cnRvdGltZSgnMjAwOS0wNS0wNCAwODozMDowMCswMCcpXG4gIC8vICAgICAgICByZXR1cm5zIDQ6IDEyNDE0MjU4MDBcbiAgLy8gICAgICAgIGV4YW1wbGUgNTogc3RydG90aW1lKCcyMDA5LTA1LTA0IDA4OjMwOjAwKzAyOjAwJylcbiAgLy8gICAgICAgIHJldHVybnMgNTogMTI0MTQxODYwMFxuICBpZiAobm93ID09IG51bGwpIHtcbiAgICBub3cgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgfVxuXG4gIC8vIHRoZSBydWxlIG9yZGVyIGlzIHZlcnkgZnJhZ2lsZVxuICAvLyBhcyBtYW55IGZvcm1hdHMgYXJlIHNpbWlsYXIgdG8gb3RoZXJzXG4gIC8vIHNvIHNtYWxsIGNoYW5nZSBjYW4gY2F1c2VcbiAgLy8gaW5wdXQgbWlzaW50ZXJwcmV0YXRpb25cbiAgdmFyIHJ1bGVzID0gW2Zvcm1hdHMueWVzdGVyZGF5LCBmb3JtYXRzLm5vdywgZm9ybWF0cy5ub29uLCBmb3JtYXRzLm1pZG5pZ2h0T3JUb2RheSwgZm9ybWF0cy50b21vcnJvdywgZm9ybWF0cy50aW1lc3RhbXAsIGZvcm1hdHMuZmlyc3RPckxhc3REYXksIGZvcm1hdHMuYmFja09yRnJvbnRPZixcbiAgLy8gZm9ybWF0cy53ZWVrZGF5T2YsIC8vIG5vdCB5ZXQgaW1wbGVtZW50ZWRcbiAgZm9ybWF0cy5tc3NxbHRpbWUsIGZvcm1hdHMudGltZUxvbmcxMiwgZm9ybWF0cy50aW1lU2hvcnQxMiwgZm9ybWF0cy50aW1lVGlueTEyLCBmb3JtYXRzLnNvYXAsIGZvcm1hdHMud2RkeCwgZm9ybWF0cy5leGlmLCBmb3JtYXRzLnhtbFJwYywgZm9ybWF0cy54bWxScGNOb0NvbG9uLCBmb3JtYXRzLmNsZiwgZm9ybWF0cy5pc284NjAxbG9uZywgZm9ybWF0cy5kYXRlVGV4dHVhbCwgZm9ybWF0cy5wb2ludGVkRGF0ZTQsIGZvcm1hdHMucG9pbnRlZERhdGUyLCBmb3JtYXRzLnRpbWVMb25nMjQsIGZvcm1hdHMuZGF0ZU5vQ29sb24sIGZvcm1hdHMucGd5ZG90ZCwgZm9ybWF0cy50aW1lU2hvcnQyNCwgZm9ybWF0cy5pc284NjAxbm9Db2xvbixcbiAgLy8gaXNvODYwMWRhdGVTbGFzaCBuZWVkcyB0byBjb21lIGJlZm9yZSBkYXRlU2xhc2hcbiAgZm9ybWF0cy5pc284NjAxZGF0ZVNsYXNoLCBmb3JtYXRzLmRhdGVTbGFzaCwgZm9ybWF0cy5hbWVyaWNhbiwgZm9ybWF0cy5hbWVyaWNhblNob3J0LCBmb3JtYXRzLmdudURhdGVTaG9ydE9ySXNvODYwMWRhdGUyLCBmb3JtYXRzLmlzbzg2MDFkYXRlNCwgZm9ybWF0cy5nbnVOb0NvbG9uLCBmb3JtYXRzLmdudURhdGVTaG9ydGVyLCBmb3JtYXRzLnBnVGV4dFJldmVyc2UsIGZvcm1hdHMuZGF0ZUZ1bGwsIGZvcm1hdHMuZGF0ZU5vRGF5LCBmb3JtYXRzLmRhdGVOb0RheVJldiwgZm9ybWF0cy5wZ1RleHRTaG9ydCwgZm9ybWF0cy5kYXRlTm9ZZWFyLCBmb3JtYXRzLmRhdGVOb1llYXJSZXYsIGZvcm1hdHMuaXNvV2Vla0RheSwgZm9ybWF0cy5yZWxhdGl2ZVRleHQsIGZvcm1hdHMucmVsYXRpdmUsIGZvcm1hdHMuZGF5VGV4dCwgZm9ybWF0cy5yZWxhdGl2ZVRleHRXZWVrLCBmb3JtYXRzLm1vbnRoRnVsbE9yTW9udGhBYmJyLCBmb3JtYXRzLnR6Q29ycmVjdGlvbiwgZm9ybWF0cy5hZ28sIGZvcm1hdHMuZ251Tm9Db2xvbjIsIGZvcm1hdHMueWVhcjQsXG4gIC8vIG5vdGU6IHRoZSB0d28gcnVsZXMgYmVsb3dcbiAgLy8gc2hvdWxkIGFsd2F5cyBjb21lIGxhc3RcbiAgZm9ybWF0cy53aGl0ZXNwYWNlLCBmb3JtYXRzLmFueV07XG5cbiAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUocmVzdWx0UHJvdG8pO1xuXG4gIHdoaWxlIChzdHIubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBydWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBmb3JtYXQgPSBydWxlc1tpXTtcblxuICAgICAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKGZvcm1hdC5yZWdleCk7XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAvLyBjYXJlIG9ubHkgYWJvdXQgZmFsc2UgcmVzdWx0cy4gSWdub3JlIG90aGVyIHZhbHVlc1xuICAgICAgICBpZiAoZm9ybWF0LmNhbGxiYWNrICYmIGZvcm1hdC5jYWxsYmFjay5hcHBseShyZXN1bHQsIG1hdGNoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBNYXRoLmZsb29yKHJlc3VsdC50b0RhdGUobmV3IERhdGUobm93ICogMTAwMCkpIC8gMTAwMCk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RydG90aW1lLmpzLm1hcFxuXG4vKioqLyB9KSxcbi8qIDI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGF0ZShmb3JtYXQsIHRpbWVzdGFtcCkge1xuICAvLyAgZGlzY3VzcyBhdDogaHR0cDovL2xvY3V0dXMuaW8vcGhwL2RhdGUvXG4gIC8vIG9yaWdpbmFsIGJ5OiBDYXJsb3MgUi4gTC4gUm9kcmlndWVzIChodHRwOi8vd3d3LmpzZnJvbWhlbGwuY29tKVxuICAvLyBvcmlnaW5hbCBieTogZ2V0dGltZW9mZGF5XG4gIC8vICAgIHBhcnRzIGJ5OiBQZXRlci1QYXVsIEtvY2ggKGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvYmVhdC5odG1sKVxuICAvLyBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2t2ei5pbylcbiAgLy8gaW1wcm92ZWQgYnk6IE1lRXRjIChodHRwOi8veWFzcy5tZWV0Y3dlYi5jb20pXG4gIC8vIGltcHJvdmVkIGJ5OiBCcmFkIFRvdWVzbmFyZFxuICAvLyBpbXByb3ZlZCBieTogVGltIFdpZWxcbiAgLy8gaW1wcm92ZWQgYnk6IEJyeWFuIEVsbGlvdHRcbiAgLy8gaW1wcm92ZWQgYnk6IERhdmlkIFJhbmRhbGxcbiAgLy8gaW1wcm92ZWQgYnk6IFRoZXJpYXVsdCAoaHR0cHM6Ly9naXRodWIuY29tL1RoZXJpYXVsdClcbiAgLy8gaW1wcm92ZWQgYnk6IFRoZXJpYXVsdCAoaHR0cHM6Ly9naXRodWIuY29tL1RoZXJpYXVsdClcbiAgLy8gaW1wcm92ZWQgYnk6IEJyZXR0IFphbWlyIChodHRwOi8vYnJldHQtemFtaXIubWUpXG4gIC8vIGltcHJvdmVkIGJ5OiBUaGVyaWF1bHQgKGh0dHBzOi8vZ2l0aHViLmNvbS9UaGVyaWF1bHQpXG4gIC8vIGltcHJvdmVkIGJ5OiBUaG9tYXMgQmVhdWNvdXJ0IChodHRwOi8vd3d3LndlYmFwcC5mcilcbiAgLy8gaW1wcm92ZWQgYnk6IEpUXG4gIC8vIGltcHJvdmVkIGJ5OiBUaGVyaWF1bHQgKGh0dHBzOi8vZ2l0aHViLmNvbS9UaGVyaWF1bHQpXG4gIC8vIGltcHJvdmVkIGJ5OiBSYWZhxYIgS3VrYXdza2kgKGh0dHA6Ly9ibG9nLmt1a2F3c2tpLnBsKVxuICAvLyBpbXByb3ZlZCBieTogVGhlcmlhdWx0IChodHRwczovL2dpdGh1Yi5jb20vVGhlcmlhdWx0KVxuICAvLyAgICBpbnB1dCBieTogQnJldHQgWmFtaXIgKGh0dHA6Ly9icmV0dC16YW1pci5tZSlcbiAgLy8gICAgaW5wdXQgYnk6IG1hamFrXG4gIC8vICAgIGlucHV0IGJ5OiBBbGV4XG4gIC8vICAgIGlucHV0IGJ5OiBNYXJ0aW5cbiAgLy8gICAgaW5wdXQgYnk6IEFsZXggV2lsc29uXG4gIC8vICAgIGlucHV0IGJ5OiBIYXJhdmlra1xuICAvLyBidWdmaXhlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2t2ei5pbylcbiAgLy8gYnVnZml4ZWQgYnk6IG1hamFrXG4gIC8vIGJ1Z2ZpeGVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va3Z6LmlvKVxuICAvLyBidWdmaXhlZCBieTogQnJldHQgWmFtaXIgKGh0dHA6Ly9icmV0dC16YW1pci5tZSlcbiAgLy8gYnVnZml4ZWQgYnk6IG9taWQgKGh0dHA6Ly9sb2N1dHVzLmlvL3BocC8zODA6MzgwI2NvbW1lbnRfMTM3MTIyKVxuICAvLyBidWdmaXhlZCBieTogQ2hyaXMgKGh0dHA6Ly93d3cuZGV2b3Rpcy5ubC8pXG4gIC8vICAgICAgbm90ZSAxOiBVc2VzIGdsb2JhbDogbG9jdXR1cyB0byBzdG9yZSB0aGUgZGVmYXVsdCB0aW1lem9uZVxuICAvLyAgICAgIG5vdGUgMTogQWx0aG91Z2ggdGhlIGZ1bmN0aW9uIHBvdGVudGlhbGx5IGFsbG93cyB0aW1lem9uZSBpbmZvXG4gIC8vICAgICAgbm90ZSAxOiAoc2VlIG5vdGVzKSwgaXQgY3VycmVudGx5IGRvZXMgbm90IHNldFxuICAvLyAgICAgIG5vdGUgMTogcGVyIGEgdGltZXpvbmUgc3BlY2lmaWVkIGJ5IGRhdGVfZGVmYXVsdF90aW1lem9uZV9zZXQoKS4gSW1wbGVtZW50ZXJzIG1pZ2h0IHVzZVxuICAvLyAgICAgIG5vdGUgMTogJGxvY3V0dXMuY3VycmVudFRpbWV6b25lT2Zmc2V0IGFuZFxuICAvLyAgICAgIG5vdGUgMTogJGxvY3V0dXMuY3VycmVudFRpbWV6b25lRFNUIHNldCBieSB0aGF0IGZ1bmN0aW9uXG4gIC8vICAgICAgbm90ZSAxOiBpbiBvcmRlciB0byBhZGp1c3QgdGhlIGRhdGVzIGluIHRoaXMgZnVuY3Rpb25cbiAgLy8gICAgICBub3RlIDE6IChvciBvdXIgb3RoZXIgZGF0ZSBmdW5jdGlvbnMhKSBhY2NvcmRpbmdseVxuICAvLyAgIGV4YW1wbGUgMTogZGF0ZSgnSDptOnMgXFxcXG0gXFxcXGlcXFxccyBcXFxcbVxcXFxvXFxcXG5cXFxcdFxcXFxoJywgMTA2MjQwMjQwMClcbiAgLy8gICByZXR1cm5zIDE6ICcwNzowOTo0MCBtIGlzIG1vbnRoJ1xuICAvLyAgIGV4YW1wbGUgMjogZGF0ZSgnRiBqLCBZLCBnOmkgYScsIDEwNjI0NjI0MDApXG4gIC8vICAgcmV0dXJucyAyOiAnU2VwdGVtYmVyIDIsIDIwMDMsIDEyOjI2IGFtJ1xuICAvLyAgIGV4YW1wbGUgMzogZGF0ZSgnWSBXIG8nLCAxMDYyNDYyNDAwKVxuICAvLyAgIHJldHVybnMgMzogJzIwMDMgMzYgMjAwMydcbiAgLy8gICBleGFtcGxlIDQ6IHZhciAkeCA9IGRhdGUoJ1kgbSBkJywgKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAvIDEwMDApXG4gIC8vICAgZXhhbXBsZSA0OiAkeCA9ICR4ICsgJydcbiAgLy8gICBleGFtcGxlIDQ6IHZhciAkcmVzdWx0ID0gJHgubGVuZ3RoIC8vIDIwMDkgMDEgMDlcbiAgLy8gICByZXR1cm5zIDQ6IDEwXG4gIC8vICAgZXhhbXBsZSA1OiBkYXRlKCdXJywgMTEwNDUzNDAwMClcbiAgLy8gICByZXR1cm5zIDU6ICc1MidcbiAgLy8gICBleGFtcGxlIDY6IGRhdGUoJ0IgdCcsIDExMDQ1MzQwMDApXG4gIC8vICAgcmV0dXJucyA2OiAnOTk5IDMxJ1xuICAvLyAgIGV4YW1wbGUgNzogZGF0ZSgnVyBVJywgMTI5Mzc1MDAwMC44Mik7IC8vIDIwMTAtMTItMzFcbiAgLy8gICByZXR1cm5zIDc6ICc1MiAxMjkzNzUwMDAwJ1xuICAvLyAgIGV4YW1wbGUgODogZGF0ZSgnVycsIDEyOTM4MzY0MDApOyAvLyAyMDExLTAxLTAxXG4gIC8vICAgcmV0dXJucyA4OiAnNTInXG4gIC8vICAgZXhhbXBsZSA5OiBkYXRlKCdXIFktbS1kJywgMTI5Mzk3NDA1NCk7IC8vIDIwMTEtMDEtMDJcbiAgLy8gICByZXR1cm5zIDk6ICc1MiAyMDExLTAxLTAyJ1xuICAvLyAgICAgICAgdGVzdDogc2tpcC0xIHNraXAtMiBza2lwLTVcblxuICB2YXIganNkYXRlLCBmO1xuICAvLyBLZWVwIHRoaXMgaGVyZSAod29ya3MsIGJ1dCBmb3IgY29kZSBjb21tZW50ZWQtb3V0IGJlbG93IGZvciBmaWxlIHNpemUgcmVhc29ucylcbiAgLy8gdmFyIHRhbD0gW107XG4gIHZhciB0eHRXb3JkcyA9IFsnU3VuJywgJ01vbicsICdUdWVzJywgJ1dlZG5lcycsICdUaHVycycsICdGcmknLCAnU2F0dXInLCAnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddO1xuICAvLyB0cmFpbGluZyBiYWNrc2xhc2ggLT4gKGRyb3BwZWQpXG4gIC8vIGEgYmFja3NsYXNoIGZvbGxvd2VkIGJ5IGFueSBjaGFyYWN0ZXIgKGluY2x1ZGluZyBiYWNrc2xhc2gpIC0+IHRoZSBjaGFyYWN0ZXJcbiAgLy8gZW1wdHkgc3RyaW5nIC0+IGVtcHR5IHN0cmluZ1xuICB2YXIgZm9ybWF0Q2hyID0gL1xcXFw/KC4/KS9naTtcbiAgdmFyIGZvcm1hdENockNiID0gZnVuY3Rpb24gZm9ybWF0Q2hyQ2IodCwgcykge1xuICAgIHJldHVybiBmW3RdID8gZlt0XSgpIDogcztcbiAgfTtcbiAgdmFyIF9wYWQgPSBmdW5jdGlvbiBfcGFkKG4sIGMpIHtcbiAgICBuID0gU3RyaW5nKG4pO1xuICAgIHdoaWxlIChuLmxlbmd0aCA8IGMpIHtcbiAgICAgIG4gPSAnMCcgKyBuO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfTtcbiAgZiA9IHtcbiAgICAvLyBEYXlcbiAgICBkOiBmdW5jdGlvbiBkKCkge1xuICAgICAgLy8gRGF5IG9mIG1vbnRoIHcvbGVhZGluZyAwOyAwMS4uMzFcbiAgICAgIHJldHVybiBfcGFkKGYuaigpLCAyKTtcbiAgICB9LFxuICAgIEQ6IGZ1bmN0aW9uIEQoKSB7XG4gICAgICAvLyBTaG9ydGhhbmQgZGF5IG5hbWU7IE1vbi4uLlN1blxuICAgICAgcmV0dXJuIGYubCgpLnNsaWNlKDAsIDMpO1xuICAgIH0sXG4gICAgajogZnVuY3Rpb24gaigpIHtcbiAgICAgIC8vIERheSBvZiBtb250aDsgMS4uMzFcbiAgICAgIHJldHVybiBqc2RhdGUuZ2V0RGF0ZSgpO1xuICAgIH0sXG4gICAgbDogZnVuY3Rpb24gbCgpIHtcbiAgICAgIC8vIEZ1bGwgZGF5IG5hbWU7IE1vbmRheS4uLlN1bmRheVxuICAgICAgcmV0dXJuIHR4dFdvcmRzW2YudygpXSArICdkYXknO1xuICAgIH0sXG4gICAgTjogZnVuY3Rpb24gTigpIHtcbiAgICAgIC8vIElTTy04NjAxIGRheSBvZiB3ZWVrOyAxW01vbl0uLjdbU3VuXVxuICAgICAgcmV0dXJuIGYudygpIHx8IDc7XG4gICAgfSxcbiAgICBTOiBmdW5jdGlvbiBTKCkge1xuICAgICAgLy8gT3JkaW5hbCBzdWZmaXggZm9yIGRheSBvZiBtb250aDsgc3QsIG5kLCByZCwgdGhcbiAgICAgIHZhciBqID0gZi5qKCk7XG4gICAgICB2YXIgaSA9IGogJSAxMDtcbiAgICAgIGlmIChpIDw9IDMgJiYgcGFyc2VJbnQoaiAlIDEwMCAvIDEwLCAxMCkgPT09IDEpIHtcbiAgICAgICAgaSA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gWydzdCcsICduZCcsICdyZCddW2kgLSAxXSB8fCAndGgnO1xuICAgIH0sXG4gICAgdzogZnVuY3Rpb24gdygpIHtcbiAgICAgIC8vIERheSBvZiB3ZWVrOyAwW1N1bl0uLjZbU2F0XVxuICAgICAgcmV0dXJuIGpzZGF0ZS5nZXREYXkoKTtcbiAgICB9LFxuICAgIHo6IGZ1bmN0aW9uIHooKSB7XG4gICAgICAvLyBEYXkgb2YgeWVhcjsgMC4uMzY1XG4gICAgICB2YXIgYSA9IG5ldyBEYXRlKGYuWSgpLCBmLm4oKSAtIDEsIGYuaigpKTtcbiAgICAgIHZhciBiID0gbmV3IERhdGUoZi5ZKCksIDAsIDEpO1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQoKGEgLSBiKSAvIDg2NGU1KTtcbiAgICB9LFxuXG4gICAgLy8gV2Vla1xuICAgIFc6IGZ1bmN0aW9uIFcoKSB7XG4gICAgICAvLyBJU08tODYwMSB3ZWVrIG51bWJlclxuICAgICAgdmFyIGEgPSBuZXcgRGF0ZShmLlkoKSwgZi5uKCkgLSAxLCBmLmooKSAtIGYuTigpICsgMyk7XG4gICAgICB2YXIgYiA9IG5ldyBEYXRlKGEuZ2V0RnVsbFllYXIoKSwgMCwgNCk7XG4gICAgICByZXR1cm4gX3BhZCgxICsgTWF0aC5yb3VuZCgoYSAtIGIpIC8gODY0ZTUgLyA3KSwgMik7XG4gICAgfSxcblxuICAgIC8vIE1vbnRoXG4gICAgRjogZnVuY3Rpb24gRigpIHtcbiAgICAgIC8vIEZ1bGwgbW9udGggbmFtZTsgSmFudWFyeS4uLkRlY2VtYmVyXG4gICAgICByZXR1cm4gdHh0V29yZHNbNiArIGYubigpXTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0oKSB7XG4gICAgICAvLyBNb250aCB3L2xlYWRpbmcgMDsgMDEuLi4xMlxuICAgICAgcmV0dXJuIF9wYWQoZi5uKCksIDIpO1xuICAgIH0sXG4gICAgTTogZnVuY3Rpb24gTSgpIHtcbiAgICAgIC8vIFNob3J0aGFuZCBtb250aCBuYW1lOyBKYW4uLi5EZWNcbiAgICAgIHJldHVybiBmLkYoKS5zbGljZSgwLCAzKTtcbiAgICB9LFxuICAgIG46IGZ1bmN0aW9uIG4oKSB7XG4gICAgICAvLyBNb250aDsgMS4uLjEyXG4gICAgICByZXR1cm4ganNkYXRlLmdldE1vbnRoKCkgKyAxO1xuICAgIH0sXG4gICAgdDogZnVuY3Rpb24gdCgpIHtcbiAgICAgIC8vIERheXMgaW4gbW9udGg7IDI4Li4uMzFcbiAgICAgIHJldHVybiBuZXcgRGF0ZShmLlkoKSwgZi5uKCksIDApLmdldERhdGUoKTtcbiAgICB9LFxuXG4gICAgLy8gWWVhclxuICAgIEw6IGZ1bmN0aW9uIEwoKSB7XG4gICAgICAvLyBJcyBsZWFwIHllYXI/OyAwIG9yIDFcbiAgICAgIHZhciBqID0gZi5ZKCk7XG4gICAgICByZXR1cm4gaiAlIDQgPT09IDAgJiBqICUgMTAwICE9PSAwIHwgaiAlIDQwMCA9PT0gMDtcbiAgICB9LFxuICAgIG86IGZ1bmN0aW9uIG8oKSB7XG4gICAgICAvLyBJU08tODYwMSB5ZWFyXG4gICAgICB2YXIgbiA9IGYubigpO1xuICAgICAgdmFyIFcgPSBmLlcoKTtcbiAgICAgIHZhciBZID0gZi5ZKCk7XG4gICAgICByZXR1cm4gWSArIChuID09PSAxMiAmJiBXIDwgOSA/IDEgOiBuID09PSAxICYmIFcgPiA5ID8gLTEgOiAwKTtcbiAgICB9LFxuICAgIFk6IGZ1bmN0aW9uIFkoKSB7XG4gICAgICAvLyBGdWxsIHllYXI7IGUuZy4gMTk4MC4uLjIwMTBcbiAgICAgIHJldHVybiBqc2RhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICB9LFxuICAgIHk6IGZ1bmN0aW9uIHkoKSB7XG4gICAgICAvLyBMYXN0IHR3byBkaWdpdHMgb2YgeWVhcjsgMDAuLi45OVxuICAgICAgcmV0dXJuIGYuWSgpLnRvU3RyaW5nKCkuc2xpY2UoLTIpO1xuICAgIH0sXG5cbiAgICAvLyBUaW1lXG4gICAgYTogZnVuY3Rpb24gYSgpIHtcbiAgICAgIC8vIGFtIG9yIHBtXG4gICAgICByZXR1cm4ganNkYXRlLmdldEhvdXJzKCkgPiAxMSA/ICdwbScgOiAnYW0nO1xuICAgIH0sXG4gICAgQTogZnVuY3Rpb24gQSgpIHtcbiAgICAgIC8vIEFNIG9yIFBNXG4gICAgICByZXR1cm4gZi5hKCkudG9VcHBlckNhc2UoKTtcbiAgICB9LFxuICAgIEI6IGZ1bmN0aW9uIEIoKSB7XG4gICAgICAvLyBTd2F0Y2ggSW50ZXJuZXQgdGltZTsgMDAwLi45OTlcbiAgICAgIHZhciBIID0ganNkYXRlLmdldFVUQ0hvdXJzKCkgKiAzNmUyO1xuICAgICAgLy8gSG91cnNcbiAgICAgIHZhciBpID0ganNkYXRlLmdldFVUQ01pbnV0ZXMoKSAqIDYwO1xuICAgICAgLy8gTWludXRlc1xuICAgICAgLy8gU2Vjb25kc1xuICAgICAgdmFyIHMgPSBqc2RhdGUuZ2V0VVRDU2Vjb25kcygpO1xuICAgICAgcmV0dXJuIF9wYWQoTWF0aC5mbG9vcigoSCArIGkgKyBzICsgMzZlMikgLyA4Ni40KSAlIDFlMywgMyk7XG4gICAgfSxcbiAgICBnOiBmdW5jdGlvbiBnKCkge1xuICAgICAgLy8gMTItSG91cnM7IDEuLjEyXG4gICAgICByZXR1cm4gZi5HKCkgJSAxMiB8fCAxMjtcbiAgICB9LFxuICAgIEc6IGZ1bmN0aW9uIEcoKSB7XG4gICAgICAvLyAyNC1Ib3VyczsgMC4uMjNcbiAgICAgIHJldHVybiBqc2RhdGUuZ2V0SG91cnMoKTtcbiAgICB9LFxuICAgIGg6IGZ1bmN0aW9uIGgoKSB7XG4gICAgICAvLyAxMi1Ib3VycyB3L2xlYWRpbmcgMDsgMDEuLjEyXG4gICAgICByZXR1cm4gX3BhZChmLmcoKSwgMik7XG4gICAgfSxcbiAgICBIOiBmdW5jdGlvbiBIKCkge1xuICAgICAgLy8gMjQtSG91cnMgdy9sZWFkaW5nIDA7IDAwLi4yM1xuICAgICAgcmV0dXJuIF9wYWQoZi5HKCksIDIpO1xuICAgIH0sXG4gICAgaTogZnVuY3Rpb24gaSgpIHtcbiAgICAgIC8vIE1pbnV0ZXMgdy9sZWFkaW5nIDA7IDAwLi41OVxuICAgICAgcmV0dXJuIF9wYWQoanNkYXRlLmdldE1pbnV0ZXMoKSwgMik7XG4gICAgfSxcbiAgICBzOiBmdW5jdGlvbiBzKCkge1xuICAgICAgLy8gU2Vjb25kcyB3L2xlYWRpbmcgMDsgMDAuLjU5XG4gICAgICByZXR1cm4gX3BhZChqc2RhdGUuZ2V0U2Vjb25kcygpLCAyKTtcbiAgICB9LFxuICAgIHU6IGZ1bmN0aW9uIHUoKSB7XG4gICAgICAvLyBNaWNyb3NlY29uZHM7IDAwMDAwMC05OTkwMDBcbiAgICAgIHJldHVybiBfcGFkKGpzZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSAqIDEwMDAsIDYpO1xuICAgIH0sXG5cbiAgICAvLyBUaW1lem9uZVxuICAgIGU6IGZ1bmN0aW9uIGUoKSB7XG4gICAgICAvLyBUaW1lem9uZSBpZGVudGlmaWVyOyBlLmcuIEF0bGFudGljL0F6b3JlcywgLi4uXG4gICAgICAvLyBUaGUgZm9sbG93aW5nIHdvcmtzLCBidXQgcmVxdWlyZXMgaW5jbHVzaW9uIG9mIHRoZSB2ZXJ5IGxhcmdlXG4gICAgICAvLyB0aW1lem9uZV9hYmJyZXZpYXRpb25zX2xpc3QoKSBmdW5jdGlvbi5cbiAgICAgIC8qICAgICAgICAgICAgICByZXR1cm4gdGhhdC5kYXRlX2RlZmF1bHRfdGltZXpvbmVfZ2V0KCk7XG4gICAgICAgKi9cbiAgICAgIHZhciBtc2cgPSAnTm90IHN1cHBvcnRlZCAoc2VlIHNvdXJjZSBjb2RlIG9mIGRhdGUoKSBmb3IgdGltZXpvbmUgb24gaG93IHRvIGFkZCBzdXBwb3J0KSc7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9LFxuICAgIEk6IGZ1bmN0aW9uIEkoKSB7XG4gICAgICAvLyBEU1Qgb2JzZXJ2ZWQ/OyAwIG9yIDFcbiAgICAgIC8vIENvbXBhcmVzIEphbiAxIG1pbnVzIEphbiAxIFVUQyB0byBKdWwgMSBtaW51cyBKdWwgMSBVVEMuXG4gICAgICAvLyBJZiB0aGV5IGFyZSBub3QgZXF1YWwsIHRoZW4gRFNUIGlzIG9ic2VydmVkLlxuICAgICAgdmFyIGEgPSBuZXcgRGF0ZShmLlkoKSwgMCk7XG4gICAgICAvLyBKYW4gMVxuICAgICAgdmFyIGMgPSBEYXRlLlVUQyhmLlkoKSwgMCk7XG4gICAgICAvLyBKYW4gMSBVVENcbiAgICAgIHZhciBiID0gbmV3IERhdGUoZi5ZKCksIDYpO1xuICAgICAgLy8gSnVsIDFcbiAgICAgIC8vIEp1bCAxIFVUQ1xuICAgICAgdmFyIGQgPSBEYXRlLlVUQyhmLlkoKSwgNik7XG4gICAgICByZXR1cm4gYSAtIGMgIT09IGIgLSBkID8gMSA6IDA7XG4gICAgfSxcbiAgICBPOiBmdW5jdGlvbiBPKCkge1xuICAgICAgLy8gRGlmZmVyZW5jZSB0byBHTVQgaW4gaG91ciBmb3JtYXQ7IGUuZy4gKzAyMDBcbiAgICAgIHZhciB0em8gPSBqc2RhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgIHZhciBhID0gTWF0aC5hYnModHpvKTtcbiAgICAgIHJldHVybiAodHpvID4gMCA/ICctJyA6ICcrJykgKyBfcGFkKE1hdGguZmxvb3IoYSAvIDYwKSAqIDEwMCArIGEgJSA2MCwgNCk7XG4gICAgfSxcbiAgICBQOiBmdW5jdGlvbiBQKCkge1xuICAgICAgLy8gRGlmZmVyZW5jZSB0byBHTVQgdy9jb2xvbjsgZS5nLiArMDI6MDBcbiAgICAgIHZhciBPID0gZi5PKCk7XG4gICAgICByZXR1cm4gTy5zdWJzdHIoMCwgMykgKyAnOicgKyBPLnN1YnN0cigzLCAyKTtcbiAgICB9LFxuICAgIFQ6IGZ1bmN0aW9uIFQoKSB7XG4gICAgICAvLyBUaGUgZm9sbG93aW5nIHdvcmtzLCBidXQgcmVxdWlyZXMgaW5jbHVzaW9uIG9mIHRoZSB2ZXJ5XG4gICAgICAvLyBsYXJnZSB0aW1lem9uZV9hYmJyZXZpYXRpb25zX2xpc3QoKSBmdW5jdGlvbi5cbiAgICAgIC8qICAgICAgICAgICAgICB2YXIgYWJiciwgaSwgb3MsIF9kZWZhdWx0O1xuICAgICAgaWYgKCF0YWwubGVuZ3RoKSB7XG4gICAgICAgIHRhbCA9IHRoYXQudGltZXpvbmVfYWJicmV2aWF0aW9uc19saXN0KCk7XG4gICAgICB9XG4gICAgICBpZiAoJGxvY3V0dXMgJiYgJGxvY3V0dXMuZGVmYXVsdF90aW1lem9uZSkge1xuICAgICAgICBfZGVmYXVsdCA9ICRsb2N1dHVzLmRlZmF1bHRfdGltZXpvbmU7XG4gICAgICAgIGZvciAoYWJiciBpbiB0YWwpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGFsW2FiYnJdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGFsW2FiYnJdW2ldLnRpbWV6b25lX2lkID09PSBfZGVmYXVsdCkge1xuICAgICAgICAgICAgICByZXR1cm4gYWJici50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChhYmJyIGluIHRhbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGFsW2FiYnJdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgb3MgPSAtanNkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDtcbiAgICAgICAgICBpZiAodGFsW2FiYnJdW2ldLm9mZnNldCA9PT0gb3MpIHtcbiAgICAgICAgICAgIHJldHVybiBhYmJyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAqL1xuICAgICAgcmV0dXJuICdVVEMnO1xuICAgIH0sXG4gICAgWjogZnVuY3Rpb24gWigpIHtcbiAgICAgIC8vIFRpbWV6b25lIG9mZnNldCBpbiBzZWNvbmRzICgtNDMyMDAuLi41MDQwMClcbiAgICAgIHJldHVybiAtanNkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDtcbiAgICB9LFxuXG4gICAgLy8gRnVsbCBEYXRlL1RpbWVcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgLy8gSVNPLTg2MDEgZGF0ZS5cbiAgICAgIHJldHVybiAnWS1tLWRcXFxcVEg6aTpzUCcucmVwbGFjZShmb3JtYXRDaHIsIGZvcm1hdENockNiKTtcbiAgICB9LFxuICAgIHI6IGZ1bmN0aW9uIHIoKSB7XG4gICAgICAvLyBSRkMgMjgyMlxuICAgICAgcmV0dXJuICdELCBkIE0gWSBIOmk6cyBPJy5yZXBsYWNlKGZvcm1hdENociwgZm9ybWF0Q2hyQ2IpO1xuICAgIH0sXG4gICAgVTogZnVuY3Rpb24gVSgpIHtcbiAgICAgIC8vIFNlY29uZHMgc2luY2UgVU5JWCBlcG9jaFxuICAgICAgcmV0dXJuIGpzZGF0ZSAvIDEwMDAgfCAwO1xuICAgIH1cbiAgfTtcblxuICB2YXIgX2RhdGUgPSBmdW5jdGlvbiBfZGF0ZShmb3JtYXQsIHRpbWVzdGFtcCkge1xuICAgIGpzZGF0ZSA9IHRpbWVzdGFtcCA9PT0gdW5kZWZpbmVkID8gbmV3IERhdGUoKSAvLyBOb3QgcHJvdmlkZWRcbiAgICA6IHRpbWVzdGFtcCBpbnN0YW5jZW9mIERhdGUgPyBuZXcgRGF0ZSh0aW1lc3RhbXApIC8vIEpTIERhdGUoKVxuICAgIDogbmV3IERhdGUodGltZXN0YW1wICogMTAwMCkgLy8gVU5JWCB0aW1lc3RhbXAgKGF1dG8tY29udmVydCB0byBpbnQpXG4gICAgO1xuICAgIHJldHVybiBmb3JtYXQucmVwbGFjZShmb3JtYXRDaHIsIGZvcm1hdENockNiKTtcbiAgfTtcblxuICByZXR1cm4gX2RhdGUoZm9ybWF0LCB0aW1lc3RhbXApO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGUuanMubWFwXG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBib29sdmFsKG1peGVkVmFyKSB7XG4gIC8vIG9yaWdpbmFsIGJ5OiBXaWxsIFJvd2VcbiAgLy8gICBleGFtcGxlIDE6IGJvb2x2YWwodHJ1ZSlcbiAgLy8gICByZXR1cm5zIDE6IHRydWVcbiAgLy8gICBleGFtcGxlIDI6IGJvb2x2YWwoZmFsc2UpXG4gIC8vICAgcmV0dXJucyAyOiBmYWxzZVxuICAvLyAgIGV4YW1wbGUgMzogYm9vbHZhbCgwKVxuICAvLyAgIHJldHVybnMgMzogZmFsc2VcbiAgLy8gICBleGFtcGxlIDQ6IGJvb2x2YWwoMC4wKVxuICAvLyAgIHJldHVybnMgNDogZmFsc2VcbiAgLy8gICBleGFtcGxlIDU6IGJvb2x2YWwoJycpXG4gIC8vICAgcmV0dXJucyA1OiBmYWxzZVxuICAvLyAgIGV4YW1wbGUgNjogYm9vbHZhbCgnMCcpXG4gIC8vICAgcmV0dXJucyA2OiBmYWxzZVxuICAvLyAgIGV4YW1wbGUgNzogYm9vbHZhbChbXSlcbiAgLy8gICByZXR1cm5zIDc6IGZhbHNlXG4gIC8vICAgZXhhbXBsZSA4OiBib29sdmFsKCcnKVxuICAvLyAgIHJldHVybnMgODogZmFsc2VcbiAgLy8gICBleGFtcGxlIDk6IGJvb2x2YWwobnVsbClcbiAgLy8gICByZXR1cm5zIDk6IGZhbHNlXG4gIC8vICAgZXhhbXBsZSAxMDogYm9vbHZhbCh1bmRlZmluZWQpXG4gIC8vICAgcmV0dXJucyAxMDogZmFsc2VcbiAgLy8gICBleGFtcGxlIDExOiBib29sdmFsKCd0cnVlJylcbiAgLy8gICByZXR1cm5zIDExOiB0cnVlXG5cbiAgaWYgKG1peGVkVmFyID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChtaXhlZFZhciA9PT0gMCB8fCBtaXhlZFZhciA9PT0gMC4wKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG1peGVkVmFyID09PSAnJyB8fCBtaXhlZFZhciA9PT0gJzAnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobWl4ZWRWYXIpICYmIG1peGVkVmFyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChtaXhlZFZhciA9PT0gbnVsbCB8fCBtaXhlZFZhciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vbHZhbC5qcy5tYXBcblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUd2lnKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBUd2lnLlRlbXBsYXRlcy5yZWdpc3RlckxvYWRlcignYWpheCcsIGZ1bmN0aW9uIChsb2NhdGlvbiwgcGFyYW1zLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgIHZhciB0ZW1wbGF0ZTtcbiAgICB2YXIgcHJlY29tcGlsZWQgPSBwYXJhbXMucHJlY29tcGlsZWQ7XG4gICAgdmFyIHBhcnNlciA9IHRoaXMucGFyc2Vyc1twYXJhbXMucGFyc2VyXSB8fCB0aGlzLnBhcnNlci50d2lnO1xuXG4gICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKCdVbnN1cHBvcnRlZCBwbGF0Zm9ybTogVW5hYmxlIHRvIGRvIGFqYXggcmVxdWVzdHMgJyArICdiZWNhdXNlIHRoZXJlIGlzIG5vIFwiWE1MSFRUUFJlcXVlc3RcIiBpbXBsZW1lbnRhdGlvbicpO1xuICAgIH1cblxuICAgIHZhciB4bWxodHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICB4bWxodHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkYXRhID0gbnVsbDtcblxuICAgICAgaWYgKHhtbGh0dHAucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICBpZiAoeG1saHR0cC5zdGF0dXMgPT09IDIwMCB8fCB3aW5kb3cuY29yZG92YSAmJiB4bWxodHRwLnN0YXR1cyA9PT0gMCkge1xuICAgICAgICAgIFR3aWcubG9nLmRlYnVnKCdHb3QgdGVtcGxhdGUgJywgeG1saHR0cC5yZXNwb25zZVRleHQpO1xuXG4gICAgICAgICAgaWYgKHByZWNvbXBpbGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZSh4bWxodHRwLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSB4bWxodHRwLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJhbXMudXJsID0gbG9jYXRpb247XG4gICAgICAgICAgcGFyYW1zLmRhdGEgPSBkYXRhO1xuICAgICAgICAgIHRlbXBsYXRlID0gcGFyc2VyLmNhbGwodGhpcywgcGFyYW1zKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRlbXBsYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVycm9yQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBlcnJvckNhbGxiYWNrKHhtbGh0dHApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHhtbGh0dHAub3BlbignR0VUJywgbG9jYXRpb24sIEJvb2xlYW4ocGFyYW1zLmFzeW5jKSk7XG4gICAgeG1saHR0cC5zZW5kKCk7XG5cbiAgICBpZiAocGFyYW1zLmFzeW5jKSB7XG4gICAgICAvLyBUT0RPOiByZXR1cm4gZGVmZXJyZWQgcHJvbWlzZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9KTtcbn07XG5cbi8qKiovIH0pLFxuLyogMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVHdpZykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGZzO1xuICB2YXIgcGF0aDtcblxuICB0cnkge1xuICAgIC8vIFJlcXVpcmUgbGliIGRlcGVuZGVuY2llcyBhdCBydW50aW1lXG4gICAgZnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcbiAgICBwYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBOT1RFOiB0aGlzIGlzIGluIGEgdHJ5L2NhdGNoIHRvIGF2b2lkIGVycm9ycyBjcm9zcyBwbGF0Zm9ybVxuICAgIGNvbnNvbGUud2FybignTWlzc2luZyBmcyBhbmQgcGF0aCBtb2R1bGVzLiAnICsgZXJyb3IpO1xuICB9XG5cbiAgVHdpZy5UZW1wbGF0ZXMucmVnaXN0ZXJMb2FkZXIoJ2ZzJywgZnVuY3Rpb24gKGxvY2F0aW9uLCBwYXJhbXMsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdmFyIHRlbXBsYXRlO1xuICAgIHZhciBkYXRhID0gbnVsbDtcbiAgICB2YXIgcHJlY29tcGlsZWQgPSBwYXJhbXMucHJlY29tcGlsZWQ7XG4gICAgdmFyIHBhcnNlciA9IHRoaXMucGFyc2Vyc1twYXJhbXMucGFyc2VyXSB8fCB0aGlzLnBhcnNlci50d2lnO1xuXG4gICAgaWYgKCFmcyB8fCAhcGF0aCkge1xuICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoJ1Vuc3VwcG9ydGVkIHBsYXRmb3JtOiBVbmFibGUgdG8gbG9hZCBmcm9tIGZpbGUgJyArICdiZWNhdXNlIHRoZXJlIGlzIG5vIFwiZnNcIiBvciBcInBhdGhcIiBpbXBsZW1lbnRhdGlvbicpO1xuICAgIH1cblxuICAgIHZhciBsb2FkVGVtcGxhdGVGbiA9IGZ1bmN0aW9uIGxvYWRUZW1wbGF0ZUZuKGVyciwgZGF0YSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAodHlwZW9mIGVycm9yQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBlcnJvckNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmVjb21waWxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH1cblxuICAgICAgcGFyYW1zLmRhdGEgPSBkYXRhO1xuICAgICAgcGFyYW1zLnBhdGggPSBwYXJhbXMucGF0aCB8fCBsb2NhdGlvbjsgLy8gVGVtcGxhdGUgaXMgaW4gZGF0YVxuXG4gICAgICB0ZW1wbGF0ZSA9IHBhcnNlci5jYWxsKHRoaXMsIHBhcmFtcyk7XG5cbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sodGVtcGxhdGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBwYXJhbXMucGF0aCA9IHBhcmFtcy5wYXRoIHx8IGxvY2F0aW9uO1xuXG4gICAgaWYgKHBhcmFtcy5hc3luYykge1xuICAgICAgZnMuc3RhdChwYXJhbXMucGF0aCwgZnVuY3Rpb24gKGVyciwgc3RhdHMpIHtcbiAgICAgICAgaWYgKGVyciB8fCAhc3RhdHMuaXNGaWxlKCkpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGVycm9yQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVycm9yQ2FsbGJhY2sobmV3IFR3aWcuRXJyb3IoJ1VuYWJsZSB0byBmaW5kIHRlbXBsYXRlIGZpbGUgJyArIHBhcmFtcy5wYXRoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZnMucmVhZEZpbGUocGFyYW1zLnBhdGgsICd1dGY4JywgbG9hZFRlbXBsYXRlRm4pO1xuICAgICAgfSk7IC8vIFRPRE86IHJldHVybiBkZWZlcnJlZCBwcm9taXNlXG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAoIWZzLnN0YXRTeW5jKHBhcmFtcy5wYXRoKS5pc0ZpbGUoKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcignVW5hYmxlIHRvIGZpbmQgdGVtcGxhdGUgZmlsZSAnICsgcGFyYW1zLnBhdGgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgVHdpZy5FcnJvcignVW5hYmxlIHRvIGZpbmQgdGVtcGxhdGUgZmlsZSAnICsgcGFyYW1zLnBhdGggKyAnLiAnICsgZXJyb3IpO1xuICAgIH1cblxuICAgIGRhdGEgPSBmcy5yZWFkRmlsZVN5bmMocGFyYW1zLnBhdGgsICd1dGY4Jyk7XG4gICAgbG9hZFRlbXBsYXRlRm4odW5kZWZpbmVkLCBkYXRhKTtcbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH0pO1xufTtcblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJmc1wiKTtcblxuLyoqKi8gfSksXG4vKiAzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTJbXCJkZWZhdWx0XCJdKSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG4vLyAjIyB0d2lnLmxvZ2ljLmpzXG4vL1xuLy8gVGhpcyBmaWxlIGhhbmRsZXMgdG9rZW5pemluZywgY29tcGlsaW5nIGFuZCBwYXJzaW5nIGxvZ2ljIHRva2Vucy4geyUgLi4uICV9XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUd2lnKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIE5hbWVzcGFjZSBmb3IgbG9naWMgaGFuZGxpbmcuXG4gICAqL1xuXG4gIFR3aWcubG9naWMgPSB7fTtcbiAgLyoqXG4gICAqIExvZ2ljIHRva2VuIHR5cGVzLlxuICAgKi9cblxuICBUd2lnLmxvZ2ljLnR5cGUgPSB7XG4gICAgaWZfOiAnVHdpZy5sb2dpYy50eXBlLmlmJyxcbiAgICBlbmRpZjogJ1R3aWcubG9naWMudHlwZS5lbmRpZicsXG4gICAgZm9yXzogJ1R3aWcubG9naWMudHlwZS5mb3InLFxuICAgIGVuZGZvcjogJ1R3aWcubG9naWMudHlwZS5lbmRmb3InLFxuICAgIGVsc2VfOiAnVHdpZy5sb2dpYy50eXBlLmVsc2UnLFxuICAgIGVsc2VpZjogJ1R3aWcubG9naWMudHlwZS5lbHNlaWYnLFxuICAgIHNldDogJ1R3aWcubG9naWMudHlwZS5zZXQnLFxuICAgIHNldGNhcHR1cmU6ICdUd2lnLmxvZ2ljLnR5cGUuc2V0Y2FwdHVyZScsXG4gICAgZW5kc2V0OiAnVHdpZy5sb2dpYy50eXBlLmVuZHNldCcsXG4gICAgZmlsdGVyOiAnVHdpZy5sb2dpYy50eXBlLmZpbHRlcicsXG4gICAgZW5kZmlsdGVyOiAnVHdpZy5sb2dpYy50eXBlLmVuZGZpbHRlcicsXG4gICAgYXBwbHk6ICdUd2lnLmxvZ2ljLnR5cGUuYXBwbHknLFxuICAgIGVuZGFwcGx5OiAnVHdpZy5sb2dpYy50eXBlLmVuZGFwcGx5JyxcbiAgICBcImRvXCI6ICdUd2lnLmxvZ2ljLnR5cGUuZG8nLFxuICAgIHNob3J0YmxvY2s6ICdUd2lnLmxvZ2ljLnR5cGUuc2hvcnRibG9jaycsXG4gICAgYmxvY2s6ICdUd2lnLmxvZ2ljLnR5cGUuYmxvY2snLFxuICAgIGVuZGJsb2NrOiAnVHdpZy5sb2dpYy50eXBlLmVuZGJsb2NrJyxcbiAgICBleHRlbmRzXzogJ1R3aWcubG9naWMudHlwZS5leHRlbmRzJyxcbiAgICB1c2U6ICdUd2lnLmxvZ2ljLnR5cGUudXNlJyxcbiAgICBpbmNsdWRlOiAnVHdpZy5sb2dpYy50eXBlLmluY2x1ZGUnLFxuICAgIHNwYWNlbGVzczogJ1R3aWcubG9naWMudHlwZS5zcGFjZWxlc3MnLFxuICAgIGVuZHNwYWNlbGVzczogJ1R3aWcubG9naWMudHlwZS5lbmRzcGFjZWxlc3MnLFxuICAgIG1hY3JvOiAnVHdpZy5sb2dpYy50eXBlLm1hY3JvJyxcbiAgICBlbmRtYWNybzogJ1R3aWcubG9naWMudHlwZS5lbmRtYWNybycsXG4gICAgaW1wb3J0XzogJ1R3aWcubG9naWMudHlwZS5pbXBvcnQnLFxuICAgIGZyb206ICdUd2lnLmxvZ2ljLnR5cGUuZnJvbScsXG4gICAgZW1iZWQ6ICdUd2lnLmxvZ2ljLnR5cGUuZW1iZWQnLFxuICAgIGVuZGVtYmVkOiAnVHdpZy5sb2dpYy50eXBlLmVuZGVtYmVkJyxcbiAgICBcIndpdGhcIjogJ1R3aWcubG9naWMudHlwZS53aXRoJyxcbiAgICBlbmR3aXRoOiAnVHdpZy5sb2dpYy50eXBlLmVuZHdpdGgnLFxuICAgIGRlcHJlY2F0ZWQ6ICdUd2lnLmxvZ2ljLnR5cGUuZGVwcmVjYXRlZCdcbiAgfTsgLy8gUmVndWxhciBleHByZXNzaW9ucyBmb3IgaGFuZGxpbmcgbG9naWMgdG9rZW5zLlxuICAvL1xuICAvLyBQcm9wZXJ0aWVzOlxuICAvL1xuICAvLyAgICAgIHR5cGU6ICBUaGUgdHlwZSBvZiBleHByZXNzaW9uIHRoaXMgbWF0Y2hlc1xuICAvL1xuICAvLyAgICAgIHJlZ2V4OiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgdGhlIGZvcm1hdCBvZiB0aGUgdG9rZW5cbiAgLy9cbiAgLy8gICAgICBuZXh0OiAgV2hhdCBsb2dpYyB0b2tlbnMgKGlmIGFueSkgcG9wIHRoaXMgdG9rZW4gb2ZmIHRoZSBsb2dpYyBzdGFjay4gSWYgZW1wdHksIHRoZVxuICAvLyAgICAgICAgICAgICBsb2dpYyB0b2tlbiBpcyBhc3N1bWVkIHRvIG5vdCByZXF1aXJlIGFuIGVuZCB0YWcgYW5kIGlzbid0IHB1c2ggb250byB0aGUgc3RhY2suXG4gIC8vXG4gIC8vICAgICAgb3BlbjogIERvZXMgdGhpcyB0YWcgb3BlbiBhIGxvZ2ljIGV4cHJlc3Npb24gb3IgaXMgaXQgc3RhbmRhbG9uZS4gRm9yIGV4YW1wbGUsXG4gIC8vICAgICAgICAgICAgIHslIGVuZGlmICV9IGNhbm5vdCBleGlzdCB3aXRob3V0IGFuIG9wZW5pbmcgeyUgaWYgLi4uICV9IHRhZywgc28gb3BlbiA9IGZhbHNlLlxuICAvL1xuICAvLyAgRnVuY3Rpb25zOlxuICAvL1xuICAvLyAgICAgIGNvbXBpbGU6IEEgZnVuY3Rpb24gdGhhdCBoYW5kbGVzIGNvbXBpbGluZyB0aGUgdG9rZW4gaW50byBhbiBvdXRwdXQgdG9rZW4gcmVhZHkgZm9yXG4gIC8vICAgICAgICAgICAgICAgcGFyc2luZyB3aXRoIHRoZSBwYXJzZSBmdW5jdGlvbi5cbiAgLy9cbiAgLy8gICAgICBwYXJzZTogICBBIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIHRoZSBjb21waWxlZCB0b2tlbiBpbnRvIG91dHB1dCAoSFRNTCAvIHdoYXRldmVyIHRoZVxuICAvLyAgICAgICAgICAgICAgIHRlbXBsYXRlIHJlcHJlc2VudHMpLlxuXG4gIFR3aWcubG9naWMuZGVmaW5pdGlvbnMgPSBbe1xuICAgIC8qKlxuICAgICAqIElmIHR5cGUgbG9naWMgdG9rZW5zLlxuICAgICAqXG4gICAgICogIEZvcm1hdDogeyUgaWYgZXhwcmVzc2lvbiAlfVxuICAgICAqL1xuICAgIHR5cGU6IFR3aWcubG9naWMudHlwZS5pZl8sXG4gICAgcmVnZXg6IC9eaWZcXHM/KFtcXHNcXFNdKykkLyxcbiAgICBuZXh0OiBbVHdpZy5sb2dpYy50eXBlLmVsc2VfLCBUd2lnLmxvZ2ljLnR5cGUuZWxzZWlmLCBUd2lnLmxvZ2ljLnR5cGUuZW5kaWZdLFxuICAgIG9wZW46IHRydWUsXG4gICAgY29tcGlsZTogZnVuY3Rpb24gY29tcGlsZSh0b2tlbikge1xuICAgICAgdmFyIGV4cHJlc3Npb24gPSB0b2tlbi5tYXRjaFsxXTsgLy8gQ29tcGlsZSB0aGUgZXhwcmVzc2lvbi5cblxuICAgICAgdG9rZW4uc3RhY2sgPSBUd2lnLmV4cHJlc3Npb24uY29tcGlsZS5jYWxsKHRoaXMsIHtcbiAgICAgICAgdHlwZTogVHdpZy5leHByZXNzaW9uLnR5cGUuZXhwcmVzc2lvbixcbiAgICAgICAgdmFsdWU6IGV4cHJlc3Npb25cbiAgICAgIH0pLnN0YWNrO1xuICAgICAgZGVsZXRlIHRva2VuLm1hdGNoO1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHRva2VuLCBjb250ZXh0LCBjaGFpbikge1xuICAgICAgdmFyIHN0YXRlID0gdGhpcztcbiAgICAgIHJldHVybiBUd2lnLmV4cHJlc3Npb24ucGFyc2VBc3luYy5jYWxsKHN0YXRlLCB0b2tlbi5zdGFjaywgY29udGV4dCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGNoYWluID0gdHJ1ZTtcblxuICAgICAgICBpZiAoVHdpZy5saWIuYm9vbHZhbChyZXN1bHQpKSB7XG4gICAgICAgICAgY2hhaW4gPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gc3RhdGUucGFyc2VBc3luYyh0b2tlbi5vdXRwdXQsIGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAob3V0cHV0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICAgIG91dHB1dDogb3V0cHV0XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICAvKipcbiAgICAgKiBFbHNlIGlmIHR5cGUgbG9naWMgdG9rZW5zLlxuICAgICAqXG4gICAgICogIEZvcm1hdDogeyUgZWxzZWlmIGV4cHJlc3Npb24gJX1cbiAgICAgKi9cbiAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUuZWxzZWlmLFxuICAgIHJlZ2V4OiAvXmVsc2VpZlxccz8oW15cXHNdLiopJC8sXG4gICAgbmV4dDogW1R3aWcubG9naWMudHlwZS5lbHNlXywgVHdpZy5sb2dpYy50eXBlLmVsc2VpZiwgVHdpZy5sb2dpYy50eXBlLmVuZGlmXSxcbiAgICBvcGVuOiBmYWxzZSxcbiAgICBjb21waWxlOiBmdW5jdGlvbiBjb21waWxlKHRva2VuKSB7XG4gICAgICB2YXIgZXhwcmVzc2lvbiA9IHRva2VuLm1hdGNoWzFdOyAvLyBDb21waWxlIHRoZSBleHByZXNzaW9uLlxuXG4gICAgICB0b2tlbi5zdGFjayA9IFR3aWcuZXhwcmVzc2lvbi5jb21waWxlLmNhbGwodGhpcywge1xuICAgICAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5leHByZXNzaW9uLFxuICAgICAgICB2YWx1ZTogZXhwcmVzc2lvblxuICAgICAgfSkuc3RhY2s7XG4gICAgICBkZWxldGUgdG9rZW4ubWF0Y2g7XG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UodG9rZW4sIGNvbnRleHQsIGNoYWluKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzO1xuICAgICAgcmV0dXJuIFR3aWcuZXhwcmVzc2lvbi5wYXJzZUFzeW5jLmNhbGwoc3RhdGUsIHRva2VuLnN0YWNrLCBjb250ZXh0KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKGNoYWluICYmIFR3aWcubGliLmJvb2x2YWwocmVzdWx0KSkge1xuICAgICAgICAgIGNoYWluID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnBhcnNlQXN5bmModG9rZW4ub3V0cHV0LCBjb250ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKG91dHB1dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoYWluOiBjaGFpbixcbiAgICAgICAgICBvdXRwdXQ6IG91dHB1dFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAgLyoqXG4gICAgICogRWxzZSB0eXBlIGxvZ2ljIHRva2Vucy5cbiAgICAgKlxuICAgICAqICBGb3JtYXQ6IHslIGVsc2UgJX1cbiAgICAgKi9cbiAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUuZWxzZV8sXG4gICAgcmVnZXg6IC9eZWxzZSQvLFxuICAgIG5leHQ6IFtUd2lnLmxvZ2ljLnR5cGUuZW5kaWYsIFR3aWcubG9naWMudHlwZS5lbmRmb3JdLFxuICAgIG9wZW46IGZhbHNlLFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSh0b2tlbiwgY29udGV4dCwgY2hhaW4pIHtcbiAgICAgIHZhciBwcm9taXNlID0gVHdpZy5Qcm9taXNlLnJlc29sdmUoJycpO1xuICAgICAgdmFyIHN0YXRlID0gdGhpcztcblxuICAgICAgaWYgKGNoYWluKSB7XG4gICAgICAgIHByb21pc2UgPSBzdGF0ZS5wYXJzZUFzeW5jKHRva2VuLm91dHB1dCwgY29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKG91dHB1dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoYWluOiBjaGFpbixcbiAgICAgICAgICBvdXRwdXQ6IG91dHB1dFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAgLyoqXG4gICAgICogRW5kIGlmIHR5cGUgbG9naWMgdG9rZW5zLlxuICAgICAqXG4gICAgICogIEZvcm1hdDogeyUgZW5kaWYgJX1cbiAgICAgKi9cbiAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUuZW5kaWYsXG4gICAgcmVnZXg6IC9eZW5kaWYkLyxcbiAgICBuZXh0OiBbXSxcbiAgICBvcGVuOiBmYWxzZVxuICB9LCB7XG4gICAgLyoqXG4gICAgICogRm9yIHR5cGUgbG9naWMgdG9rZW5zLlxuICAgICAqXG4gICAgICogIEZvcm1hdDogeyUgZm9yIGV4cHJlc3Npb24gJX1cbiAgICAgKi9cbiAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUuZm9yXyxcbiAgICByZWdleDogL15mb3JcXHMrKFthLXpBLVowLTlfLFxcc10rKVxccytpblxccysoW1xcU1xcc10rPykoPzpcXHMraWZcXHMrKFteXFxzXS4qKSk/JC8sXG4gICAgbmV4dDogW1R3aWcubG9naWMudHlwZS5lbHNlXywgVHdpZy5sb2dpYy50eXBlLmVuZGZvcl0sXG4gICAgb3BlbjogdHJ1ZSxcbiAgICBjb21waWxlOiBmdW5jdGlvbiBjb21waWxlKHRva2VuKSB7XG4gICAgICB2YXIga2V5VmFsdWUgPSB0b2tlbi5tYXRjaFsxXTtcbiAgICAgIHZhciBleHByZXNzaW9uID0gdG9rZW4ubWF0Y2hbMl07XG4gICAgICB2YXIgY29uZGl0aW9uYWwgPSB0b2tlbi5tYXRjaFszXTtcbiAgICAgIHZhciBrdlNwbGl0ID0gbnVsbDtcbiAgICAgIHRva2VuLmtleVZhciA9IG51bGw7XG4gICAgICB0b2tlbi52YWx1ZVZhciA9IG51bGw7XG5cbiAgICAgIGlmIChrZXlWYWx1ZS5pbmNsdWRlcygnLCcpKSB7XG4gICAgICAgIGt2U3BsaXQgPSBrZXlWYWx1ZS5zcGxpdCgnLCcpO1xuXG4gICAgICAgIGlmIChrdlNwbGl0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHRva2VuLmtleVZhciA9IGt2U3BsaXRbMF0udHJpbSgpO1xuICAgICAgICAgIHRva2VuLnZhbHVlVmFyID0ga3ZTcGxpdFsxXS50cmltKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoJ0ludmFsaWQgZXhwcmVzc2lvbiBpbiBmb3IgbG9vcDogJyArIGtleVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rZW4udmFsdWVWYXIgPSBrZXlWYWx1ZS50cmltKCk7XG4gICAgICB9IC8vIFZhbGlkIGV4cHJlc3Npb25zIGZvciBhIGZvciBsb29wXG4gICAgICAvLyAgIGZvciBpdGVtICAgICBpbiBleHByZXNzaW9uXG4gICAgICAvLyAgIGZvciBrZXksaXRlbSBpbiBleHByZXNzaW9uXG4gICAgICAvLyBDb21waWxlIHRoZSBleHByZXNzaW9uLlxuXG5cbiAgICAgIHRva2VuLmV4cHJlc3Npb24gPSBUd2lnLmV4cHJlc3Npb24uY29tcGlsZS5jYWxsKHRoaXMsIHtcbiAgICAgICAgdHlwZTogVHdpZy5leHByZXNzaW9uLnR5cGUuZXhwcmVzc2lvbixcbiAgICAgICAgdmFsdWU6IGV4cHJlc3Npb25cbiAgICAgIH0pLnN0YWNrOyAvLyBDb21waWxlIHRoZSBjb25kaXRpb25hbCAoaWYgYXZhaWxhYmxlKVxuXG4gICAgICBpZiAoY29uZGl0aW9uYWwpIHtcbiAgICAgICAgdG9rZW4uY29uZGl0aW9uYWwgPSBUd2lnLmV4cHJlc3Npb24uY29tcGlsZS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5leHByZXNzaW9uLFxuICAgICAgICAgIHZhbHVlOiBjb25kaXRpb25hbFxuICAgICAgICB9KS5zdGFjaztcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIHRva2VuLm1hdGNoO1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHRva2VuLCBjb250ZXh0LCBjb250aW51ZUNoYWluKSB7XG4gICAgICAvLyBQYXJzZSBleHByZXNzaW9uXG4gICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICB2YXIgbGVuO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBrZXlzZXQ7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzO1xuICAgICAgdmFyIGNvbmRpdGlvbmFsID0gdG9rZW4uY29uZGl0aW9uYWw7XG5cbiAgICAgIHZhciBidWlsZExvb3AgPSBmdW5jdGlvbiBidWlsZExvb3AoaW5kZXgsIGxlbikge1xuICAgICAgICB2YXIgaXNDb25kaXRpb25hbCA9IGNvbmRpdGlvbmFsICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaW5kZXg6IGluZGV4ICsgMSxcbiAgICAgICAgICBpbmRleDA6IGluZGV4LFxuICAgICAgICAgIHJldmluZGV4OiBpc0NvbmRpdGlvbmFsID8gdW5kZWZpbmVkIDogbGVuIC0gaW5kZXgsXG4gICAgICAgICAgcmV2aW5kZXgwOiBpc0NvbmRpdGlvbmFsID8gdW5kZWZpbmVkIDogbGVuIC0gaW5kZXggLSAxLFxuICAgICAgICAgIGZpcnN0OiBpbmRleCA9PT0gMCxcbiAgICAgICAgICBsYXN0OiBpc0NvbmRpdGlvbmFsID8gdW5kZWZpbmVkIDogaW5kZXggPT09IGxlbiAtIDEsXG4gICAgICAgICAgbGVuZ3RoOiBpc0NvbmRpdGlvbmFsID8gdW5kZWZpbmVkIDogbGVuLFxuICAgICAgICAgIHBhcmVudDogY29udGV4dFxuICAgICAgICB9O1xuICAgICAgfTsgLy8gUnVuIG9uY2UgZm9yIGVhY2ggaXRlcmF0aW9uIG9mIHRoZSBsb29wXG5cblxuICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiBsb29wKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGlubmVyQ29udGV4dCA9IF9vYmplY3RTcHJlYWQoe30sIGNvbnRleHQpO1xuXG4gICAgICAgIGlubmVyQ29udGV4dFt0b2tlbi52YWx1ZVZhcl0gPSB2YWx1ZTtcblxuICAgICAgICBpZiAodG9rZW4ua2V5VmFyKSB7XG4gICAgICAgICAgaW5uZXJDb250ZXh0W3Rva2VuLmtleVZhcl0gPSBrZXk7XG4gICAgICAgIH0gLy8gTG9vcCBvYmplY3RcblxuXG4gICAgICAgIGlubmVyQ29udGV4dC5sb29wID0gYnVpbGRMb29wKGluZGV4LCBsZW4pO1xuICAgICAgICB2YXIgcHJvbWlzZSA9IGNvbmRpdGlvbmFsID09PSB1bmRlZmluZWQgPyBUd2lnLlByb21pc2UucmVzb2x2ZSh0cnVlKSA6IFR3aWcuZXhwcmVzc2lvbi5wYXJzZUFzeW5jLmNhbGwoc3RhdGUsIGNvbmRpdGlvbmFsLCBpbm5lckNvbnRleHQpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICAgICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdGF0ZS5wYXJzZUFzeW5jKHRva2VuLm91dHB1dCwgaW5uZXJDb250ZXh0KS50aGVuKGZ1bmN0aW9uICh0b2tlbk91dHB1dCkge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2godG9rZW5PdXRwdXQpO1xuICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gRGVsZXRlIGxvb3AtcmVsYXRlZCB2YXJpYWJsZXMgZnJvbSB0aGUgY29udGV4dFxuICAgICAgICAgIGRlbGV0ZSBpbm5lckNvbnRleHQubG9vcDtcbiAgICAgICAgICBkZWxldGUgaW5uZXJDb250ZXh0W3Rva2VuLnZhbHVlVmFyXTtcbiAgICAgICAgICBkZWxldGUgaW5uZXJDb250ZXh0W3Rva2VuLmtleVZhcl07IC8vIE1lcmdlIGluIHZhbHVlcyB0aGF0IGV4aXN0IGluIGNvbnRleHQgYnV0IGhhdmUgY2hhbmdlZFxuICAgICAgICAgIC8vIGluIGlubmVyX2NvbnRleHQuXG5cbiAgICAgICAgICBUd2lnLm1lcmdlKGNvbnRleHQsIGlubmVyQ29udGV4dCwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIFR3aWcuZXhwcmVzc2lvbi5wYXJzZUFzeW5jLmNhbGwoc3RhdGUsIHRva2VuLmV4cHJlc3Npb24sIGNvbnRleHQpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgICAgbGVuID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gVHdpZy5hc3luYy5mb3JFYWNoKHJlc3VsdCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gaW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gbG9vcChrZXksIHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChUd2lnLmxpYi5pcygnT2JqZWN0JywgcmVzdWx0KSkge1xuICAgICAgICAgIGlmIChyZXN1bHQuX2tleXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAga2V5c2V0ID0gT2JqZWN0LmtleXMocmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5c2V0ID0gcmVzdWx0Ll9rZXlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxlbiA9IGtleXNldC5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIFR3aWcuYXN5bmMuZm9yRWFjaChrZXlzZXQsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSB0aGUgX2tleXMgcHJvcGVydHksIGl0J3MgaW50ZXJuYWwgdG8gdHdpZy5qc1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ19rZXlzJykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBsb29wKGtleSwgcmVzdWx0W2tleV0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gT25seSBhbGxvdyBlbHNlIHN0YXRlbWVudHMgaWYgbm8gb3V0cHV0IHdhcyBnZW5lcmF0ZWRcbiAgICAgICAgY29udGludWVDaGFpbiA9IG91dHB1dC5sZW5ndGggPT09IDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hhaW46IGNvbnRpbnVlQ2hhaW4sXG4gICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICBvdXRwdXQ6IFR3aWcub3V0cHV0LmNhbGwoc3RhdGUudGVtcGxhdGUsIG91dHB1dClcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIC8qKlxuICAgICAqIEVuZCBmb3IgdHlwZSBsb2dpYyB0b2tlbnMuXG4gICAgICpcbiAgICAgKiAgRm9ybWF0OiB7JSBlbmRmb3IgJX1cbiAgICAgKi9cbiAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUuZW5kZm9yLFxuICAgIHJlZ2V4OiAvXmVuZGZvciQvLFxuICAgIG5leHQ6IFtdLFxuICAgIG9wZW46IGZhbHNlXG4gIH0sIHtcbiAgICAvKipcbiAgICAgKiBTZXQgdHlwZSBsb2dpYyB0b2tlbnMuXG4gICAgICpcbiAgICAgKiAgRm9ybWF0OiB7JSBzZXQga2V5ID0gZXhwcmVzc2lvbiAlfVxuICAgICAqL1xuICAgIHR5cGU6IFR3aWcubG9naWMudHlwZS5zZXQsXG4gICAgcmVnZXg6IC9ec2V0XFxzKyhbYS16QS1aMC05XyxcXHNdKylcXHMqPVxccyooW1xcc1xcU10rKSQvLFxuICAgIG5leHQ6IFtdLFxuICAgIG9wZW46IHRydWUsXG4gICAgY29tcGlsZTogZnVuY3Rpb24gY29tcGlsZSh0b2tlbikge1xuICAgICAgLy9cbiAgICAgIHZhciBrZXkgPSB0b2tlbi5tYXRjaFsxXS50cmltKCk7XG4gICAgICB2YXIgZXhwcmVzc2lvbiA9IHRva2VuLm1hdGNoWzJdOyAvLyBDb21waWxlIHRoZSBleHByZXNzaW9uLlxuXG4gICAgICB2YXIgZXhwcmVzc2lvblN0YWNrID0gVHdpZy5leHByZXNzaW9uLmNvbXBpbGUuY2FsbCh0aGlzLCB7XG4gICAgICAgIHR5cGU6IFR3aWcuZXhwcmVzc2lvbi50eXBlLmV4cHJlc3Npb24sXG4gICAgICAgIHZhbHVlOiBleHByZXNzaW9uXG4gICAgICB9KS5zdGFjaztcbiAgICAgIHRva2VuLmtleSA9IGtleTtcbiAgICAgIHRva2VuLmV4cHJlc3Npb24gPSBleHByZXNzaW9uU3RhY2s7XG4gICAgICBkZWxldGUgdG9rZW4ubWF0Y2g7XG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UodG9rZW4sIGNvbnRleHQsIGNvbnRpbnVlQ2hhaW4pIHtcbiAgICAgIHZhciBrZXkgPSB0b2tlbi5rZXk7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzO1xuICAgICAgcmV0dXJuIFR3aWcuZXhwcmVzc2lvbi5wYXJzZUFzeW5jLmNhbGwoc3RhdGUsIHRva2VuLmV4cHJlc3Npb24sIGNvbnRleHQpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gY29udGV4dCkge1xuICAgICAgICAgIC8qICBJZiBzdG9yaW5nIHRoZSBjb250ZXh0IGluIGEgdmFyaWFibGUsIGl0IG5lZWRzIHRvIGJlIGEgY2xvbmUgb2YgdGhlIGN1cnJlbnQgc3RhdGUgb2YgY29udGV4dC5cbiAgICAgICAgICAgICAgT3RoZXJ3aXNlIHdlIGhhdmUgYSBjb250ZXh0IHdpdGggaW5maW5pdGUgcmVjdXJzaW9uLlxuICAgICAgICAgICAgICBGaXhlcyAjMzQxXG4gICAgICAgICAgKi9cbiAgICAgICAgICB2YWx1ZSA9IF9vYmplY3RTcHJlYWQoe30sIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHRba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoYWluOiBjb250aW51ZUNoYWluLFxuICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIC8qKlxuICAgICAqIFNldCBjYXB0dXJlIHR5cGUgbG9naWMgdG9rZW5zLlxuICAgICAqXG4gICAgICogIEZvcm1hdDogeyUgc2V0IGtleSAlfVxuICAgICAqL1xuICAgIHR5cGU6IFR3aWcubG9naWMudHlwZS5zZXRjYXB0dXJlLFxuICAgIHJlZ2V4OiAvXnNldFxccysoW2EtekEtWjAtOV8sXFxzXSspJC8sXG4gICAgbmV4dDogW1R3aWcubG9naWMudHlwZS5lbmRzZXRdLFxuICAgIG9wZW46IHRydWUsXG4gICAgY29tcGlsZTogZnVuY3Rpb24gY29tcGlsZSh0b2tlbikge1xuICAgICAgdmFyIGtleSA9IHRva2VuLm1hdGNoWzFdLnRyaW0oKTtcbiAgICAgIHRva2VuLmtleSA9IGtleTtcbiAgICAgIGRlbGV0ZSB0b2tlbi5tYXRjaDtcbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSh0b2tlbiwgY29udGV4dCwgY29udGludWVDaGFpbikge1xuICAgICAgdmFyIHN0YXRlID0gdGhpcztcbiAgICAgIHZhciBrZXkgPSB0b2tlbi5rZXk7XG4gICAgICByZXR1cm4gc3RhdGUucGFyc2VBc3luYyh0b2tlbi5vdXRwdXQsIGNvbnRleHQpLnRoZW4oZnVuY3Rpb24gKG91dHB1dCkge1xuICAgICAgICAvLyBTZXQgb24gYm90aCB0aGUgZ2xvYmFsIGFuZCBsb2NhbCBjb250ZXh0XG4gICAgICAgIHN0YXRlLmNvbnRleHRba2V5XSA9IG91dHB1dDtcbiAgICAgICAgY29udGV4dFtrZXldID0gb3V0cHV0O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoYWluOiBjb250aW51ZUNoYWluLFxuICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIC8qKlxuICAgICAqIEVuZCBzZXQgdHlwZSBibG9jayBsb2dpYyB0b2tlbnMuXG4gICAgICpcbiAgICAgKiAgRm9ybWF0OiB7JSBlbmRzZXQgJX1cbiAgICAgKi9cbiAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUuZW5kc2V0LFxuICAgIHJlZ2V4OiAvXmVuZHNldCQvLFxuICAgIG5leHQ6IFtdLFxuICAgIG9wZW46IGZhbHNlXG4gIH0sIHtcbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgbG9naWMgdG9rZW5zLlxuICAgICAqXG4gICAgICogIEZvcm1hdDogeyUgZmlsdGVyIHVwcGVyICV9IG9yIHslIGZpbHRlciBsb3dlcnxlc2NhcGUgJX1cbiAgICAgKi9cbiAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUuZmlsdGVyLFxuICAgIHJlZ2V4OiAvXmZpbHRlclxccysoLispJC8sXG4gICAgbmV4dDogW1R3aWcubG9naWMudHlwZS5lbmRmaWx0ZXJdLFxuICAgIG9wZW46IHRydWUsXG4gICAgY29tcGlsZTogZnVuY3Rpb24gY29tcGlsZSh0b2tlbikge1xuICAgICAgdmFyIGV4cHJlc3Npb24gPSAnfCcgKyB0b2tlbi5tYXRjaFsxXS50cmltKCk7IC8vIENvbXBpbGUgdGhlIGV4cHJlc3Npb24uXG5cbiAgICAgIHRva2VuLnN0YWNrID0gVHdpZy5leHByZXNzaW9uLmNvbXBpbGUuY2FsbCh0aGlzLCB7XG4gICAgICAgIHR5cGU6IFR3aWcuZXhwcmVzc2lvbi50eXBlLmV4cHJlc3Npb24sXG4gICAgICAgIHZhbHVlOiBleHByZXNzaW9uXG4gICAgICB9KS5zdGFjaztcbiAgICAgIGRlbGV0ZSB0b2tlbi5tYXRjaDtcbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSh0b2tlbiwgY29udGV4dCwgY2hhaW4pIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXM7XG4gICAgICByZXR1cm4gc3RhdGUucGFyc2VBc3luYyh0b2tlbi5vdXRwdXQsIGNvbnRleHQpLnRoZW4oZnVuY3Rpb24gKG91dHB1dCkge1xuICAgICAgICB2YXIgc3RhY2sgPSBbe1xuICAgICAgICAgIHR5cGU6IFR3aWcuZXhwcmVzc2lvbi50eXBlLnN0cmluZyxcbiAgICAgICAgICB2YWx1ZTogb3V0cHV0XG4gICAgICAgIH1dLmNvbmNhdCh0b2tlbi5zdGFjayk7XG4gICAgICAgIHJldHVybiBUd2lnLmV4cHJlc3Npb24ucGFyc2VBc3luYy5jYWxsKHN0YXRlLCBzdGFjaywgY29udGV4dCk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChvdXRwdXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjaGFpbjogY2hhaW4sXG4gICAgICAgICAgb3V0cHV0OiBvdXRwdXRcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIC8qKlxuICAgICAqIEVuZCBmaWx0ZXIgbG9naWMgdG9rZW5zLlxuICAgICAqXG4gICAgICogIEZvcm1hdDogeyUgZW5kZmlsdGVyICV9XG4gICAgICovXG4gICAgdHlwZTogVHdpZy5sb2dpYy50eXBlLmVuZGZpbHRlcixcbiAgICByZWdleDogL15lbmRmaWx0ZXIkLyxcbiAgICBuZXh0OiBbXSxcbiAgICBvcGVuOiBmYWxzZVxuICB9LCB7XG4gICAgLyoqXG4gICAgICogQXBwbHkgbG9naWMgdG9rZW5zLlxuICAgICAqXG4gICAgICogIEZvcm1hdDogeyUgYXBwbHkgdXBwZXIgJX0gb3IgeyUgYXBwbHkgbG93ZXJ8ZXNjYXBlICV9XG4gICAgICovXG4gICAgdHlwZTogVHdpZy5sb2dpYy50eXBlLmFwcGx5LFxuICAgIHJlZ2V4OiAvXmFwcGx5XFxzKyguKykkLyxcbiAgICBuZXh0OiBbVHdpZy5sb2dpYy50eXBlLmVuZGFwcGx5XSxcbiAgICBvcGVuOiB0cnVlLFxuICAgIGNvbXBpbGU6IGZ1bmN0aW9uIGNvbXBpbGUodG9rZW4pIHtcbiAgICAgIHZhciBleHByZXNzaW9uID0gJ3wnICsgdG9rZW4ubWF0Y2hbMV0udHJpbSgpOyAvLyBDb21waWxlIHRoZSBleHByZXNzaW9uLlxuXG4gICAgICB0b2tlbi5zdGFjayA9IFR3aWcuZXhwcmVzc2lvbi5jb21waWxlLmNhbGwodGhpcywge1xuICAgICAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5leHByZXNzaW9uLFxuICAgICAgICB2YWx1ZTogZXhwcmVzc2lvblxuICAgICAgfSkuc3RhY2s7XG4gICAgICBkZWxldGUgdG9rZW4ubWF0Y2g7XG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UodG9rZW4sIGNvbnRleHQsIGNoYWluKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzO1xuICAgICAgcmV0dXJuIHN0YXRlLnBhcnNlQXN5bmModG9rZW4ub3V0cHV0LCBjb250ZXh0KS50aGVuKGZ1bmN0aW9uIChvdXRwdXQpIHtcbiAgICAgICAgdmFyIHN0YWNrID0gW3tcbiAgICAgICAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5zdHJpbmcsXG4gICAgICAgICAgdmFsdWU6IG91dHB1dFxuICAgICAgICB9XS5jb25jYXQodG9rZW4uc3RhY2spO1xuICAgICAgICByZXR1cm4gVHdpZy5leHByZXNzaW9uLnBhcnNlQXN5bmMuY2FsbChzdGF0ZSwgc3RhY2ssIGNvbnRleHQpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAob3V0cHV0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICAgIG91dHB1dDogb3V0cHV0XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICAvKipcbiAgICAgKiBFbmQgYXBwbHkgbG9naWMgdG9rZW5zLlxuICAgICAqXG4gICAgICogIEZvcm1hdDogeyUgZW5kYXBwbHkgJX1cbiAgICAgKi9cbiAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUuZW5kYXBwbHksXG4gICAgcmVnZXg6IC9eZW5kYXBwbHkkLyxcbiAgICBuZXh0OiBbXSxcbiAgICBvcGVuOiBmYWxzZVxuICB9LCB7XG4gICAgLyoqXG4gICAgICogU2V0IHR5cGUgbG9naWMgdG9rZW5zLlxuICAgICAqXG4gICAgICogIEZvcm1hdDogeyUgZG8gZXhwcmVzc2lvbiAlfVxuICAgICAqL1xuICAgIHR5cGU6IFR3aWcubG9naWMudHlwZVtcImRvXCJdLFxuICAgIHJlZ2V4OiAvXmRvXFxzKyhbXFxTXFxzXSspJC8sXG4gICAgbmV4dDogW10sXG4gICAgb3BlbjogdHJ1ZSxcbiAgICBjb21waWxlOiBmdW5jdGlvbiBjb21waWxlKHRva2VuKSB7XG4gICAgICAvL1xuICAgICAgdmFyIGV4cHJlc3Npb24gPSB0b2tlbi5tYXRjaFsxXTsgLy8gQ29tcGlsZSB0aGUgZXhwcmVzc2lvbi5cblxuICAgICAgdmFyIGV4cHJlc3Npb25TdGFjayA9IFR3aWcuZXhwcmVzc2lvbi5jb21waWxlLmNhbGwodGhpcywge1xuICAgICAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5leHByZXNzaW9uLFxuICAgICAgICB2YWx1ZTogZXhwcmVzc2lvblxuICAgICAgfSkuc3RhY2s7XG4gICAgICB0b2tlbi5leHByZXNzaW9uID0gZXhwcmVzc2lvblN0YWNrO1xuICAgICAgZGVsZXRlIHRva2VuLm1hdGNoO1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHRva2VuLCBjb250ZXh0LCBjb250aW51ZUNoYWluKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzO1xuICAgICAgcmV0dXJuIFR3aWcuZXhwcmVzc2lvbi5wYXJzZUFzeW5jLmNhbGwoc3RhdGUsIHRva2VuLmV4cHJlc3Npb24sIGNvbnRleHQpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoYWluOiBjb250aW51ZUNoYWluLFxuICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIC8qKlxuICAgICAqIEJsb2NrIGxvZ2ljIHRva2Vucy5cbiAgICAgKlxuICAgICAqICBGb3JtYXQ6IHslIGJsb2NrIHRpdGxlICV9XG4gICAgICovXG4gICAgdHlwZTogVHdpZy5sb2dpYy50eXBlLmJsb2NrLFxuICAgIHJlZ2V4OiAvXmJsb2NrXFxzKyhcXHcrKSQvLFxuICAgIG5leHQ6IFtUd2lnLmxvZ2ljLnR5cGUuZW5kYmxvY2tdLFxuICAgIG9wZW46IHRydWUsXG4gICAgY29tcGlsZTogZnVuY3Rpb24gY29tcGlsZSh0b2tlbikge1xuICAgICAgdG9rZW4uYmxvY2tOYW1lID0gdG9rZW4ubWF0Y2hbMV0udHJpbSgpO1xuICAgICAgZGVsZXRlIHRva2VuLm1hdGNoO1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHRva2VuLCBjb250ZXh0LCBjaGFpbikge1xuICAgICAgdmFyIHN0YXRlID0gdGhpcztcbiAgICAgIHZhciBwcm9taXNlID0gVHdpZy5Qcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIHN0YXRlLnRlbXBsYXRlLmJsb2Nrcy5kZWZpbmVkW3Rva2VuLmJsb2NrTmFtZV0gPSBuZXcgVHdpZy5CbG9jayhzdGF0ZS50ZW1wbGF0ZSwgdG9rZW4pO1xuXG4gICAgICBpZiAoc3RhdGUudGVtcGxhdGUucGFyZW50VGVtcGxhdGUgPT09IG51bGwgfHwgc3RhdGUudGVtcGxhdGUucGFyZW50VGVtcGxhdGUgaW5zdGFuY2VvZiBUd2lnLlRlbXBsYXRlKSB7XG4gICAgICAgIHByb21pc2UgPSBzdGF0ZS5nZXRCbG9jayh0b2tlbi5ibG9ja05hbWUpLnJlbmRlcihzdGF0ZSwgY29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKG91dHB1dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoYWluOiBjaGFpbixcbiAgICAgICAgICBvdXRwdXQ6IG91dHB1dFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAgLyoqXG4gICAgICogQmxvY2sgc2hvcnRoYW5kIGxvZ2ljIHRva2Vucy5cbiAgICAgKlxuICAgICAqICBGb3JtYXQ6IHslIGJsb2NrIHRpdGxlIGV4cHJlc3Npb24gJX1cbiAgICAgKi9cbiAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUuc2hvcnRibG9jayxcbiAgICByZWdleDogL15ibG9ja1xccysoXFx3KylcXHMrKC4rKSQvLFxuICAgIG5leHQ6IFtdLFxuICAgIG9wZW46IHRydWUsXG4gICAgY29tcGlsZTogZnVuY3Rpb24gY29tcGlsZSh0b2tlbikge1xuICAgICAgdmFyIHRlbXBsYXRlID0gdGhpcztcbiAgICAgIHRva2VuLmV4cHJlc3Npb24gPSB0b2tlbi5tYXRjaFsyXS50cmltKCk7XG4gICAgICB0b2tlbi5vdXRwdXQgPSBUd2lnLmV4cHJlc3Npb24uY29tcGlsZSh7XG4gICAgICAgIHR5cGU6IFR3aWcuZXhwcmVzc2lvbi50eXBlLmV4cHJlc3Npb24sXG4gICAgICAgIHZhbHVlOiB0b2tlbi5leHByZXNzaW9uXG4gICAgICB9KS5zdGFjaztcbiAgICAgIHJldHVybiBUd2lnLmxvZ2ljLmhhbmRsZXJbVHdpZy5sb2dpYy50eXBlLmJsb2NrXS5jb21waWxlLmFwcGx5KHRlbXBsYXRlLCBbdG9rZW5dKTtcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSgpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gVHdpZy5sb2dpYy5oYW5kbGVyW1R3aWcubG9naWMudHlwZS5ibG9ja10ucGFyc2UuYXBwbHkoc3RhdGUsIGFyZ3MpO1xuICAgIH1cbiAgfSwge1xuICAgIC8qKlxuICAgICAqIEVuZCBibG9jayBsb2dpYyB0b2tlbnMuXG4gICAgICpcbiAgICAgKiAgRm9ybWF0OiB7JSBlbmRibG9jayAlfVxuICAgICAqL1xuICAgIHR5cGU6IFR3aWcubG9naWMudHlwZS5lbmRibG9jayxcbiAgICByZWdleDogL15lbmRibG9jayg/OlxccysoXFx3KykpPyQvLFxuICAgIG5leHQ6IFtdLFxuICAgIG9wZW46IGZhbHNlXG4gIH0sIHtcbiAgICAvKipcbiAgICAgKiBCbG9jayBsb2dpYyB0b2tlbnMuXG4gICAgICpcbiAgICAgKiAgRm9ybWF0OiB7JSBleHRlbmRzIFwidGVtcGxhdGUudHdpZ1wiICV9XG4gICAgICovXG4gICAgdHlwZTogVHdpZy5sb2dpYy50eXBlLmV4dGVuZHNfLFxuICAgIHJlZ2V4OiAvXmV4dGVuZHNcXHMrKC4rKSQvLFxuICAgIG5leHQ6IFtdLFxuICAgIG9wZW46IHRydWUsXG4gICAgY29tcGlsZTogZnVuY3Rpb24gY29tcGlsZSh0b2tlbikge1xuICAgICAgdmFyIGV4cHJlc3Npb24gPSB0b2tlbi5tYXRjaFsxXS50cmltKCk7XG4gICAgICBkZWxldGUgdG9rZW4ubWF0Y2g7XG4gICAgICB0b2tlbi5zdGFjayA9IFR3aWcuZXhwcmVzc2lvbi5jb21waWxlLmNhbGwodGhpcywge1xuICAgICAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5leHByZXNzaW9uLFxuICAgICAgICB2YWx1ZTogZXhwcmVzc2lvblxuICAgICAgfSkuc3RhY2s7XG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UodG9rZW4sIGNvbnRleHQsIGNoYWluKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzO1xuICAgICAgcmV0dXJuIFR3aWcuZXhwcmVzc2lvbi5wYXJzZUFzeW5jLmNhbGwoc3RhdGUsIHRva2VuLnN0YWNrLCBjb250ZXh0KS50aGVuKGZ1bmN0aW9uIChmaWxlTmFtZSkge1xuICAgICAgICBzdGF0ZS50ZW1wbGF0ZS5wYXJlbnRUZW1wbGF0ZSA9IGZpbGVOYW1lO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoYWluOiBjaGFpbixcbiAgICAgICAgICBvdXRwdXQ6ICcnXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICAvKipcbiAgICAgKiBCbG9jayBsb2dpYyB0b2tlbnMuXG4gICAgICpcbiAgICAgKiAgRm9ybWF0OiB7JSB1c2UgXCJ0ZW1wbGF0ZS50d2lnXCIgJX1cbiAgICAgKi9cbiAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUudXNlLFxuICAgIHJlZ2V4OiAvXnVzZVxccysoLispJC8sXG4gICAgbmV4dDogW10sXG4gICAgb3BlbjogdHJ1ZSxcbiAgICBjb21waWxlOiBmdW5jdGlvbiBjb21waWxlKHRva2VuKSB7XG4gICAgICB2YXIgZXhwcmVzc2lvbiA9IHRva2VuLm1hdGNoWzFdLnRyaW0oKTtcbiAgICAgIGRlbGV0ZSB0b2tlbi5tYXRjaDtcbiAgICAgIHRva2VuLnN0YWNrID0gVHdpZy5leHByZXNzaW9uLmNvbXBpbGUuY2FsbCh0aGlzLCB7XG4gICAgICAgIHR5cGU6IFR3aWcuZXhwcmVzc2lvbi50eXBlLmV4cHJlc3Npb24sXG4gICAgICAgIHZhbHVlOiBleHByZXNzaW9uXG4gICAgICB9KS5zdGFjaztcbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSh0b2tlbiwgY29udGV4dCwgY2hhaW4pIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXM7XG4gICAgICByZXR1cm4gVHdpZy5leHByZXNzaW9uLnBhcnNlQXN5bmMuY2FsbChzdGF0ZSwgdG9rZW4uc3RhY2ssIGNvbnRleHQpLnRoZW4oZnVuY3Rpb24gKGZpbGVQYXRoKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBzdGF0ZSBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICAgIC8vIGFueSBkZWZpbmVkIGJsb2NrcyB3aWxsIGJlIGNyZWF0ZWQgaW4gaXNvbGF0aW9uXG4gICAgICAgIHZhciB1c2VUZW1wbGF0ZSA9IHN0YXRlLnRlbXBsYXRlLmltcG9ydEZpbGUoZmlsZVBhdGgpO1xuICAgICAgICB2YXIgdXNlU3RhdGUgPSBuZXcgVHdpZy5QYXJzZVN0YXRlKHVzZVRlbXBsYXRlKTtcbiAgICAgICAgcmV0dXJuIHVzZVN0YXRlLnBhcnNlQXN5bmModXNlVGVtcGxhdGUudG9rZW5zKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdGF0ZS50ZW1wbGF0ZS5ibG9ja3MuaW1wb3J0ZWQgPSBfb2JqZWN0U3ByZWFkKHt9LCBzdGF0ZS50ZW1wbGF0ZS5ibG9ja3MuaW1wb3J0ZWQsIHt9LCB1c2VTdGF0ZS5nZXRCbG9ja3MoKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICAgIG91dHB1dDogJydcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIC8qKlxuICAgICAqIEJsb2NrIGxvZ2ljIHRva2Vucy5cbiAgICAgKlxuICAgICAqICBGb3JtYXQ6IHslIGluY2x1ZGVzIFwidGVtcGxhdGUudHdpZ1wiIFt3aXRoIHtzb21lOiAndmFsdWVzJ30gb25seV0gJX1cbiAgICAgKi9cbiAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUuaW5jbHVkZSxcbiAgICByZWdleDogL15pbmNsdWRlXFxzKyguKz8pKD86XFxzfCQpKGlnbm9yZSBtaXNzaW5nKD86XFxzfCQpKT8oPzp3aXRoXFxzKyhbXFxTXFxzXSs/KSk/KD86XFxzfCQpKG9ubHkpPyQvLFxuICAgIG5leHQ6IFtdLFxuICAgIG9wZW46IHRydWUsXG4gICAgY29tcGlsZTogZnVuY3Rpb24gY29tcGlsZSh0b2tlbikge1xuICAgICAgdmFyIG1hdGNoID0gdG9rZW4ubWF0Y2g7XG4gICAgICB2YXIgZXhwcmVzc2lvbiA9IG1hdGNoWzFdLnRyaW0oKTtcbiAgICAgIHZhciBpZ25vcmVNaXNzaW5nID0gbWF0Y2hbMl0gIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciB3aXRoQ29udGV4dCA9IG1hdGNoWzNdO1xuICAgICAgdmFyIG9ubHkgPSBtYXRjaFs0XSAhPT0gdW5kZWZpbmVkICYmIG1hdGNoWzRdLmxlbmd0aDtcbiAgICAgIGRlbGV0ZSB0b2tlbi5tYXRjaDtcbiAgICAgIHRva2VuLm9ubHkgPSBvbmx5O1xuICAgICAgdG9rZW4uaWdub3JlTWlzc2luZyA9IGlnbm9yZU1pc3Npbmc7XG4gICAgICB0b2tlbi5zdGFjayA9IFR3aWcuZXhwcmVzc2lvbi5jb21waWxlLmNhbGwodGhpcywge1xuICAgICAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5leHByZXNzaW9uLFxuICAgICAgICB2YWx1ZTogZXhwcmVzc2lvblxuICAgICAgfSkuc3RhY2s7XG5cbiAgICAgIGlmICh3aXRoQ29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRva2VuLndpdGhTdGFjayA9IFR3aWcuZXhwcmVzc2lvbi5jb21waWxlLmNhbGwodGhpcywge1xuICAgICAgICAgIHR5cGU6IFR3aWcuZXhwcmVzc2lvbi50eXBlLmV4cHJlc3Npb24sXG4gICAgICAgICAgdmFsdWU6IHdpdGhDb250ZXh0LnRyaW0oKVxuICAgICAgICB9KS5zdGFjaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHRva2VuLCBjb250ZXh0LCBjaGFpbikge1xuICAgICAgLy8gUmVzb2x2ZSBmaWxlbmFtZVxuICAgICAgdmFyIGlubmVyQ29udGV4dCA9IHRva2VuLm9ubHkgPyB7fSA6IF9vYmplY3RTcHJlYWQoe30sIGNvbnRleHQpO1xuICAgICAgdmFyIGlnbm9yZU1pc3NpbmcgPSB0b2tlbi5pZ25vcmVNaXNzaW5nO1xuICAgICAgdmFyIHN0YXRlID0gdGhpcztcbiAgICAgIHZhciBwcm9taXNlID0gbnVsbDtcbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIGNoYWluOiBjaGFpbixcbiAgICAgICAgb3V0cHV0OiAnJ1xuICAgICAgfTtcblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbi53aXRoU3RhY2sgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHByb21pc2UgPSBUd2lnLlByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZSA9IFR3aWcuZXhwcmVzc2lvbi5wYXJzZUFzeW5jLmNhbGwoc3RhdGUsIHRva2VuLndpdGhTdGFjaywgY29udGV4dCkudGhlbihmdW5jdGlvbiAod2l0aENvbnRleHQpIHtcbiAgICAgICAgICBpbm5lckNvbnRleHQgPSBfb2JqZWN0U3ByZWFkKHt9LCBpbm5lckNvbnRleHQsIHt9LCB3aXRoQ29udGV4dCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFR3aWcuZXhwcmVzc2lvbi5wYXJzZUFzeW5jLmNhbGwoc3RhdGUsIHRva2VuLnN0YWNrLCBjb250ZXh0KTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgdmFyIGZpbGVzO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpbGUpKSB7XG4gICAgICAgICAgZmlsZXMgPSBmaWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbGVzID0gW2ZpbGVdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IGZpbGVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBmaWxlKSB7XG4gICAgICAgICAgaWYgKGFjYy5yZW5kZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChmaWxlIGluc3RhbmNlb2YgVHdpZy5UZW1wbGF0ZSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlbmRlcjogZmlsZS5yZW5kZXJBc3luYyhpbm5lckNvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgIGlzSW5jbHVkZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGxhc3RFcnJvcjogbnVsbFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlbmRlcjogc3RhdGUudGVtcGxhdGUuaW1wb3J0RmlsZShmaWxlKS5yZW5kZXJBc3luYyhpbm5lckNvbnRleHQsIHtcbiAgICAgICAgICAgICAgICAgIGlzSW5jbHVkZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGxhc3RFcnJvcjogbnVsbFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZW5kZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgbGFzdEVycm9yOiBlcnJvclxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICByZW5kZXI6IG51bGwsXG4gICAgICAgICAgbGFzdEVycm9yOiBudWxsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyZXN1bHQucmVuZGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZW5kZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0LnJlbmRlciA9PT0gbnVsbCAmJiBpZ25vcmVNaXNzaW5nKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgcmVzdWx0Lmxhc3RFcnJvcjtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKG91dHB1dCkge1xuICAgICAgICBpZiAob3V0cHV0ICE9PSAnJykge1xuICAgICAgICAgIHJlc3VsdC5vdXRwdXQgPSBvdXRwdXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAgdHlwZTogVHdpZy5sb2dpYy50eXBlLnNwYWNlbGVzcyxcbiAgICByZWdleDogL15zcGFjZWxlc3MkLyxcbiAgICBuZXh0OiBbVHdpZy5sb2dpYy50eXBlLmVuZHNwYWNlbGVzc10sXG4gICAgb3BlbjogdHJ1ZSxcbiAgICAvLyBQYXJzZSB0aGUgaHRtbCBhbmQgcmV0dXJuIGl0IHdpdGhvdXQgYW55IHNwYWNlcyBiZXR3ZWVuIHRhZ3NcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UodG9rZW4sIGNvbnRleHQsIGNoYWluKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzOyAvLyBQYXJzZSB0aGUgb3V0cHV0IHdpdGhvdXQgYW55IGZpbHRlclxuXG4gICAgICByZXR1cm4gc3RhdGUucGFyc2VBc3luYyh0b2tlbi5vdXRwdXQsIGNvbnRleHQpLnRoZW4oZnVuY3Rpb24gKHRva2VuT3V0cHV0KSB7XG4gICAgICAgIHZhciAvLyBBIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBmaW5kIGNsb3NpbmcgYW5kIG9wZW5pbmcgdGFncyB3aXRoIHNwYWNlcyBiZXR3ZWVuIHRoZW1cbiAgICAgICAgckJldHdlZW5UYWdTcGFjZXMgPSAvPlxccys8L2c7IC8vIFJlcGxhY2UgYWxsIHNwYWNlIGJldHdlZW4gY2xvc2luZyBhbmQgb3BlbmluZyBodG1sIHRhZ3NcblxuICAgICAgICB2YXIgb3V0cHV0ID0gdG9rZW5PdXRwdXQucmVwbGFjZShyQmV0d2VlblRhZ1NwYWNlcywgJz48JykudHJpbSgpOyAvLyBSZXdyYXAgb3V0cHV0IGFzIGEgVHdpZy5NYXJrdXBcblxuICAgICAgICBvdXRwdXQgPSBuZXcgVHdpZy5NYXJrdXAob3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjaGFpbjogY2hhaW4sXG4gICAgICAgICAgb3V0cHV0OiBvdXRwdXRcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgLy8gQWRkIHRoZSB7JSBlbmRzcGFjZWxlc3MgJX0gdG9rZW5cbiAge1xuICAgIHR5cGU6IFR3aWcubG9naWMudHlwZS5lbmRzcGFjZWxlc3MsXG4gICAgcmVnZXg6IC9eZW5kc3BhY2VsZXNzJC8sXG4gICAgbmV4dDogW10sXG4gICAgb3BlbjogZmFsc2VcbiAgfSwge1xuICAgIC8qKlxuICAgICAqIE1hY3JvIGxvZ2ljIHRva2Vucy5cbiAgICAgKlxuICAgICAqIEZvcm1hdDogeyUgbWFjcm8gaW5wdXQobmFtZSA9IGRlZmF1bHQsIHZhbHVlLCB0eXBlLCBzaXplKSAlfVxuICAgICAqXG4gICAgICovXG4gICAgdHlwZTogVHdpZy5sb2dpYy50eXBlLm1hY3JvLFxuICAgIHJlZ2V4OiAvXm1hY3JvXFxzKyhcXHcrKVxccypcXChcXHMqKCg/OlxcdysoPzpcXHMqPVxccyooW1xcc1xcU10rKSk/KD86LFxccyopPykqKVxccypcXCkkLyxcbiAgICBuZXh0OiBbVHdpZy5sb2dpYy50eXBlLmVuZG1hY3JvXSxcbiAgICBvcGVuOiB0cnVlLFxuICAgIGNvbXBpbGU6IGZ1bmN0aW9uIGNvbXBpbGUodG9rZW4pIHtcbiAgICAgIHZhciBtYWNyb05hbWUgPSB0b2tlbi5tYXRjaFsxXTtcbiAgICAgIHZhciByYXdQYXJhbWV0ZXJzID0gdG9rZW4ubWF0Y2hbMl0uc3BsaXQoL1xccyosXFxzKi8pO1xuICAgICAgdmFyIHBhcmFtZXRlcnMgPSByYXdQYXJhbWV0ZXJzLm1hcChmdW5jdGlvbiAocmF3UGFyYW1ldGVyKSB7XG4gICAgICAgIHJldHVybiByYXdQYXJhbWV0ZXIuc3BsaXQoL1xccyo9XFxzKi8pWzBdO1xuICAgICAgfSk7XG4gICAgICB2YXIgcGFyYW1ldGVyc0NvdW50ID0gcGFyYW1ldGVycy5sZW5ndGg7IC8vIER1cGxpY2F0ZSBjaGVja1xuXG4gICAgICBpZiAocGFyYW1ldGVyc0NvdW50ID4gMSkge1xuICAgICAgICB2YXIgdW5pcSA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1ldGVyc0NvdW50OyBpKyspIHtcbiAgICAgICAgICB2YXIgcGFyYW1ldGVyID0gcGFyYW1ldGVyc1tpXTtcblxuICAgICAgICAgIGlmICh1bmlxW3BhcmFtZXRlcl0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKCdEdXBsaWNhdGUgYXJndW1lbnRzIGZvciBwYXJhbWV0ZXI6ICcgKyBwYXJhbWV0ZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bmlxW3BhcmFtZXRlcl0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0b2tlbi5tYWNyb05hbWUgPSBtYWNyb05hbWU7XG4gICAgICB0b2tlbi5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICAgIHRva2VuLmRlZmF1bHRzID0gcmF3UGFyYW1ldGVycy5yZWR1Y2UoZnVuY3Rpb24gKGRlZmF1bHRzLCByYXdQYXJhbWV0ZXIpIHtcbiAgICAgICAgdmFyIHBhaXIgPSByYXdQYXJhbWV0ZXIuc3BsaXQoL1xccyo9XFxzKi8pO1xuICAgICAgICB2YXIga2V5ID0gcGFpclswXTtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYWlyWzFdO1xuXG4gICAgICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICAgICAgZGVmYXVsdHNba2V5XSA9IFR3aWcuZXhwcmVzc2lvbi5jb21waWxlLmNhbGwodGhpcywge1xuICAgICAgICAgICAgdHlwZTogVHdpZy5leHByZXNzaW9uLnR5cGUuZXhwcmVzc2lvbixcbiAgICAgICAgICAgIHZhbHVlOiBleHByZXNzaW9uXG4gICAgICAgICAgfSkuc3RhY2s7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVmYXVsdHNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcbiAgICAgIH0sIHt9KTtcbiAgICAgIGRlbGV0ZSB0b2tlbi5tYXRjaDtcbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSh0b2tlbiwgY29udGV4dCwgY2hhaW4pIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXM7XG5cbiAgICAgIHN0YXRlLm1hY3Jvc1t0b2tlbi5tYWNyb05hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQYXNzIGdsb2JhbCBjb250ZXh0IGFuZCBvdGhlciBtYWNyb3NcbiAgICAgICAgdmFyIG1hY3JvQ29udGV4dCA9IHtcbiAgICAgICAgICBfc2VsZjogc3RhdGUubWFjcm9zXG4gICAgICAgIH07IC8vIFNhdmUgYXJndW1lbnRzXG5cbiAgICAgICAgcmV0dXJuIFR3aWcuYXN5bmMuZm9yRWFjaCh0b2tlbi5wYXJhbWV0ZXJzLCBmdW5jdGlvbiAocHJvcCwgaSkge1xuICAgICAgICAgIC8vIEFkZCBwYXJhbWV0ZXJzIGZyb20gY29udGV4dCB0byBtYWNyb0NvbnRleHRcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZ3NbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBtYWNyb0NvbnRleHRbcHJvcF0gPSBhcmdzW2ldO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbi5kZWZhdWx0c1twcm9wXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBUd2lnLmV4cHJlc3Npb24ucGFyc2VBc3luYy5jYWxsKHRoaXMsIHRva2VuLmRlZmF1bHRzW3Byb3BdLCBjb250ZXh0KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICBtYWNyb0NvbnRleHRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIFR3aWcuUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtYWNyb0NvbnRleHRbcHJvcF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFJlbmRlclxuICAgICAgICAgIHJldHVybiBzdGF0ZS5wYXJzZUFzeW5jKHRva2VuLm91dHB1dCwgbWFjcm9Db250ZXh0KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaGFpbjogY2hhaW4sXG4gICAgICAgIG91dHB1dDogJydcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAgLyoqXG4gICAgICogRW5kIG1hY3JvIGxvZ2ljIHRva2Vucy5cbiAgICAgKlxuICAgICAqIEZvcm1hdDogeyUgZW5kbWFjcm8gJX1cbiAgICAgKi9cbiAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUuZW5kbWFjcm8sXG4gICAgcmVnZXg6IC9eZW5kbWFjcm8kLyxcbiAgICBuZXh0OiBbXSxcbiAgICBvcGVuOiBmYWxzZVxuICB9LCB7XG4gICAgLypcbiAgICAqIEltcG9ydCBsb2dpYyB0b2tlbnMuXG4gICAgKlxuICAgICogRm9ybWF0OiB7JSBpbXBvcnQgXCJ0ZW1wbGF0ZS50d2lnXCIgYXMgZm9ybSAlfVxuICAgICovXG4gICAgdHlwZTogVHdpZy5sb2dpYy50eXBlLmltcG9ydF8sXG4gICAgcmVnZXg6IC9eaW1wb3J0XFxzKyguKylcXHMrYXNcXHMrKFxcdyspJC8sXG4gICAgbmV4dDogW10sXG4gICAgb3BlbjogdHJ1ZSxcbiAgICBjb21waWxlOiBmdW5jdGlvbiBjb21waWxlKHRva2VuKSB7XG4gICAgICB2YXIgZXhwcmVzc2lvbiA9IHRva2VuLm1hdGNoWzFdLnRyaW0oKTtcbiAgICAgIHZhciBjb250ZXh0TmFtZSA9IHRva2VuLm1hdGNoWzJdLnRyaW0oKTtcbiAgICAgIGRlbGV0ZSB0b2tlbi5tYXRjaDtcbiAgICAgIHRva2VuLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgdG9rZW4uY29udGV4dE5hbWUgPSBjb250ZXh0TmFtZTtcbiAgICAgIHRva2VuLnN0YWNrID0gVHdpZy5leHByZXNzaW9uLmNvbXBpbGUuY2FsbCh0aGlzLCB7XG4gICAgICAgIHR5cGU6IFR3aWcuZXhwcmVzc2lvbi50eXBlLmV4cHJlc3Npb24sXG4gICAgICAgIHZhbHVlOiBleHByZXNzaW9uXG4gICAgICB9KS5zdGFjaztcbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSh0b2tlbiwgY29udGV4dCwgY2hhaW4pIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXM7XG4gICAgICB2YXIgb3V0cHV0ID0ge1xuICAgICAgICBjaGFpbjogY2hhaW4sXG4gICAgICAgIG91dHB1dDogJydcbiAgICAgIH07XG5cbiAgICAgIGlmICh0b2tlbi5leHByZXNzaW9uID09PSAnX3NlbGYnKSB7XG4gICAgICAgIGNvbnRleHRbdG9rZW4uY29udGV4dE5hbWVdID0gc3RhdGUubWFjcm9zO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gVHdpZy5leHByZXNzaW9uLnBhcnNlQXN5bmMuY2FsbChzdGF0ZSwgdG9rZW4uc3RhY2ssIGNvbnRleHQpLnRoZW4oZnVuY3Rpb24gKGZpbGVQYXRoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS50ZW1wbGF0ZS5pbXBvcnRGaWxlKGZpbGVQYXRoIHx8IHRva2VuLmV4cHJlc3Npb24pO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoaW1wb3J0VGVtcGxhdGUpIHtcbiAgICAgICAgdmFyIGltcG9ydFN0YXRlID0gbmV3IFR3aWcuUGFyc2VTdGF0ZShpbXBvcnRUZW1wbGF0ZSk7XG4gICAgICAgIHJldHVybiBpbXBvcnRTdGF0ZS5wYXJzZUFzeW5jKGltcG9ydFRlbXBsYXRlLnRva2VucykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29udGV4dFt0b2tlbi5jb250ZXh0TmFtZV0gPSBpbXBvcnRTdGF0ZS5tYWNyb3M7XG4gICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICAvKlxuICAgICogRnJvbSBsb2dpYyB0b2tlbnMuXG4gICAgKlxuICAgICogRm9ybWF0OiB7JSBmcm9tIFwidGVtcGxhdGUudHdpZ1wiIGltcG9ydCBmdW5jIGFzIGZvcm0gJX1cbiAgICAqL1xuICAgIHR5cGU6IFR3aWcubG9naWMudHlwZS5mcm9tLFxuICAgIHJlZ2V4OiAvXmZyb21cXHMrKC4rKVxccytpbXBvcnRcXHMrKFthLXpBLVowLTlfLCBdKykkLyxcbiAgICBuZXh0OiBbXSxcbiAgICBvcGVuOiB0cnVlLFxuICAgIGNvbXBpbGU6IGZ1bmN0aW9uIGNvbXBpbGUodG9rZW4pIHtcbiAgICAgIHZhciBleHByZXNzaW9uID0gdG9rZW4ubWF0Y2hbMV0udHJpbSgpO1xuICAgICAgdmFyIG1hY3JvRXhwcmVzc2lvbnMgPSB0b2tlbi5tYXRjaFsyXS50cmltKCkuc3BsaXQoL1xccyosXFxzKi8pO1xuICAgICAgdmFyIG1hY3JvTmFtZXMgPSB7fTtcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBtYWNyb0V4cHJlc3Npb25zW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciByZXMgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAvLyBNYXRjaCBmdW5jdGlvbiBhcyB2YXJpYWJsZVxuICAgICAgICAgIHZhciBtYWNyb01hdGNoID0gcmVzLm1hdGNoKC9eKFxcdyspXFxzK2FzXFxzKyhcXHcrKSQvKTtcblxuICAgICAgICAgIGlmIChtYWNyb01hdGNoKSB7XG4gICAgICAgICAgICBtYWNyb05hbWVzW21hY3JvTWF0Y2hbMV0udHJpbSgpXSA9IG1hY3JvTWF0Y2hbMl0udHJpbSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVzLm1hdGNoKC9eKFxcdyspJC8pKSB7XG4gICAgICAgICAgICBtYWNyb05hbWVzW3Jlc10gPSByZXM7XG4gICAgICAgICAgfSBlbHNlIHsvLyBpZ25vcmUgaW1wb3J0XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvcltcInJldHVyblwiXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3JbXCJyZXR1cm5cIl0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGVsZXRlIHRva2VuLm1hdGNoO1xuICAgICAgdG9rZW4uZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICB0b2tlbi5tYWNyb05hbWVzID0gbWFjcm9OYW1lcztcbiAgICAgIHRva2VuLnN0YWNrID0gVHdpZy5leHByZXNzaW9uLmNvbXBpbGUuY2FsbCh0aGlzLCB7XG4gICAgICAgIHR5cGU6IFR3aWcuZXhwcmVzc2lvbi50eXBlLmV4cHJlc3Npb24sXG4gICAgICAgIHZhbHVlOiBleHByZXNzaW9uXG4gICAgICB9KS5zdGFjaztcbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSh0b2tlbiwgY29udGV4dCwgY2hhaW4pIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXM7XG4gICAgICB2YXIgcHJvbWlzZTtcblxuICAgICAgaWYgKHRva2VuLmV4cHJlc3Npb24gPT09ICdfc2VsZicpIHtcbiAgICAgICAgcHJvbWlzZSA9IFR3aWcuUHJvbWlzZS5yZXNvbHZlKHN0YXRlLm1hY3Jvcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlID0gVHdpZy5leHByZXNzaW9uLnBhcnNlQXN5bmMuY2FsbChzdGF0ZSwgdG9rZW4uc3RhY2ssIGNvbnRleHQpLnRoZW4oZnVuY3Rpb24gKGZpbGVQYXRoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnRlbXBsYXRlLmltcG9ydEZpbGUoZmlsZVBhdGggfHwgdG9rZW4uZXhwcmVzc2lvbik7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGltcG9ydFRlbXBsYXRlKSB7XG4gICAgICAgICAgdmFyIGltcG9ydFN0YXRlID0gbmV3IFR3aWcuUGFyc2VTdGF0ZShpbXBvcnRUZW1wbGF0ZSk7XG4gICAgICAgICAgcmV0dXJuIGltcG9ydFN0YXRlLnBhcnNlQXN5bmMoaW1wb3J0VGVtcGxhdGUudG9rZW5zKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbXBvcnRTdGF0ZS5tYWNyb3M7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChtYWNyb3MpIHtcbiAgICAgICAgZm9yICh2YXIgbWFjcm9OYW1lIGluIHRva2VuLm1hY3JvTmFtZXMpIHtcbiAgICAgICAgICBpZiAobWFjcm9zW21hY3JvTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGV4dFt0b2tlbi5tYWNyb05hbWVzW21hY3JvTmFtZV1dID0gbWFjcm9zW21hY3JvTmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjaGFpbjogY2hhaW4sXG4gICAgICAgICAgb3V0cHV0OiAnJ1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAgLyoqXG4gICAgICogVGhlIGVtYmVkIHRhZyBjb21iaW5lcyB0aGUgYmVoYXZpb3VyIG9mIGluY2x1ZGUgYW5kIGV4dGVuZHMuXG4gICAgICogSXQgYWxsb3dzIHlvdSB0byBpbmNsdWRlIGFub3RoZXIgdGVtcGxhdGUncyBjb250ZW50cywganVzdCBsaWtlIGluY2x1ZGUgZG9lcy5cbiAgICAgKlxuICAgICAqICBGb3JtYXQ6IHslIGVtYmVkIFwidGVtcGxhdGUudHdpZ1wiIFt3aXRoIHtzb21lOiAndmFsdWVzJ30gb25seV0gJX1cbiAgICAgKi9cbiAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUuZW1iZWQsXG4gICAgcmVnZXg6IC9eZW1iZWRcXHMrKC4rPykoPzpcXHMrKGlnbm9yZSBtaXNzaW5nKSk/KD86XFxzK3dpdGhcXHMrKFtcXFNcXHNdKz8pKT8oPzpcXHMrKG9ubHkpKT8kLyxcbiAgICBuZXh0OiBbVHdpZy5sb2dpYy50eXBlLmVuZGVtYmVkXSxcbiAgICBvcGVuOiB0cnVlLFxuICAgIGNvbXBpbGU6IGZ1bmN0aW9uIGNvbXBpbGUodG9rZW4pIHtcbiAgICAgIHZhciBtYXRjaCA9IHRva2VuLm1hdGNoO1xuICAgICAgdmFyIGV4cHJlc3Npb24gPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICB2YXIgaWdub3JlTWlzc2luZyA9IG1hdGNoWzJdICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgd2l0aENvbnRleHQgPSBtYXRjaFszXTtcbiAgICAgIHZhciBvbmx5ID0gbWF0Y2hbNF0gIT09IHVuZGVmaW5lZCAmJiBtYXRjaFs0XS5sZW5ndGg7XG4gICAgICBkZWxldGUgdG9rZW4ubWF0Y2g7XG4gICAgICB0b2tlbi5vbmx5ID0gb25seTtcbiAgICAgIHRva2VuLmlnbm9yZU1pc3NpbmcgPSBpZ25vcmVNaXNzaW5nO1xuICAgICAgdG9rZW4uc3RhY2sgPSBUd2lnLmV4cHJlc3Npb24uY29tcGlsZS5jYWxsKHRoaXMsIHtcbiAgICAgICAgdHlwZTogVHdpZy5leHByZXNzaW9uLnR5cGUuZXhwcmVzc2lvbixcbiAgICAgICAgdmFsdWU6IGV4cHJlc3Npb25cbiAgICAgIH0pLnN0YWNrO1xuXG4gICAgICBpZiAod2l0aENvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0b2tlbi53aXRoU3RhY2sgPSBUd2lnLmV4cHJlc3Npb24uY29tcGlsZS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5leHByZXNzaW9uLFxuICAgICAgICAgIHZhbHVlOiB3aXRoQ29udGV4dC50cmltKClcbiAgICAgICAgfSkuc3RhY2s7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSh0b2tlbiwgY29udGV4dCwgY2hhaW4pIHtcbiAgICAgIHZhciBlbWJlZENvbnRleHQgPSB7fTtcbiAgICAgIHZhciBwcm9taXNlID0gVHdpZy5Qcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXM7XG5cbiAgICAgIGlmICghdG9rZW4ub25seSkge1xuICAgICAgICBlbWJlZENvbnRleHQgPSBfb2JqZWN0U3ByZWFkKHt9LCBjb250ZXh0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLndpdGhTdGFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb21pc2UgPSBUd2lnLmV4cHJlc3Npb24ucGFyc2VBc3luYy5jYWxsKHN0YXRlLCB0b2tlbi53aXRoU3RhY2ssIGNvbnRleHQpLnRoZW4oZnVuY3Rpb24gKHdpdGhDb250ZXh0KSB7XG4gICAgICAgICAgZW1iZWRDb250ZXh0ID0gX29iamVjdFNwcmVhZCh7fSwgZW1iZWRDb250ZXh0LCB7fSwgd2l0aENvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBUd2lnLmV4cHJlc3Npb24ucGFyc2VBc3luYy5jYWxsKHN0YXRlLCB0b2tlbi5zdGFjaywgZW1iZWRDb250ZXh0KTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGZpbGVOYW1lKSB7XG4gICAgICAgIHZhciBlbWJlZE92ZXJyaWRlVGVtcGxhdGUgPSBuZXcgVHdpZy5UZW1wbGF0ZSh7XG4gICAgICAgICAgZGF0YTogdG9rZW4ub3V0cHV0LFxuICAgICAgICAgIGlkOiBzdGF0ZS50ZW1wbGF0ZS5pZCxcbiAgICAgICAgICBiYXNlOiBzdGF0ZS50ZW1wbGF0ZS5iYXNlLFxuICAgICAgICAgIHBhdGg6IHN0YXRlLnRlbXBsYXRlLnBhdGgsXG4gICAgICAgICAgdXJsOiBzdGF0ZS50ZW1wbGF0ZS51cmwsXG4gICAgICAgICAgbmFtZTogc3RhdGUudGVtcGxhdGUubmFtZSxcbiAgICAgICAgICBtZXRob2Q6IHN0YXRlLnRlbXBsYXRlLm1ldGhvZCxcbiAgICAgICAgICBvcHRpb25zOiBzdGF0ZS50ZW1wbGF0ZS5vcHRpb25zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZW1iZWRPdmVycmlkZVRlbXBsYXRlLmltcG9ydEZpbGUoZmlsZU5hbWUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGlmICh0b2tlbi5pZ25vcmVNaXNzaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgfSAvLyBFcnJvcnMgcHJlc2VydmUgcmVmZXJlbmNlcyB0byB2YXJpYWJsZXMgaW4gc2NvcGUsXG4gICAgICAgICAgLy8gdGhpcyByZW1vdmVzIGB0aGlzYCBmcm9tIHRoZSBzY29wZS5cblxuXG4gICAgICAgICAgc3RhdGUgPSBudWxsO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgZW1iZWRPdmVycmlkZVRlbXBsYXRlLnBhcmVudFRlbXBsYXRlID0gZmlsZU5hbWU7XG4gICAgICAgIHJldHVybiBlbWJlZE92ZXJyaWRlVGVtcGxhdGUucmVuZGVyQXN5bmMoZW1iZWRDb250ZXh0LCB7XG4gICAgICAgICAgaXNJbmNsdWRlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAob3V0cHV0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hhaW46IGNoYWluLFxuICAgICAgICAgIG91dHB1dDogb3V0cHV0XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIC8qIEFkZCB0aGUgeyUgZW5kZW1iZWQgJX0gdG9rZW5cbiAgICpcbiAgICovXG4gIHtcbiAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUuZW5kZW1iZWQsXG4gICAgcmVnZXg6IC9eZW5kZW1iZWQkLyxcbiAgICBuZXh0OiBbXSxcbiAgICBvcGVuOiBmYWxzZVxuICB9LCB7XG4gICAgLyoqXG4gICAgICogQmxvY2sgbG9naWMgdG9rZW5zLlxuICAgICAqXG4gICAgICogIEZvcm1hdDogeyUgd2l0aCB7c29tZTogJ3ZhbHVlcyd9IFtvbmx5XSAlfVxuICAgICAqL1xuICAgIHR5cGU6IFR3aWcubG9naWMudHlwZVtcIndpdGhcIl0sXG4gICAgcmVnZXg6IC9eKD86d2l0aFxccysoW1xcU1xcc10rPykpKD86XFxzfCQpKG9ubHkpPyQvLFxuICAgIG5leHQ6IFtUd2lnLmxvZ2ljLnR5cGUuZW5kd2l0aF0sXG4gICAgb3BlbjogdHJ1ZSxcbiAgICBjb21waWxlOiBmdW5jdGlvbiBjb21waWxlKHRva2VuKSB7XG4gICAgICB2YXIgbWF0Y2ggPSB0b2tlbi5tYXRjaDtcbiAgICAgIHZhciB3aXRoQ29udGV4dCA9IG1hdGNoWzFdO1xuICAgICAgdmFyIG9ubHkgPSBtYXRjaFsyXSAhPT0gdW5kZWZpbmVkICYmIG1hdGNoWzJdLmxlbmd0aDtcbiAgICAgIGRlbGV0ZSB0b2tlbi5tYXRjaDtcbiAgICAgIHRva2VuLm9ubHkgPSBvbmx5O1xuXG4gICAgICBpZiAod2l0aENvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0b2tlbi53aXRoU3RhY2sgPSBUd2lnLmV4cHJlc3Npb24uY29tcGlsZS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICB0eXBlOiBUd2lnLmV4cHJlc3Npb24udHlwZS5leHByZXNzaW9uLFxuICAgICAgICAgIHZhbHVlOiB3aXRoQ29udGV4dC50cmltKClcbiAgICAgICAgfSkuc3RhY2s7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSh0b2tlbiwgY29udGV4dCwgY2hhaW4pIHtcbiAgICAgIC8vIFJlc29sdmUgZmlsZW5hbWVcbiAgICAgIHZhciBpbm5lckNvbnRleHQgPSB7fTtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIHN0YXRlID0gdGhpcztcbiAgICAgIHZhciBwcm9taXNlID0gVHdpZy5Qcm9taXNlLnJlc29sdmUoKTtcblxuICAgICAgaWYgKCF0b2tlbi5vbmx5KSB7XG4gICAgICAgIGlubmVyQ29udGV4dCA9IF9vYmplY3RTcHJlYWQoe30sIGNvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4ud2l0aFN0YWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvbWlzZSA9IFR3aWcuZXhwcmVzc2lvbi5wYXJzZUFzeW5jLmNhbGwoc3RhdGUsIHRva2VuLndpdGhTdGFjaywgY29udGV4dCkudGhlbihmdW5jdGlvbiAod2l0aENvbnRleHQpIHtcbiAgICAgICAgICBmb3IgKGkgaW4gd2l0aENvbnRleHQpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh3aXRoQ29udGV4dCwgaSkpIHtcbiAgICAgICAgICAgICAgaW5uZXJDb250ZXh0W2ldID0gd2l0aENvbnRleHRbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5wYXJzZUFzeW5jKHRva2VuLm91dHB1dCwgaW5uZXJDb250ZXh0KTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKG91dHB1dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoYWluOiBjaGFpbixcbiAgICAgICAgICBvdXRwdXQ6IG91dHB1dFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAgdHlwZTogVHdpZy5sb2dpYy50eXBlLmVuZHdpdGgsXG4gICAgcmVnZXg6IC9eZW5kd2l0aCQvLFxuICAgIG5leHQ6IFtdLFxuICAgIG9wZW46IGZhbHNlXG4gIH0sIHtcbiAgICAvKipcbiAgICAgKiBEZXByZWNhdGVkIHR5cGUgbG9naWMgdG9rZW5zLlxuICAgICAqXG4gICAgICogIEZvcm1hdDogeyUgZGVwcmVjYXRlZCAnRGVzY3JpcHRpb24nICV9XG4gICAgICovXG4gICAgdHlwZTogVHdpZy5sb2dpYy50eXBlLmRlcHJlY2F0ZWQsXG4gICAgcmVnZXg6IC9eZGVwcmVjYXRlZFxccysoLispJC8sXG4gICAgbmV4dDogW10sXG4gICAgb3BlbjogdHJ1ZSxcbiAgICBjb21waWxlOiBmdW5jdGlvbiBjb21waWxlKHRva2VuKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIG5vdGljZTogJyArIHRva2VuLm1hdGNoWzFdKTtcbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSgpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH1dO1xuICAvKipcbiAgICogUmVnaXN0cnkgZm9yIGxvZ2ljIGhhbmRsZXJzLlxuICAgKi9cblxuICBUd2lnLmxvZ2ljLmhhbmRsZXIgPSB7fTtcbiAgLyoqXG4gICAqIERlZmluZSBhIG5ldyB0b2tlbiB0eXBlLCBhdmFpbGFibGUgYXQgVHdpZy5sb2dpYy50eXBlLnt0eXBlfVxuICAgKi9cblxuICBUd2lnLmxvZ2ljLmV4dGVuZFR5cGUgPSBmdW5jdGlvbiAodHlwZSwgdmFsdWUpIHtcbiAgICB2YWx1ZSA9IHZhbHVlIHx8ICdUd2lnLmxvZ2ljLnR5cGUnICsgdHlwZTtcbiAgICBUd2lnLmxvZ2ljLnR5cGVbdHlwZV0gPSB2YWx1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIEV4dGVuZCB0aGUgbG9naWMgcGFyc2luZyBmdW5jdGlvbmFsaXR5IHdpdGggYSBuZXcgdG9rZW4gZGVmaW5pdGlvbi5cbiAgICpcbiAgICogLy8gRGVmaW5lIGEgbmV3IHRhZ1xuICAgKiBUd2lnLmxvZ2ljLmV4dGVuZCh7XG4gICAqICAgICB0eXBlOiBUd2lnLmxvZ2ljLnR5cGUue3R5cGV9LFxuICAgKiAgICAgLy8gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggZm9yIHRoaXMgdG9rZW5cbiAgICogICAgIHJlZ2V4OiAuLi4sXG4gICAqICAgICAvLyBXaGF0IHRva2VuIHR5cGVzIGNhbiBmb2xsb3cgdGhpcyB0b2tlbiwgbGVhdmUgYmxhbmsgaWYgYW55LlxuICAgKiAgICAgbmV4dDogWyAuLi4gXVxuICAgKiAgICAgLy8gQ3JlYXRlIGFuZCByZXR1cm4gY29tcGlsZWQgdmVyc2lvbiBvZiB0aGUgdG9rZW5cbiAgICogICAgIGNvbXBpbGU6IGZ1bmN0aW9uKHRva2VuKSB7IC4uLiB9XG4gICAqICAgICAvLyBQYXJzZSB0aGUgY29tcGlsZWQgdG9rZW4gd2l0aCB0aGUgY29udGV4dCBwcm92aWRlZCBieSB0aGUgcmVuZGVyIGNhbGxcbiAgICogICAgIC8vICAgYW5kIHdoZXRoZXIgdGhpcyB0b2tlbiBjaGFpbiBpcyBjb21wbGV0ZS5cbiAgICogICAgIHBhcnNlOiBmdW5jdGlvbih0b2tlbiwgY29udGV4dCwgY2hhaW4pIHsgLi4uIH1cbiAgICogfSk7XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZpbml0aW9uIFRoZSBuZXcgbG9naWMgZXhwcmVzc2lvbi5cbiAgICovXG5cblxuICBUd2lnLmxvZ2ljLmV4dGVuZCA9IGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gICAgaWYgKGRlZmluaXRpb24udHlwZSkge1xuICAgICAgVHdpZy5sb2dpYy5leHRlbmRUeXBlKGRlZmluaXRpb24udHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKCdVbmFibGUgdG8gZXh0ZW5kIGxvZ2ljIGRlZmluaXRpb24uIE5vIHR5cGUgcHJvdmlkZWQgZm9yICcgKyBkZWZpbml0aW9uKTtcbiAgICB9XG5cbiAgICBUd2lnLmxvZ2ljLmhhbmRsZXJbZGVmaW5pdGlvbi50eXBlXSA9IGRlZmluaXRpb247XG4gIH07IC8vIEV4dGVuZCB3aXRoIGJ1aWx0LWluIGV4cHJlc3Npb25zXG5cblxuICB3aGlsZSAoVHdpZy5sb2dpYy5kZWZpbml0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgVHdpZy5sb2dpYy5leHRlbmQoVHdpZy5sb2dpYy5kZWZpbml0aW9ucy5zaGlmdCgpKTtcbiAgfVxuICAvKipcbiAgICogQ29tcGlsZSBhIGxvZ2ljIHRva2VuIGludG8gYW4gb2JqZWN0IHJlYWR5IGZvciBwYXJzaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmF3VG9rZW4gQW4gdW5jb21waWxlZCBsb2dpYyB0b2tlbi5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBBIGNvbXBpbGVkIGxvZ2ljIHRva2VuLCByZWFkeSBmb3IgcGFyc2luZy5cbiAgICovXG5cblxuICBUd2lnLmxvZ2ljLmNvbXBpbGUgPSBmdW5jdGlvbiAocmF3VG9rZW4pIHtcbiAgICB2YXIgZXhwcmVzc2lvbiA9IHJhd1Rva2VuLnZhbHVlLnRyaW0oKTtcbiAgICB2YXIgdG9rZW4gPSBUd2lnLmxvZ2ljLnRva2VuaXplLmNhbGwodGhpcywgZXhwcmVzc2lvbik7XG4gICAgdmFyIHRva2VuVGVtcGxhdGUgPSBUd2lnLmxvZ2ljLmhhbmRsZXJbdG9rZW4udHlwZV07IC8vIENoZWNrIGlmIHRoZSB0b2tlbiBuZWVkcyBjb21waWxpbmdcblxuICAgIGlmICh0b2tlblRlbXBsYXRlLmNvbXBpbGUpIHtcbiAgICAgIHRva2VuID0gdG9rZW5UZW1wbGF0ZS5jb21waWxlLmNhbGwodGhpcywgdG9rZW4pO1xuICAgICAgVHdpZy5sb2cudHJhY2UoJ1R3aWcubG9naWMuY29tcGlsZTogJywgJ0NvbXBpbGVkIGxvZ2ljIHRva2VuIHRvICcsIHRva2VuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9rZW47XG4gIH07XG4gIC8qKlxuICAgKiBUb2tlbml6ZSBsb2dpYyBleHByZXNzaW9ucy4gVGhpcyBmdW5jdGlvbiBtYXRjaGVzIHRva2VuIGV4cHJlc3Npb25zIGFnYWluc3QgcmVndWxhclxuICAgKiBleHByZXNzaW9ucyBwcm92aWRlZCBpbiB0b2tlbiBkZWZpbml0aW9ucyBwcm92aWRlZCB3aXRoIFR3aWcubG9naWMuZXh0ZW5kLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiB0aGUgbG9naWMgdG9rZW4gZXhwcmVzc2lvbiB0byB0b2tlbml6ZVxuICAgKiAgICAgICAgICAgICAgICAoaS5lLiB3aGF0J3MgYmV0d2VlbiB7JSBhbmQgJX0pXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG1hdGNoZWQgdG9rZW4gd2l0aCB0eXBlIHNldCB0byB0aGUgdG9rZW4gdHlwZSBhbmQgbWF0Y2ggdG8gdGhlIHJlZ2V4IG1hdGNoLlxuICAgKi9cblxuXG4gIFR3aWcubG9naWMudG9rZW5pemUgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgIHZhciB0b2tlblRlbXBsYXRlVHlwZSA9IG51bGw7XG4gICAgdmFyIHRva2VuVHlwZSA9IG51bGw7XG4gICAgdmFyIHRva2VuUmVnZXggPSBudWxsO1xuICAgIHZhciByZWdleEFycmF5ID0gbnVsbDtcbiAgICB2YXIgcmVnZXhMZW4gPSBudWxsO1xuICAgIHZhciByZWdleEkgPSBudWxsO1xuICAgIHZhciBtYXRjaCA9IG51bGw7IC8vIElnbm9yZSB3aGl0ZXNwYWNlIGFyb3VuZCBleHByZXNzaW9ucy5cblxuICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLnRyaW0oKTtcblxuICAgIGZvciAodG9rZW5UZW1wbGF0ZVR5cGUgaW4gVHdpZy5sb2dpYy5oYW5kbGVyKSB7XG4gICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoVHdpZy5sb2dpYy5oYW5kbGVyLCB0b2tlblRlbXBsYXRlVHlwZSkpIHtcbiAgICAgICAgLy8gR2V0IHRoZSB0eXBlIGFuZCByZWdleCBmb3IgdGhpcyB0ZW1wbGF0ZSB0eXBlXG4gICAgICAgIHRva2VuVHlwZSA9IFR3aWcubG9naWMuaGFuZGxlclt0b2tlblRlbXBsYXRlVHlwZV0udHlwZTtcbiAgICAgICAgdG9rZW5SZWdleCA9IFR3aWcubG9naWMuaGFuZGxlclt0b2tlblRlbXBsYXRlVHlwZV0ucmVnZXg7IC8vIEhhbmRsZSBtdWx0aXBsZSByZWd1bGFyIGV4cHJlc3Npb25zIHBlciB0eXBlLlxuXG4gICAgICAgIHJlZ2V4QXJyYXkgPSB0b2tlblJlZ2V4O1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0b2tlblJlZ2V4KSkge1xuICAgICAgICAgIHJlZ2V4QXJyYXkgPSBbdG9rZW5SZWdleF07XG4gICAgICAgIH1cblxuICAgICAgICByZWdleExlbiA9IHJlZ2V4QXJyYXkubGVuZ3RoOyAvLyBDaGVjayByZWd1bGFyIGV4cHJlc3Npb25zIGluIHRoZSBvcmRlciB0aGV5IHdlcmUgc3BlY2lmaWVkIGluIHRoZSBkZWZpbml0aW9uLlxuXG4gICAgICAgIGZvciAocmVnZXhJID0gMDsgcmVnZXhJIDwgcmVnZXhMZW47IHJlZ2V4SSsrKSB7XG4gICAgICAgICAgbWF0Y2ggPSByZWdleEFycmF5W3JlZ2V4SV0uZXhlYyhleHByZXNzaW9uKTtcblxuICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgVHdpZy5sb2cudHJhY2UoJ1R3aWcubG9naWMudG9rZW5pemU6ICcsICdNYXRjaGVkIGEgJywgdG9rZW5UeXBlLCAnIHJlZ3VsYXIgZXhwcmVzc2lvbiBvZiAnLCBtYXRjaCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiB0b2tlblR5cGUsXG4gICAgICAgICAgICAgIG1hdGNoOiBtYXRjaFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIE5vIHJlZ2V4IG1hdGNoZXNcblxuXG4gICAgdGhyb3cgbmV3IFR3aWcuRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSBcXCcnICsgZXhwcmVzc2lvbi50cmltKCkgKyAnXFwnJyk7XG4gIH07XG4gIC8qKlxuICAgKiBQYXJzZSBhIGxvZ2ljIHRva2VuIHdpdGhpbiBhIGdpdmVuIGNvbnRleHQuXG4gICAqXG4gICAqIFdoYXQgYXJlIGxvZ2ljIGNoYWlucz9cbiAgICogICAgICBMb2dpYyBjaGFpbnMgcmVwcmVzZW50IGEgc2VyaWVzIG9mIHRva2VucyB0aGF0IGFyZSBjb25uZWN0ZWQsXG4gICAqICAgICAgICAgIGZvciBleGFtcGxlOlxuICAgKiAgICAgICAgICB7JSBpZiAuLi4gJX0geyUgZWxzZSAlfSB7JSBlbmRpZiAlfVxuICAgKlxuICAgKiAgICAgIFRoZSBjaGFpbiBwYXJhbWV0ZXIgaXMgdXNlZCB0byBzaWduaWZ5IGlmIGEgY2hhaW4gaXMgb3BlbiBvZiBjbG9zZWQuXG4gICAqICAgICAgb3BlbjpcbiAgICogICAgICAgICAgTW9yZSB0b2tlbnMgaW4gdGhpcyBjaGFpbiBzaG91bGQgYmUgcGFyc2VkLlxuICAgKiAgICAgIGNsb3NlZDpcbiAgICogICAgICAgICAgVGhpcyB0b2tlbiBjaGFpbiBoYXMgY29tcGxldGVkIHBhcnNpbmcgYW5kIGFueSBhZGRpdGlvbmFsXG4gICAqICAgICAgICAgIHRva2VucyAoZWxzZSwgZWxzZWlmLCBldGMuLi4pIHNob3VsZCBiZSBpZ25vcmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdG9rZW4gVGhlIGNvbXBpbGVkIHRva2VuLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBUaGUgcmVuZGVyIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hhaW4gSXMgdGhpcyBhbiBvcGVuIGxvZ2ljIGNoYWluLiBJZiBmYWxzZSwgdGhhdCBtZWFucyBhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4gaXMgY2xvc2VkIGFuZCBubyBmdXJ0aGVyIGNhc2VzIHNob3VsZCBiZSBwYXJzZWQuXG4gICAqL1xuXG5cbiAgVHdpZy5sb2dpYy5wYXJzZSA9IGZ1bmN0aW9uICh0b2tlbiwgY29udGV4dCwgY2hhaW4sIGFsbG93QXN5bmMpIHtcbiAgICByZXR1cm4gVHdpZy5hc3luYy5wb3RlbnRpYWxseUFzeW5jKHRoaXMsIGFsbG93QXN5bmMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIFR3aWcubG9nLmRlYnVnKCdUd2lnLmxvZ2ljLnBhcnNlOiAnLCAnUGFyc2luZyBsb2dpYyB0b2tlbiAnLCB0b2tlbik7XG4gICAgICB2YXIgdG9rZW5UZW1wbGF0ZSA9IFR3aWcubG9naWMuaGFuZGxlclt0b2tlbi50eXBlXTtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRva2VuVGVtcGxhdGUucGFyc2UpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5uZXN0aW5nU3RhY2sudW5zaGlmdCh0b2tlbik7XG4gICAgICByZXN1bHQgPSB0b2tlblRlbXBsYXRlLnBhcnNlLmNhbGwoc3RhdGUsIHRva2VuLCBjb250ZXh0IHx8IHt9LCBjaGFpbik7XG5cbiAgICAgIGlmIChUd2lnLmlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICBzdGF0ZS5uZXN0aW5nU3RhY2suc2hpZnQoKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLm5lc3RpbmdTdGFjay5zaGlmdCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBUd2lnO1xufTtcblxuLyoqKi8gfSksXG4vKiAzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUd2lnKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBUd2lnLlRlbXBsYXRlcy5yZWdpc3RlclBhcnNlcignc291cmNlJywgZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHJldHVybiBwYXJhbXMuZGF0YSB8fCAnJztcbiAgfSk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDMyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFR3aWcpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIFR3aWcuVGVtcGxhdGVzLnJlZ2lzdGVyUGFyc2VyKCd0d2lnJywgZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgVHdpZy5UZW1wbGF0ZShwYXJhbXMpO1xuICB9KTtcbn07XG5cbi8qKiovIH0pLFxuLyogMzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3R5cGVvZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xuXG4vLyAjIyB0d2lnLnBhdGguanNcbi8vXG4vLyBUaGlzIGZpbGUgaGFuZGxlcyBwYXRoIHBhcnNpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFR3aWcpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICogTmFtZXNwYWNlIGZvciBwYXRoIGhhbmRsaW5nLlxuICAgKi9cblxuICBUd2lnLnBhdGggPSB7fTtcbiAgLyoqXG4gICAqIEdlbmVyYXRlIHRoZSBjYW5vbmljYWwgdmVyc2lvbiBvZiBhIHVybCBiYXNlZCBvbiB0aGUgZ2l2ZW4gYmFzZSBwYXRoIGFuZCBmaWxlIHBhdGggYW5kIGluXG4gICAqIHRoZSBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgbmFtZXNwYWNlcy5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0ZW1wbGF0ZSBUaGUgVHdpZyBUZW1wbGF0ZVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IF9maWxlICAgIFRoZSBmaWxlIHBhdGgsIG1heSBiZSByZWxhdGl2ZSBhbmQgbWF5IGNvbnRhaW4gbmFtZXNwYWNlcy5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSAgICAgICAgICBUaGUgY2Fub25pY2FsIHZlcnNpb24gb2YgdGhlIHBhdGhcbiAgICovXG5cbiAgVHdpZy5wYXRoLnBhcnNlUGF0aCA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgX2ZpbGUpIHtcbiAgICB2YXIgayA9IG51bGw7XG4gICAgdmFyIG5hbWVzcGFjZXMgPSB0ZW1wbGF0ZS5vcHRpb25zLm5hbWVzcGFjZXM7XG4gICAgdmFyIGZpbGUgPSBfZmlsZSB8fCAnJztcbiAgICB2YXIgaGFzTmFtZXNwYWNlcyA9IG5hbWVzcGFjZXMgJiYgKDAsIF90eXBlb2YyW1wiZGVmYXVsdFwiXSkobmFtZXNwYWNlcykgPT09ICdvYmplY3QnO1xuXG4gICAgaWYgKGhhc05hbWVzcGFjZXMpIHtcbiAgICAgIGZvciAoayBpbiBuYW1lc3BhY2VzKSB7XG4gICAgICAgIGlmICghZmlsZS5pbmNsdWRlcyhrKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIENoZWNrIGlmIGtleWVkIG5hbWVzcGFjZSBleGlzdHMgYXQgcGF0aCdzIHN0YXJ0XG5cblxuICAgICAgICB2YXIgY29sb24gPSBuZXcgUmVnRXhwKCdeJyArIGsgKyAnOjonKTtcbiAgICAgICAgdmFyIGF0U2lnbiA9IG5ldyBSZWdFeHAoJ15AJyArIGsgKyAnLycpOyAvLyBBZGQgc2xhc2ggdG8gdGhlIGVuZCBvZiBwYXRoXG5cbiAgICAgICAgdmFyIG5hbWVzcGFjZVBhdGggPSBuYW1lc3BhY2VzW2tdLnJlcGxhY2UoLyhbXi9dKSQvLCAnJDEvJyk7XG5cbiAgICAgICAgaWYgKGNvbG9uLnRlc3QoZmlsZSkpIHtcbiAgICAgICAgICBmaWxlID0gZmlsZS5yZXBsYWNlKGNvbG9uLCBuYW1lc3BhY2VQYXRoKTtcbiAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdFNpZ24udGVzdChmaWxlKSkge1xuICAgICAgICAgIGZpbGUgPSBmaWxlLnJlcGxhY2UoYXRTaWduLCBuYW1lc3BhY2VQYXRoKTtcbiAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBUd2lnLnBhdGgucmVsYXRpdmVQYXRoKHRlbXBsYXRlLCBmaWxlKTtcbiAgfTtcbiAgLyoqXG4gICAqIEdlbmVyYXRlIHRoZSByZWxhdGl2ZSBjYW5vbmljYWwgdmVyc2lvbiBvZiBhIHVybCBiYXNlZCBvbiB0aGUgZ2l2ZW4gYmFzZSBwYXRoIGFuZCBmaWxlIHBhdGguXG4gICAqXG4gICAqIEBwYXJhbSB7VHdpZy5UZW1wbGF0ZX0gdGVtcGxhdGUgVGhlIFR3aWcuVGVtcGxhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfZmlsZSBUaGUgZmlsZSBwYXRoLCByZWxhdGl2ZSB0byB0aGUgYmFzZSBwYXRoLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjYW5vbmljYWwgdmVyc2lvbiBvZiB0aGUgcGF0aC5cbiAgICovXG5cblxuICBUd2lnLnBhdGgucmVsYXRpdmVQYXRoID0gZnVuY3Rpb24gKHRlbXBsYXRlLCBfZmlsZSkge1xuICAgIHZhciBiYXNlO1xuICAgIHZhciBiYXNlUGF0aDtcbiAgICB2YXIgc2VwQ2hyID0gJy8nO1xuICAgIHZhciBuZXdQYXRoID0gW107XG4gICAgdmFyIGZpbGUgPSBfZmlsZSB8fCAnJztcbiAgICB2YXIgdmFsO1xuXG4gICAgaWYgKHRlbXBsYXRlLnVybCkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZS5iYXNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBiYXNlID0gdGVtcGxhdGUudXJsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWRkIHNsYXNoIHRvIHRoZSBlbmQgb2YgcGF0aFxuICAgICAgICBiYXNlID0gdGVtcGxhdGUuYmFzZS5yZXBsYWNlKC8oW14vXSkkLywgJyQxLycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGVtcGxhdGUucGF0aCkge1xuICAgICAgLy8gR2V0IHRoZSBzeXN0ZW0tc3BlY2lmaWMgcGF0aCBzZXBhcmF0b3JcbiAgICAgIHZhciBwYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuICAgICAgdmFyIHNlcCA9IHBhdGguc2VwIHx8IHNlcENocjtcbiAgICAgIHZhciByZWxhdGl2ZSA9IG5ldyBSZWdFeHAoJ15cXFxcLnsxLDJ9JyArIHNlcC5yZXBsYWNlKCdcXFxcJywgJ1xcXFxcXFxcJykpO1xuICAgICAgZmlsZSA9IGZpbGUucmVwbGFjZSgvXFwvL2csIHNlcCk7XG5cbiAgICAgIGlmICh0ZW1wbGF0ZS5iYXNlICE9PSB1bmRlZmluZWQgJiYgZmlsZS5tYXRjaChyZWxhdGl2ZSkgPT09IG51bGwpIHtcbiAgICAgICAgZmlsZSA9IGZpbGUucmVwbGFjZSh0ZW1wbGF0ZS5iYXNlLCAnJyk7XG4gICAgICAgIGJhc2UgPSB0ZW1wbGF0ZS5iYXNlICsgc2VwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZSA9IHBhdGgubm9ybWFsaXplKHRlbXBsYXRlLnBhdGgpO1xuICAgICAgfVxuXG4gICAgICBiYXNlID0gYmFzZS5yZXBsYWNlKHNlcCArIHNlcCwgc2VwKTtcbiAgICAgIHNlcENociA9IHNlcDtcbiAgICB9IGVsc2UgaWYgKCh0ZW1wbGF0ZS5uYW1lIHx8IHRlbXBsYXRlLmlkKSAmJiB0ZW1wbGF0ZS5tZXRob2QgJiYgdGVtcGxhdGUubWV0aG9kICE9PSAnZnMnICYmIHRlbXBsYXRlLm1ldGhvZCAhPT0gJ2FqYXgnKSB7XG4gICAgICAvLyBDdXN0b20gcmVnaXN0ZXJlZCBsb2FkZXJcbiAgICAgIGJhc2UgPSB0ZW1wbGF0ZS5iYXNlIHx8IHRlbXBsYXRlLm5hbWUgfHwgdGVtcGxhdGUuaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKCdDYW5ub3QgZXh0ZW5kIGFuIGlubGluZSB0ZW1wbGF0ZS4nKTtcbiAgICB9XG5cbiAgICBiYXNlUGF0aCA9IGJhc2Uuc3BsaXQoc2VwQ2hyKTsgLy8gUmVtb3ZlIGZpbGUgZnJvbSB1cmxcblxuICAgIGJhc2VQYXRoLnBvcCgpO1xuICAgIGJhc2VQYXRoID0gYmFzZVBhdGguY29uY2F0KGZpbGUuc3BsaXQoc2VwQ2hyKSk7XG5cbiAgICB3aGlsZSAoYmFzZVBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgdmFsID0gYmFzZVBhdGguc2hpZnQoKTtcblxuICAgICAgaWYgKHZhbCA9PT0gJy4nKSB7Ly8gSWdub3JlXG4gICAgICB9IGVsc2UgaWYgKHZhbCA9PT0gJy4uJyAmJiBuZXdQYXRoLmxlbmd0aCA+IDAgJiYgbmV3UGF0aFtuZXdQYXRoLmxlbmd0aCAtIDFdICE9PSAnLi4nKSB7XG4gICAgICAgIG5ld1BhdGgucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdQYXRoLnB1c2godmFsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3UGF0aC5qb2luKHNlcENocik7XG4gIH07XG5cbiAgcmV0dXJuIFR3aWc7XG59O1xuXG4vKioqLyB9KSxcbi8qIDM0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8vICMjIHR3aWcudGVzdHMuanNcbi8vXG4vLyBUaGlzIGZpbGUgaGFuZGxlcyBleHByZXNzaW9uIHRlc3RzLiAoaXMgZW1wdHksIGlzIG5vdCBkZWZpbmVkLCBldGMuLi4pXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUd2lnKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBUd2lnLnRlc3RzID0ge1xuICAgIGVtcHR5OiBmdW5jdGlvbiBlbXB0eSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIEhhbmRsZXIgbnVtYmVyc1xuXG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gTnVtYmVycyBhcmUgbmV2ZXIgXCJlbXB0eVwiXG4gICAgICAvLyBIYW5kbGUgc3RyaW5ncyBhbmQgYXJyYXlzXG5cblxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBIYW5kbGUgb2JqZWN0c1xuXG5cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBvZGQ6IGZ1bmN0aW9uIG9kZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICUgMiA9PT0gMTtcbiAgICB9LFxuICAgIGV2ZW46IGZ1bmN0aW9uIGV2ZW4odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAlIDIgPT09IDA7XG4gICAgfSxcbiAgICBkaXZpc2libGVieTogZnVuY3Rpb24gZGl2aXNpYmxlYnkodmFsdWUsIHBhcmFtcykge1xuICAgICAgcmV0dXJuIHZhbHVlICUgcGFyYW1zWzBdID09PSAwO1xuICAgIH0sXG4gICAgZGVmaW5lZDogZnVuY3Rpb24gZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBub25lOiBmdW5jdGlvbiBub25lKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfSxcbiAgICBcIm51bGxcIjogZnVuY3Rpb24gX251bGwodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vbmUodmFsdWUpOyAvLyBBbGlhcyBvZiBub25lXG4gICAgfSxcbiAgICAnc2FtZSBhcyc6IGZ1bmN0aW9uIHNhbWVBcyh2YWx1ZSwgcGFyYW1zKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHBhcmFtc1swXTtcbiAgICB9LFxuICAgIHNhbWVhczogZnVuY3Rpb24gc2FtZWFzKHZhbHVlLCBwYXJhbXMpIHtcbiAgICAgIGNvbnNvbGUud2FybignYHNhbWVhc2AgaXMgZGVwcmVjYXRlZCB1c2UgYHNhbWUgYXNgJyk7XG4gICAgICByZXR1cm4gVHdpZy50ZXN0c1snc2FtZSBhcyddKHZhbHVlLCBwYXJhbXMpO1xuICAgIH0sXG4gICAgaXRlcmFibGU6IGZ1bmN0aW9uIGl0ZXJhYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgKFR3aWcubGliLmlzKCdBcnJheScsIHZhbHVlKSB8fCBUd2lnLmxpYi5pcygnT2JqZWN0JywgdmFsdWUpKTtcbiAgICB9XG4gICAgLypcbiAgICBDb25zdGFudCA/XG4gICAgICovXG5cbiAgfTtcblxuICBUd2lnLnRlc3QgPSBmdW5jdGlvbiAodGVzdCwgdmFsdWUsIHBhcmFtcykge1xuICAgIGlmICghVHdpZy50ZXN0c1t0ZXN0XSkge1xuICAgICAgdGhyb3cgVHdpZy5FcnJvcignVGVzdCAnICsgdGVzdCArICcgaXMgbm90IGRlZmluZWQuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFR3aWcudGVzdHNbdGVzdF0odmFsdWUsIHBhcmFtcyk7XG4gIH07XG5cbiAgVHdpZy50ZXN0LmV4dGVuZCA9IGZ1bmN0aW9uICh0ZXN0LCBkZWZpbml0aW9uKSB7XG4gICAgVHdpZy50ZXN0c1t0ZXN0XSA9IGRlZmluaXRpb247XG4gIH07XG5cbiAgcmV0dXJuIFR3aWc7XG59O1xuXG4vKioqLyB9KSxcbi8qIDM1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8vICMjIHR3aWcuYXN5bmMuanNcbi8vXG4vLyBUaGlzIGZpbGUgaGFuZGxlcyBhc3luY2hyb25vdXMgdGFza3Mgd2l0aGluIHR3aWcuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUd2lnKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgU1RBVEVfVU5LTk9XTiA9IDA7XG4gIHZhciBTVEFURV9SRVNPTFZFRCA9IDE7XG4gIHZhciBTVEFURV9SRUpFQ1RFRCA9IDI7XG5cbiAgVHdpZy5QYXJzZVN0YXRlLnByb3RvdHlwZS5wYXJzZUFzeW5jID0gZnVuY3Rpb24gKHRva2VucywgY29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlKHRva2VucywgY29udGV4dCwgdHJ1ZSk7XG4gIH07XG5cbiAgVHdpZy5leHByZXNzaW9uLnBhcnNlQXN5bmMgPSBmdW5jdGlvbiAodG9rZW5zLCBjb250ZXh0LCB0b2tlbnNBcmVQYXJhbWV0ZXJzKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcztcbiAgICByZXR1cm4gVHdpZy5leHByZXNzaW9uLnBhcnNlLmNhbGwoc3RhdGUsIHRva2VucywgY29udGV4dCwgdG9rZW5zQXJlUGFyYW1ldGVycywgdHJ1ZSk7XG4gIH07XG5cbiAgVHdpZy5sb2dpYy5wYXJzZUFzeW5jID0gZnVuY3Rpb24gKHRva2VuLCBjb250ZXh0LCBjaGFpbikge1xuICAgIHZhciBzdGF0ZSA9IHRoaXM7XG4gICAgcmV0dXJuIFR3aWcubG9naWMucGFyc2UuY2FsbChzdGF0ZSwgdG9rZW4sIGNvbnRleHQsIGNoYWluLCB0cnVlKTtcbiAgfTtcblxuICBUd2lnLlRlbXBsYXRlLnByb3RvdHlwZS5yZW5kZXJBc3luYyA9IGZ1bmN0aW9uIChjb250ZXh0LCBwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXIoY29udGV4dCwgcGFyYW1zLCB0cnVlKTtcbiAgfTtcblxuICBUd2lnLmFzeW5jID0ge307XG4gIC8qKlxuICAgKiBDaGVja3MgZm9yIGB0aGVuYWJsZWAgb2JqZWN0c1xuICAgKi9cblxuICBUd2lnLmlzUHJvbWlzZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai50aGVuICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbiAgfTtcbiAgLyoqXG4gICAqIEhhbmRsaW5nIG9mIGNvZGUgcGF0aHMgdGhhdCBtaWdodCBlaXRoZXIgcmV0dXJuIGEgcHJvbWlzZVxuICAgKiBvciBhIHZhbHVlIGRlcGVuZGluZyBvbiB3aGV0aGVyIGFzeW5jIGNvZGUgaXMgdXNlZC5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vdHdpZ2pzL3R3aWcuanMvYmxvYi9tYXN0ZXIvQVNZTkMubWQjZGV0ZWN0aW5nLWFzeW5jaHJvbm91cy1iZWhhdmlvdXJcbiAgICovXG5cblxuICBmdW5jdGlvbiBwb3RlbnRpYWxseUFzeW5jU2xvdyh0aGF0LCBhbGxvd0FzeW5jLCBhY3Rpb24pIHtcbiAgICB2YXIgcmVzdWx0ID0gYWN0aW9uLmNhbGwodGhhdCk7XG4gICAgdmFyIGVyciA9IG51bGw7XG4gICAgdmFyIGlzQXN5bmMgPSB0cnVlO1xuXG4gICAgaWYgKCFUd2lnLmlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIHJlc3VsdCA9IHJlcztcbiAgICAgIGlzQXN5bmMgPSBmYWxzZTtcbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgZXJyID0gZXJyb3I7XG4gICAgfSk7XG5cbiAgICBpZiAoZXJyICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgaWYgKGlzQXN5bmMpIHtcbiAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKCdZb3UgYXJlIHVzaW5nIFR3aWcuanMgaW4gc3luYyBtb2RlIGluIGNvbWJpbmF0aW9uIHdpdGggYXN5bmMgZXh0ZW5zaW9ucy4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgVHdpZy5hc3luYy5wb3RlbnRpYWxseUFzeW5jID0gZnVuY3Rpb24gKHRoYXQsIGFsbG93QXN5bmMsIGFjdGlvbikge1xuICAgIGlmIChhbGxvd0FzeW5jKSB7XG4gICAgICByZXR1cm4gVHdpZy5Qcm9taXNlLnJlc29sdmUoYWN0aW9uLmNhbGwodGhhdCkpO1xuICAgIH1cblxuICAgIHJldHVybiBwb3RlbnRpYWxseUFzeW5jU2xvdyh0aGF0LCBhbGxvd0FzeW5jLCBhY3Rpb24pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJ1bihmbiwgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGVuZGluZyhoYW5kbGVycywgb25SZXNvbHZlZCwgb25SZWplY3RlZCkge1xuICAgIHZhciBoID0gW29uUmVzb2x2ZWQsIG9uUmVqZWN0ZWQsIC0yXTsgLy8gVGhlIHByb21pc2UgaGFzIHlldCB0byBiZSByZWplY3RlZCBvciByZXNvbHZlZC5cblxuICAgIGlmICghaGFuZGxlcnMpIHtcbiAgICAgIGhhbmRsZXJzID0gaDtcbiAgICB9IGVsc2UgaWYgKGhhbmRsZXJzWzJdID09PSAtMikge1xuICAgICAgLy8gT25seSBhbGxvY2F0ZSBhbiBhcnJheSB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBoYW5kbGVyc1xuICAgICAgaGFuZGxlcnMgPSBbaGFuZGxlcnMsIGhdO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVycy5wdXNoKGgpO1xuICAgIH1cblxuICAgIHJldHVybiBoYW5kbGVycztcbiAgfVxuICAvKipcbiAgICogUmVhbGx5IHNtYWxsIHRoZW5hYmxlIHRvIHJlcHJlc2VudCBwcm9taXNlcyB0aGF0IHJlc29sdmUgaW1tZWRpYXRlbHkuXG4gICAqXG4gICAqL1xuXG5cbiAgVHdpZy5UaGVuYWJsZSA9IGZ1bmN0aW9uICh0aGVuLCB2YWx1ZSwgc3RhdGUpIHtcbiAgICB0aGlzLnRoZW4gPSB0aGVuO1xuICAgIHRoaXMuX3ZhbHVlID0gc3RhdGUgPyB2YWx1ZSA6IG51bGw7XG4gICAgdGhpcy5fc3RhdGUgPSBzdGF0ZSB8fCBTVEFURV9VTktOT1dOO1xuICB9O1xuXG4gIFR3aWcuVGhlbmFibGUucHJvdG90eXBlW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgIC8vIFRIZSBwcm9taXNlIHdpbGwgbm90IHRocm93LCBpdCBoYXMgYWxyZWFkeSByZXNvbHZlZC5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IFNUQVRFX1JFU09MVkVEKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xuICB9O1xuICAvKipcbiAgICogVGhlIGB0aGVuYCBtZXRob2QgYXR0YWNoZWQgdG8gYSBUaGVuYWJsZSB3aGVuIGl0IGhhcyByZXNvbHZlZC5cbiAgICpcbiAgICovXG5cblxuICBUd2lnLlRoZW5hYmxlLnJlc29sdmVkVGhlbiA9IGZ1bmN0aW9uIChvblJlc29sdmVkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBUd2lnLlByb21pc2UucmVzb2x2ZShvblJlc29sdmVkKHRoaXMuX3ZhbHVlKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBUd2lnLlByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBUaGUgYHRoZW5gIG1ldGhvZCBhdHRhY2hlZCB0byBhIFRoZW5hYmxlIHdoZW4gaXQgaGFzIHJlamVjdGVkLlxuICAgKlxuICAgKi9cblxuXG4gIFR3aWcuVGhlbmFibGUucmVqZWN0ZWRUaGVuID0gZnVuY3Rpb24gKG9uUmVzb2x2ZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAvLyBTaG9ydGN1dCBmb3IgcmVqZWN0ZWQgdHdpZyBwcm9taXNlc1xuICAgIGlmICghb25SZWplY3RlZCB8fCB0eXBlb2Ygb25SZWplY3RlZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gdGhpcy5fdmFsdWU7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBvblJlamVjdGVkKHZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVzdWx0ID0gVHdpZy5Qcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFR3aWcuUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gIH07XG4gIC8qKlxuICAgKiBBbiBhbHRlcm5hdGUgaW1wbGVtZW50YXRpb24gb2YgYSBQcm9taXNlIHRoYXQgZG9lcyBub3QgZnVsbHkgZm9sbG93XG4gICAqIHRoZSBzcGVjLCBidXQgaW5zdGVhZCB3b3JrcyBmdWxseSBzeW5jaHJvbm91cyB3aGlsZSBzdGlsbCBiZWluZ1xuICAgKiB0aGVuYWJsZS5cbiAgICpcbiAgICogVGhlc2UgcHJvbWlzZXMgY2FuIGJlIG1peGVkIHdpdGggcmVndWxhciBwcm9taXNlcyBhdCB3aGljaCBwb2ludFxuICAgKiB0aGUgc3luY2hyb25vdXMgYmVoYXZpb3VyIGlzIGxvc3QuXG4gICAqL1xuXG5cbiAgVHdpZy5Qcm9taXNlID0gZnVuY3Rpb24gKGV4ZWN1dG9yKSB7XG4gICAgdmFyIHN0YXRlID0gU1RBVEVfVU5LTk9XTjtcbiAgICB2YXIgdmFsdWUgPSBudWxsO1xuXG4gICAgdmFyIGNoYW5nZVN0YXRlID0gZnVuY3Rpb24gY2hhbmdlU3RhdGUobmV4dFN0YXRlLCBuZXh0VmFsdWUpIHtcbiAgICAgIHN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgdmFsdWUgPSBuZXh0VmFsdWU7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG9uUmVhZHkodikge1xuICAgICAgY2hhbmdlU3RhdGUoU1RBVEVfUkVTT0xWRUQsIHYpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uUmVqZWN0KGUpIHtcbiAgICAgIGNoYW5nZVN0YXRlKFNUQVRFX1JFSkVDVEVELCBlKTtcbiAgICB9XG5cbiAgICBydW4oZXhlY3V0b3IsIG9uUmVhZHksIG9uUmVqZWN0KTsgLy8gSWYgdGhlIHByb21pc2Ugc2V0dGxlcyByaWdodCBhZnRlciBydW5uaW5nIHRoZSBleGVjdXRvciB3ZSBjYW5cbiAgICAvLyByZXR1cm4gYSBQcm9taXNlIHdpdGggaXQncyBzdGF0ZSBhbHJlYWR5IHNldC5cbiAgICAvL1xuICAgIC8vIFR3aWcuUHJvbWlzZS5yZXNvbHZlIGFuZCBUd2lnLlByb21pc2UucmVqZWN0IGJvdGggdXNlIHRoZSBtb3JlXG4gICAgLy8gZWZmaWNpZW50IGBUd2lnLlRoZW5hYmxlYCBmb3IgdGhpcyBwdXJwb3NlLlxuXG4gICAgaWYgKHN0YXRlID09PSBTVEFURV9SRVNPTFZFRCkge1xuICAgICAgcmV0dXJuIFR3aWcuUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUgPT09IFNUQVRFX1JFSkVDVEVEKSB7XG4gICAgICByZXR1cm4gVHdpZy5Qcm9taXNlLnJlamVjdCh2YWx1ZSk7XG4gICAgfSAvLyBJZiB3ZSBtYW5hZ2VkIHRvIGdldCBoZXJlIG91ciBwcm9taXNlIGlzIGdvaW5nIHRvIHJlc29sdmUgYXN5bmNocm9ub3VzLlxuXG5cbiAgICBjaGFuZ2VTdGF0ZSA9IG5ldyBUd2lnLkZ1bGxQcm9taXNlKCk7XG4gICAgcmV0dXJuIGNoYW5nZVN0YXRlLnByb21pc2U7XG4gIH07XG4gIC8qKlxuICAgKiBQcm9taXNlIGltcGxlbWVudGF0aW9uIHRoYXQgY2FuIGhhbmRsZSBiZWluZyByZXNvbHZlZCBhdCBhbnkgbGF0ZXIgdGltZS5cbiAgICpcbiAgICovXG5cblxuICBUd2lnLkZ1bGxQcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYW5kbGVycyA9IG51bGw7IC8vIFRoZSBzdGF0ZSBoYXMgYmVlbiBjaGFuZ2VkIHRvIGVpdGhlciByZXNvbHZlLCBvciByZWplY3RcbiAgICAvLyB3aGljaCBtZWFucyB3ZSBzaG91bGQgY2FsbCB0aGUgaGFuZGxlci5cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVkKG9uUmVzb2x2ZWQpIHtcbiAgICAgIG9uUmVzb2x2ZWQocC5fdmFsdWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlamVjdGVkKG9uUmVzb2x2ZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIG9uUmVqZWN0ZWQocC5fdmFsdWUpO1xuICAgIH1cblxuICAgIHZhciBhcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQob25SZXNvbHZlZCwgb25SZWplY3RlZCkge1xuICAgICAgaGFuZGxlcnMgPSBwZW5kaW5nKGhhbmRsZXJzLCBvblJlc29sdmVkLCBvblJlamVjdGVkKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2hhbmdlU3RhdGUobmV3U3RhdGUsIHYpIHtcbiAgICAgIGlmIChwLl9zdGF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHAuX3ZhbHVlID0gdjtcbiAgICAgIHAuX3N0YXRlID0gbmV3U3RhdGU7XG4gICAgICBhcHBlbmQgPSBuZXdTdGF0ZSA9PT0gU1RBVEVfUkVTT0xWRUQgPyByZXNvbHZlZCA6IHJlamVjdGVkO1xuXG4gICAgICBpZiAoIWhhbmRsZXJzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhbmRsZXJzWzJdID09PSAtMikge1xuICAgICAgICBhcHBlbmQoaGFuZGxlcnNbMF0sIGhhbmRsZXJzWzFdKTtcbiAgICAgICAgaGFuZGxlcnMgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgYXBwZW5kKGhbMF0sIGhbMV0pO1xuICAgICAgfSk7XG4gICAgICBoYW5kbGVycyA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHAgPSBuZXcgVHdpZy5UaGVuYWJsZShmdW5jdGlvbiAob25SZXNvbHZlZCwgb25SZWplY3RlZCkge1xuICAgICAgdmFyIGhhc1Jlc29sdmVkID0gdHlwZW9mIG9uUmVzb2x2ZWQgPT09ICdmdW5jdGlvbic7IC8vIFNob3J0Y3V0IGZvciByZXNvbHZlZCB0d2lnIHByb21pc2VzXG5cbiAgICAgIGlmIChwLl9zdGF0ZSA9PT0gU1RBVEVfUkVTT0xWRUQgJiYgIWhhc1Jlc29sdmVkKSB7XG4gICAgICAgIHJldHVybiBUd2lnLlByb21pc2UucmVzb2x2ZShwLl92YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwLl9zdGF0ZSA9PT0gU1RBVEVfUkVTT0xWRUQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gVHdpZy5Qcm9taXNlLnJlc29sdmUob25SZXNvbHZlZChwLl92YWx1ZSkpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBUd2lnLlByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaGFzUmVqZWN0ZWQgPSB0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIHJldHVybiBuZXcgVHdpZy5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgYXBwZW5kKGhhc1Jlc29sdmVkID8gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNvbHZlKG9uUmVzb2x2ZWQocmVzdWx0KSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IDogcmVzb2x2ZSwgaGFzUmVqZWN0ZWQgPyBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc29sdmUob25SZWplY3RlZChlcnIpKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gOiByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY2hhbmdlU3RhdGUucHJvbWlzZSA9IHA7XG4gICAgcmV0dXJuIGNoYW5nZVN0YXRlO1xuICB9O1xuXG4gIFR3aWcuUHJvbWlzZS5kZWZhdWx0UmVzb2x2ZWQgPSBuZXcgVHdpZy5UaGVuYWJsZShUd2lnLlRoZW5hYmxlLnJlc29sdmVkVGhlbiwgdW5kZWZpbmVkLCBTVEFURV9SRVNPTFZFRCk7XG4gIFR3aWcuUHJvbWlzZS5lbXB0eVN0cmluZ1Jlc29sdmVkID0gbmV3IFR3aWcuVGhlbmFibGUoVHdpZy5UaGVuYWJsZS5yZXNvbHZlZFRoZW4sICcnLCBTVEFURV9SRVNPTFZFRCk7XG5cbiAgVHdpZy5Qcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gVHdpZy5Qcm9taXNlLmRlZmF1bHRSZXNvbHZlZDtcbiAgICB9XG5cbiAgICBpZiAoVHdpZy5pc1Byb21pc2UodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSAvLyBUd2lnIG9mdGVuIHJlc29sdmVzIHdpdGggYW4gZW1wdHkgc3RyaW5nLCB3ZSBvcHRpbWl6ZSBmb3IgdGhpc1xuICAgIC8vIHNjZW5hcmlvIGJ5IHJldHVybmluZyBhIGZpeGVkIHByb21pc2UuIFRoaXMgcmVkdWNlcyB0aGUgbG9hZCBvblxuICAgIC8vIGdhcmJhZ2UgY29sbGVjdGlvbi5cblxuXG4gICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgcmV0dXJuIFR3aWcuUHJvbWlzZS5lbXB0eVN0cmluZ1Jlc29sdmVkO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVHdpZy5UaGVuYWJsZShUd2lnLlRoZW5hYmxlLnJlc29sdmVkVGhlbiwgdmFsdWUsIFNUQVRFX1JFU09MVkVEKTtcbiAgfTtcblxuICBUd2lnLlByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAvLyBgZWAgc2hvdWxkIG5ldmVyIGJlIGEgcHJvbWlzZS5cbiAgICByZXR1cm4gbmV3IFR3aWcuVGhlbmFibGUoVHdpZy5UaGVuYWJsZS5yZWplY3RlZFRoZW4sIGUsIFNUQVRFX1JFSkVDVEVEKTtcbiAgfTtcblxuICBUd2lnLlByb21pc2UuYWxsID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBuZXcgQXJyYXkocHJvbWlzZXMubGVuZ3RoKTtcbiAgICByZXR1cm4gVHdpZy5hc3luYy5mb3JFYWNoKHByb21pc2VzLCBmdW5jdGlvbiAocCwgaW5kZXgpIHtcbiAgICAgIGlmICghVHdpZy5pc1Byb21pc2UocCkpIHtcbiAgICAgICAgcmVzdWx0c1tpbmRleF0gPSBwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChwLl9zdGF0ZSA9PT0gU1RBVEVfUkVTT0xWRUQpIHtcbiAgICAgICAgcmVzdWx0c1tpbmRleF0gPSBwLl92YWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcC50aGVuKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJlc3VsdHNbaW5kZXhdID0gdjtcbiAgICAgIH0pO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAqIEdvIG92ZXIgZWFjaCBpdGVtIGluIGEgZmFzaGlvbiBjb21wYXRpYmxlIHdpdGggVHdpZy5mb3JFYWNoLFxuICAqIGFsbG93IHRoZSBmdW5jdGlvbiB0byByZXR1cm4gYSBwcm9taXNlIG9yIGNhbGwgdGhlIHRoaXJkIGFyZ3VtZW50XG4gICogdG8gc2lnbmFsIGl0IGlzIGZpbmlzaGVkLlxuICAqXG4gICogRWFjaCBpdGVtIGluIHRoZSBhcnJheSB3aWxsIGJlIGNhbGxlZCBzZXF1ZW50aWFsbHkuXG4gICovXG5cblxuICBUd2lnLmFzeW5jLmZvckVhY2ggPSBmdW5jdGlvbiAoYXJyLCBjYWxsYmFjaykge1xuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIHZhciBpbmRleCA9IDA7XG5cbiAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgdmFyIHJlc3AgPSBudWxsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gbGVuKSB7XG4gICAgICAgICAgcmV0dXJuIFR3aWcuUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXNwID0gY2FsbGJhY2soYXJyW2luZGV4XSwgaW5kZXgpO1xuICAgICAgICBpbmRleCsrOyAvLyBXaGlsZSB0aGUgcmVzdWx0IG9mIHRoZSBjYWxsYmFjayBpcyBub3QgYSBwcm9taXNlIG9yIGl0IGlzXG4gICAgICAgIC8vIGEgcHJvbWlzZSB0aGF0IGhhcyBzZXR0bGVkIHdlIGNhbiB1c2UgYSByZWd1bGFyIGxvb3Agd2hpY2hcbiAgICAgICAgLy8gaXMgbXVjaCBmYXN0ZXIuXG4gICAgICB9IHdoaWxlICghcmVzcCB8fCAhVHdpZy5pc1Byb21pc2UocmVzcCkgfHwgcmVzcC5fc3RhdGUgPT09IFNUQVRFX1JFU09MVkVEKTtcblxuICAgICAgcmV0dXJuIHJlc3AudGhlbihuZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dCgpO1xuICB9O1xuXG4gIHJldHVybiBUd2lnO1xufTtcblxuLyoqKi8gfSksXG4vKiAzNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vLyAjIyB0d2lnLmV4cG9ydHMuanNcbi8vXG4vLyBUaGlzIGZpbGUgcHJvdmlkZXMgZXh0ZW5zaW9uIHBvaW50cyBhbmQgb3RoZXIgaG9va3MgaW50byB0aGUgdHdpZyBmdW5jdGlvbmFsaXR5LlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVHdpZykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgVHdpZy5leHBvcnRzID0ge1xuICAgIFZFUlNJT046IFR3aWcuVkVSU0lPTlxuICB9O1xuICAvKipcbiAgICogQ3JlYXRlIGFuZCBjb21waWxlIGEgdHdpZy5qcyB0ZW1wbGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtIFBhcmFtdGVyZXMgZm9yIGNyZWF0aW5nIGEgVHdpZyB0ZW1wbGF0ZS5cbiAgICpcbiAgICogQHJldHVybiB7VHdpZy5UZW1wbGF0ZX0gQSBUd2lnIHRlbXBsYXRlIHJlYWR5IGZvciByZW5kZXJpbmcuXG4gICAqL1xuXG4gIFR3aWcuZXhwb3J0cy50d2lnID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBpZCA9IHBhcmFtcy5pZDtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIHN0cmljdFZhcmlhYmxlczogcGFyYW1zLnN0cmljdF92YXJpYWJsZXMgfHwgZmFsc2UsXG4gICAgICAvLyBUT0RPOiB0dXJuIGF1dG9zY2FwZSBvbiBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uXG4gICAgICBhdXRvZXNjYXBlOiBwYXJhbXMuYXV0b2VzY2FwZSAhPT0gbnVsbCAmJiBwYXJhbXMuYXV0b2VzY2FwZSB8fCBmYWxzZSxcbiAgICAgIGFsbG93SW5saW5lSW5jbHVkZXM6IHBhcmFtcy5hbGxvd0lubGluZUluY2x1ZGVzIHx8IGZhbHNlLFxuICAgICAgcmV0aHJvdzogcGFyYW1zLnJldGhyb3cgfHwgZmFsc2UsXG4gICAgICBuYW1lc3BhY2VzOiBwYXJhbXMubmFtZXNwYWNlc1xuICAgIH07XG5cbiAgICBpZiAoVHdpZy5jYWNoZSAmJiBpZCkge1xuICAgICAgVHdpZy52YWxpZGF0ZUlkKGlkKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmRlYnVnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIFR3aWcuZGVidWcgPSBwYXJhbXMuZGVidWc7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy50cmFjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBUd2lnLnRyYWNlID0gcGFyYW1zLnRyYWNlO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gVHdpZy5UZW1wbGF0ZXMucGFyc2Vycy50d2lnKHtcbiAgICAgICAgZGF0YTogcGFyYW1zLmRhdGEsXG4gICAgICAgIHBhdGg6IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtcywgJ3BhdGgnKSA/IHBhcmFtcy5wYXRoIDogdW5kZWZpbmVkLFxuICAgICAgICBtb2R1bGU6IHBhcmFtcy5tb2R1bGUsXG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5yZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHBhcmFtcy5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKCdCb3RoIHJlZiBhbmQgaWQgY2Fubm90IGJlIHNldCBvbiBhIHR3aWcuanMgdGVtcGxhdGUuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBUd2lnLlRlbXBsYXRlcy5sb2FkKHBhcmFtcy5yZWYpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMubWV0aG9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghVHdpZy5UZW1wbGF0ZXMuaXNSZWdpc3RlcmVkTG9hZGVyKHBhcmFtcy5tZXRob2QpKSB7XG4gICAgICAgIHRocm93IG5ldyBUd2lnLkVycm9yKCdMb2FkZXIgZm9yIFwiJyArIHBhcmFtcy5tZXRob2QgKyAnXCIgaXMgbm90IGRlZmluZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBUd2lnLlRlbXBsYXRlcy5sb2FkUmVtb3RlKHBhcmFtcy5uYW1lIHx8IHBhcmFtcy5ocmVmIHx8IHBhcmFtcy5wYXRoIHx8IGlkIHx8IHVuZGVmaW5lZCwge1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIG1ldGhvZDogcGFyYW1zLm1ldGhvZCxcbiAgICAgICAgcGFyc2VyOiBwYXJhbXMucGFyc2VyIHx8ICd0d2lnJyxcbiAgICAgICAgYmFzZTogcGFyYW1zLmJhc2UsXG4gICAgICAgIG1vZHVsZTogcGFyYW1zLm1vZHVsZSxcbiAgICAgICAgcHJlY29tcGlsZWQ6IHBhcmFtcy5wcmVjb21waWxlZCxcbiAgICAgICAgYXN5bmM6IHBhcmFtcy5hc3luYyxcbiAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgfSwgcGFyYW1zLmxvYWQsIHBhcmFtcy5lcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5ocmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBUd2lnLlRlbXBsYXRlcy5sb2FkUmVtb3RlKHBhcmFtcy5ocmVmLCB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgbWV0aG9kOiAnYWpheCcsXG4gICAgICAgIHBhcnNlcjogcGFyYW1zLnBhcnNlciB8fCAndHdpZycsXG4gICAgICAgIGJhc2U6IHBhcmFtcy5iYXNlLFxuICAgICAgICBtb2R1bGU6IHBhcmFtcy5tb2R1bGUsXG4gICAgICAgIHByZWNvbXBpbGVkOiBwYXJhbXMucHJlY29tcGlsZWQsXG4gICAgICAgIGFzeW5jOiBwYXJhbXMuYXN5bmMsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgIH0sIHBhcmFtcy5sb2FkLCBwYXJhbXMuZXJyb3IpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gVHdpZy5UZW1wbGF0ZXMubG9hZFJlbW90ZShwYXJhbXMucGF0aCwge1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIG1ldGhvZDogJ2ZzJyxcbiAgICAgICAgcGFyc2VyOiBwYXJhbXMucGFyc2VyIHx8ICd0d2lnJyxcbiAgICAgICAgYmFzZTogcGFyYW1zLmJhc2UsXG4gICAgICAgIG1vZHVsZTogcGFyYW1zLm1vZHVsZSxcbiAgICAgICAgcHJlY29tcGlsZWQ6IHBhcmFtcy5wcmVjb21waWxlZCxcbiAgICAgICAgYXN5bmM6IHBhcmFtcy5hc3luYyxcbiAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgfSwgcGFyYW1zLmxvYWQsIHBhcmFtcy5lcnJvcik7XG4gICAgfVxuICB9OyAvLyBFeHRlbmQgVHdpZyB3aXRoIGEgbmV3IGZpbHRlci5cblxuXG4gIFR3aWcuZXhwb3J0cy5leHRlbmRGaWx0ZXIgPSBmdW5jdGlvbiAoZmlsdGVyLCBkZWZpbml0aW9uKSB7XG4gICAgVHdpZy5maWx0ZXIuZXh0ZW5kKGZpbHRlciwgZGVmaW5pdGlvbik7XG4gIH07IC8vIEV4dGVuZCBUd2lnIHdpdGggYSBuZXcgZnVuY3Rpb24uXG5cblxuICBUd2lnLmV4cG9ydHMuZXh0ZW5kRnVuY3Rpb24gPSBmdW5jdGlvbiAoZm4sIGRlZmluaXRpb24pIHtcbiAgICBUd2lnLl9mdW5jdGlvbi5leHRlbmQoZm4sIGRlZmluaXRpb24pO1xuICB9OyAvLyBFeHRlbmQgVHdpZyB3aXRoIGEgbmV3IHRlc3QuXG5cblxuICBUd2lnLmV4cG9ydHMuZXh0ZW5kVGVzdCA9IGZ1bmN0aW9uICh0ZXN0LCBkZWZpbml0aW9uKSB7XG4gICAgVHdpZy50ZXN0LmV4dGVuZCh0ZXN0LCBkZWZpbml0aW9uKTtcbiAgfTsgLy8gRXh0ZW5kIFR3aWcgd2l0aCBhIG5ldyBkZWZpbml0aW9uLlxuXG5cbiAgVHdpZy5leHBvcnRzLmV4dGVuZFRhZyA9IGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gICAgVHdpZy5sb2dpYy5leHRlbmQoZGVmaW5pdGlvbik7XG4gIH07IC8vIFByb3ZpZGUgYW4gZW52aXJvbm1lbnQgZm9yIGV4dGVuZGluZyBUd2lnIGNvcmUuXG4gIC8vIENhbGxzIGZuIHdpdGggdGhlIGludGVybmFsIFR3aWcgb2JqZWN0LlxuXG5cbiAgVHdpZy5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uIChmbikge1xuICAgIGZuKFR3aWcpO1xuICB9O1xuICAvKipcbiAgICogUHJvdmlkZSBhbiBleHRlbnNpb24gZm9yIHVzZSB3aXRoIGV4cHJlc3MgMi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBUaGUgdGVtcGxhdGUgbWFya3VwLlxuICAgKiBAcGFyYW0ge2FycmF5fSBvcHRpb25zIFRoZSBleHByZXNzIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHJlbmRlcmVkIHRlbXBsYXRlLlxuICAgKi9cblxuXG4gIFR3aWcuZXhwb3J0cy5jb21waWxlID0gZnVuY3Rpb24gKG1hcmt1cCwgb3B0aW9ucykge1xuICAgIHZhciBpZCA9IG9wdGlvbnMuZmlsZW5hbWU7XG4gICAgdmFyIHBhdGggPSBvcHRpb25zLmZpbGVuYW1lOyAvLyBUcnkgdG8gbG9hZCB0aGUgdGVtcGxhdGUgZnJvbSB0aGUgY2FjaGVcblxuICAgIHZhciB0ZW1wbGF0ZSA9IG5ldyBUd2lnLlRlbXBsYXRlKHtcbiAgICAgIGRhdGE6IG1hcmt1cCxcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICBpZDogaWQsXG4gICAgICBvcHRpb25zOiBvcHRpb25zLnNldHRpbmdzWyd0d2lnIG9wdGlvbnMnXVxuICAgIH0pOyAvLyBUd2lnLlRlbXBsYXRlcy5sb2FkKGlkKSB8fFxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGVtcGxhdGUucmVuZGVyKGNvbnRleHQpO1xuICAgIH07XG4gIH07XG4gIC8qKlxuICAgKiBQcm92aWRlIGFuIGV4dGVuc2lvbiBmb3IgdXNlIHdpdGggZXhwcmVzcyAzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgbG9jYXRpb24gb2YgdGhlIHRlbXBsYXRlIGZpbGUgb24gZGlzay5cbiAgICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IFRoZSBvcHRpb25zIG9yIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBjYWxsYmFjay5cbiAgICpcbiAgICogQHRocm93cyBUd2lnLkVycm9yXG4gICAqL1xuXG5cbiAgVHdpZy5leHBvcnRzLnJlbmRlckZpbGUgPSBmdW5jdGlvbiAocGF0aCwgb3B0aW9ucywgZm4pIHtcbiAgICAvLyBIYW5kbGUgY2FsbGJhY2sgaW4gb3B0aW9uc1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZm4gPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBzZXR0aW5ncyA9IG9wdGlvbnMuc2V0dGluZ3MgfHwge307IC8vIE1peGluIGFueSBvcHRpb25zIHByb3ZpZGVkIHRvIHRoZSBleHByZXNzIGFwcC5cblxuICAgIHZhciB2aWV3T3B0aW9ucyA9IHNldHRpbmdzWyd0d2lnIG9wdGlvbnMnXTtcbiAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIGJhc2U6IHNldHRpbmdzLnZpZXdzLFxuICAgICAgbG9hZDogZnVuY3Rpb24gbG9hZCh0ZW1wbGF0ZSkge1xuICAgICAgICAvLyBSZW5kZXIgYW5kIHJldHVybiB0ZW1wbGF0ZSBhcyBhIHNpbXBsZSBzdHJpbmcsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdHdpZ2pzL3R3aWcuanMvcHVsbC8zNDggZm9yIG1vcmUgaW5mb3JtYXRpb25cbiAgICAgICAgaWYgKCF2aWV3T3B0aW9ucyB8fCAhdmlld09wdGlvbnMuYWxsb3dBc3luYykge1xuICAgICAgICAgIGZuKG51bGwsIFN0cmluZyh0ZW1wbGF0ZS5yZW5kZXIob3B0aW9ucykpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0ZW1wbGF0ZS5yZW5kZXJBc3luYyhvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgICByZXR1cm4gZm4obnVsbCwgb3V0KTtcbiAgICAgICAgfSwgZm4pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodmlld09wdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIG9wdGlvbiBpbiB2aWV3T3B0aW9ucykge1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodmlld09wdGlvbnMsIG9wdGlvbikpIHtcbiAgICAgICAgICBwYXJhbXNbb3B0aW9uXSA9IHZpZXdPcHRpb25zW29wdGlvbl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBUd2lnLmV4cG9ydHMudHdpZyhwYXJhbXMpO1xuICB9OyAvLyBFeHByZXNzIDMgaGFuZGxlclxuXG5cbiAgVHdpZy5leHBvcnRzLl9fZXhwcmVzcyA9IFR3aWcuZXhwb3J0cy5yZW5kZXJGaWxlO1xuICAvKipcbiAgICogU2hvdWQgVHdpZy5qcyBjYWNoZSB0ZW1wbGF0ZXMuXG4gICAqIERpc2FibGUgZHVyaW5nIGRldmVsb3BtZW50IHRvIHNlZSBjaGFuZ2VzIHRvIHRlbXBsYXRlcyB3aXRob3V0XG4gICAqIHJlbG9hZGluZywgYW5kIGRpc2FibGUgaW4gcHJvZHVjdGlvbiB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNhY2hlXG4gICAqL1xuXG4gIFR3aWcuZXhwb3J0cy5jYWNoZSA9IGZ1bmN0aW9uIChjYWNoZSkge1xuICAgIFR3aWcuY2FjaGUgPSBjYWNoZTtcbiAgfTsgLy8gV2UgbmVlZCB0byBleHBvcnQgdGhlIHBhdGggbW9kdWxlIHNvIHdlIGNhbiBlZmZlY3RpdmVseSB0ZXN0IGl0XG5cblxuICBUd2lnLmV4cG9ydHMucGF0aCA9IFR3aWcucGF0aDsgLy8gRXhwb3J0IG91ciBmaWx0ZXJzLlxuICAvLyBSZXNvbHZlcyAjMzA3XG5cbiAgVHdpZy5leHBvcnRzLmZpbHRlcnMgPSBUd2lnLmZpbHRlcnM7IC8vIEV4cG9ydCBvdXIgdGVzdHMuXG5cbiAgVHdpZy5leHBvcnRzLnRlc3RzID0gVHdpZy50ZXN0cztcbiAgVHdpZy5leHBvcnRzLlByb21pc2UgPSBUd2lnLlByb21pc2U7XG4gIHJldHVybiBUd2lnO1xufTtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7IiwiLyogKGlnbm9yZWQpICovIl0sInNvdXJjZVJvb3QiOiIifQ==